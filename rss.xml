<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Colmugx &#39;s Blog</title>
    <link>https://colmugx.github.io/blog/</link>
    <atom:link href="/blog/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>Co1MugX Blog</description>
    <pubDate>Sun, 21 Jun 2020 05:25:02 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>利用 electron 爬图片</title>
      <link>https://colmugx.github.io/blog/2020/06/21/electron-crawler/</link>
      <guid>https://colmugx.github.io/blog/2020/06/21/electron-crawler/</guid>
      <pubDate>Sun, 21 Jun 2020 03:51:10 GMT</pubDate>
      <description>
      
        &lt;p&gt;有个做广告设计的朋友，自己开个小工作室，平时接些小广告设计维持生活。但总会遇到一些甲方拿着某个站点的图片，让他用这个图片给他做广告牌或者海报。就这样，作为老切图仔就一直在帮他「从网站里拿出图片」这种脏累活。想着是不是可以干脆送他个工具，这样他就可以自己玩了&lt;br&gt;
&lt;strong&gt;（不是很推荐这种操作，但是毕竟要恰饭要苟活，而且这种外包单，甲方是这样的）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想了一下，切图仔唯一高效 GUI 的选型只有 &lt;code&gt;electron&lt;/code&gt; 了，没得选。但是这次有点特别，因为 &lt;code&gt;electron&lt;/code&gt; 的特殊性，我有了些想法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;electron = node + chromium，都有个完整浏览器了 484 不需要无头就可以加载 remote 然后直接获取资源？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里用的模板是之前实验服务一体化的模板 &lt;a href=&quot;https://github.com/colmugx/electron-react-koa-template&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;electron-react-koa-template&lt;/a&gt;，然后删除了&lt;code&gt;server&lt;/code&gt;…&lt;/p&gt;
&lt;p&gt;删了&lt;code&gt;server&lt;/code&gt;……&lt;/p&gt;
&lt;h2 id=&quot;TL-DR&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;webview&lt;/li&gt;
&lt;li&gt;获取资源&lt;/li&gt;
&lt;li&gt;提供下载&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>有个做广告设计的朋友，自己开个小工作室，平时接些小广告设计维持生活。但总会遇到一些甲方拿着某个站点的图片，让他用这个图片给他做广告牌或者海报。就这样，作为老切图仔就一直在帮他「从网站里拿出图片」这种脏累活。想着是不是可以干脆送他个工具，这样他就可以自己玩了<br><strong>（不是很推荐这种操作，但是毕竟要恰饭要苟活，而且这种外包单，甲方是这样的）</strong></p><p>想了一下，切图仔唯一高效 GUI 的选型只有 <code>electron</code> 了，没得选。但是这次有点特别，因为 <code>electron</code> 的特殊性，我有了些想法</p><blockquote><p>electron = node + chromium，都有个完整浏览器了 484 不需要无头就可以加载 remote 然后直接获取资源？</p></blockquote><p>这里用的模板是之前实验服务一体化的模板 <a href="https://github.com/colmugx/electron-react-koa-template" target="_blank" rel="noopener">electron-react-koa-template</a>，然后删除了<code>server</code>…</p><p>删了<code>server</code>……</p><h2 id="TL-DR">TL;DR</h2><ul><li>webview</li><li>获取资源</li><li>提供下载</li></ul><a id="more"></a><h2 id="webview">webview</h2><p>这里还有一个方案，<code>BrowserWindow</code>，然后<code>{show: false}</code>让这个窗口不显示，用这个窗体当无头</p><p>不过在之前开发 hexo 编辑器的时候就有用过，当时用来做内嵌视图打开博客预览地址，还有切换线上地址用的，这里可以用用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webview = <span class="built_in">document</span>.createElement(<span class="string">'webview'</span>)</span><br><span class="line"><span class="comment">// 当页面加载完成之后会触发这个事件，可以继续做接下来的事情</span></span><br><span class="line">webview.addEventListener(<span class="string">'dom-ready'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>于是封装一下变成</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">const</span> webview = <span class="built_in">document</span>.createElement(<span class="string">'webview'</span>)</span><br><span class="line">  <span class="comment">// 保险起见</span></span><br><span class="line">  webview.useragent</span><br><span class="line">    = <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_2) '</span></span><br><span class="line">    + <span class="string">'AppleWebKit/537.36 (KHTML, like Gecko) '</span></span><br><span class="line">    + <span class="string">'Chrome/81.0.4044.129 Safari/537.36 Edg/81.0.416.68'</span></span><br><span class="line">  webview.addEventListener(<span class="string">'dom-ready'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(webview)</span><br><span class="line">  <span class="keyword">this</span>.webview = webview</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">search(url) &#123;</span><br><span class="line">  <span class="keyword">this</span>.webview.src = url</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一套操作之后，你会发现什么都看不到……这个时候你会先怀疑你上面写的这个 <code>createElement</code>，是不是 electron 的 dom 不可以直接创建（匪夷所思），于是你将 <code>&lt;webview /&gt;</code> 直接放到 <code>render</code> 里，发现依然什么都没有</p><h3 id="坑：安全性">坑：安全性</h3><p>这里使用的是<code>electron@6</code>，查了一番之后，发现<code>electron@5</code>加了一个安全性设定：需要允许<code>webviewTag</code></p><p>于是在主窗体需要一行配置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">  webPreferences: &#123;</span><br><span class="line">    <span class="comment">// 这里</span></span><br><span class="line">    webviewTag: <span class="literal">true</span>,</span><br><span class="line">    nodeIntegration: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后你就能看到页面被加载</p><p>接着，确认能加载之后就可以大方的把 <code>webview</code> 隐藏起来了</p><h2 id="解析资源">解析资源</h2><p>这里计划是直接尝试获取 <code>webview</code> 的资源，但是没找到方法，只能退而求其次：爬tmd。那么这就需要一个拥有 80 年爬虫经验的工具：<code>cheerio</code></p><p>与现在普遍的互联网上某些技术社区所分享的「一小时精通 nodejs 爬虫」、「教你怎么用 nodejs 爬妹子图」等文章不同 —— <strong>他们对 SPA 一点办法都没有！</strong></p><p>我这不一样，我有浏览器，在 <code>dom-ready</code> 的时候也意味着真实结构已经加载到了（亲测！专门拿 SPA 试的！</p><h3 id="执行-JavaScript">执行 JavaScript</h3><p><code>webview</code> 有个方法 <code>&lt;webview&gt;.executeJavaScript(code[, userGesture])</code>，所以可以通过执行一段 js 把 html 拿出来，有股叉 ass ass 的味道</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webview</span><br><span class="line">  .executeJavaScript(</span><br><span class="line">    <span class="string">`function gethtml () &#123; return new Promise(resolve =&gt; resolve(document.documentElement.innerHTML)) &#125;; gethtml();`</span>,</span><br><span class="line">  )</span><br><span class="line">  .then(<span class="function">(<span class="params">html</span>) =&gt;</span> &#123;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>这个时候<code>html</code>即一个完整的<code>html</code>，把执行放到<code>dom-ready</code>，接下来就交给 ipc 表演了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">webview.addEventListener(<span class="string">'dom-ready'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  webview</span><br><span class="line">  .executeJavaScript(</span><br><span class="line">    <span class="string">`function gethtml () &#123; return new Promise(resolve =&gt; resolve(document.documentElement.innerHTML)) &#125;; gethtml();`</span>,</span><br><span class="line">  )</span><br><span class="line">  .then(<span class="function"><span class="params">html</span> =&gt;</span> &#123;</span><br><span class="line">    ipcRenderer.send(<span class="string">'ganhuo'</span>, html)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="node-cheerio">node/cheerio</h3><p>主要是 <code>cheerio</code> 是一个 node 方的应用，依然是在 <code>main</code> 层操作更安心一些</p><p>准备一个 ipc 监听，刚刚那个是<code>ganhuo</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ipcMain.on(<span class="string">'ganhuo'</span>, <span class="function">(<span class="params">e, arg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> $ = cheerio.load(arg)</span><br><span class="line">  <span class="comment">// 各种教程都能看到的</span></span><br><span class="line">  <span class="comment">// 这里没多余操作，是个 img 就拿走</span></span><br><span class="line">  <span class="comment">// 接着 reply 回 renderer</span></span><br><span class="line">  <span class="keyword">const</span> imgs = $(<span class="string">'body'</span>).find(<span class="string">'img'</span>).map(<span class="function">(<span class="params">idx, ele</span>) =&gt;</span> $(ele).attr(<span class="string">'src'</span>)).get()</span><br><span class="line">  e.reply(<span class="string">'chuhuo'</span>, imgs)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>renderer</code> 边准备一个接收，这波结束</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  ipcRenderer.on(<span class="string">'chuhuo'</span>, <span class="function">(<span class="params">e, result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      imgs: result,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="展示-下载">展示/下载</h2><p>UI库直接用 <code>antd</code>，依然是放心产品</p><p>这里草草带过：用 <code>form</code>、<code>input</code>、<code>button</code> 处理一个简单地址栏，用 <code>card</code> 展示图片，至于要不要<code>funcybox</code>之类的随缘</p><p>继续依赖 node 层就可以做到下载文件保存文件的操作，可以拿到图片信息(exif)，获取分辨率以及过滤分辨率啥的</p><h2 id="总结">总结</h2><p>到这里能发现个问题：爬取、加载，如果再算上图片信息解析等操作的话，图片妥妥的获取了三次。虽说因为图片资源都相同，可能有两次获取的是<code>disk cache</code></p><p>这里不开源了，一股 POC 味</p><h2 id="参考链接">参考链接</h2><ul><li><a href="https://www.electronjs.org/docs/api/webview-tag" target="_blank" rel="noopener">webview tag</a></li><li><a href="https://en.wikipedia.org/wiki/Exif" target="_blank" rel="noopener">Exif</a></li></ul>]]></content:encoded>
      
      <comments>https://colmugx.github.io/blog/2020/06/21/electron-crawler/#disqus_thread</comments>
    </item>
    
    <item>
      <title>整一个家庭服务器记录</title>
      <link>https://colmugx.github.io/blog/2020/06/07/home-server/</link>
      <guid>https://colmugx.github.io/blog/2020/06/07/home-server/</guid>
      <pubDate>Sun, 07 Jun 2020 05:57:46 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;准备&quot;&gt;准备&lt;/h2&gt;
&lt;p&gt;我自己使用的是树莓派组，可以选择的有很多，x86的开发板、淘汰的笔记本。废物再生计划！&lt;/p&gt;
&lt;h3 id=&quot;系统选择&quot;&gt;系统选择&lt;/h3&gt;
&lt;p&gt;推荐三个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.raspberrypi.org/downloads/raspbian/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;raspbian&lt;/a&gt;（树莓派）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://clearlinux.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;clear linux&lt;/a&gt;（英特尔CPU）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.debian.org/index.zh-cn.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;debian&lt;/a&gt;（传统服务器系统）&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="准备">准备</h2><p>我自己使用的是树莓派组，可以选择的有很多，x86的开发板、淘汰的笔记本。废物再生计划！</p><h3 id="系统选择">系统选择</h3><p>推荐三个：</p><ul><li><a href="https://www.raspberrypi.org/downloads/raspbian/" target="_blank" rel="noopener">raspbian</a>（树莓派）</li><li><a href="https://clearlinux.org/" target="_blank" rel="noopener">clear linux</a>（英特尔CPU）</li><li><a href="https://www.debian.org/index.zh-cn.html" target="_blank" rel="noopener">debian</a>（传统服务器系统）</li><li>……</li></ul><a id="more"></a><p>树莓派的话直接用 raspbian 就好了，无论是驱动（如果用到了GPIO）还是稳定性</p><p><code>clearlinux</code> 可以推荐，这里并不是只有英特尔平台才能运行，而是这个系统针对英特尔平台有特殊优化，默认会启动所有优化。除此之外这也是一个滚动型系统，并且定制性强，也很轻便，最小安装下体积非常小。亲测同样的功能项，配置下来后对比 <code>archlinux</code> 的体积会小一点。</p><p>最后就是传统一点同时寻求帮助比较方便的 debian，当然 centos 也行。只是自己已有一段时间就不接触RPM系linux而感到陌生了…（respbian 也是 debian 型）</p><h3 id="系统安装">系统安装</h3><p>这里选择的是最小安装，如果对桌面有需求的话可以默认安装</p><p>建议不需要桌面，服务器类型的东西，一旦配置都做完之后，桌面就只是一个占用性能的鸡肋了</p><h3 id="系统配置">系统配置</h3><p>大概有这么几点是最好完成的：</p><ul><li>连接网络（有线或者无线）</li><li>设置开机自动连接网络</li><li>固定ip</li><li>打开SSH</li></ul><p>无桌面的系统可能需要自己去安装一些必要的网络管理工具，这里可以寻找各系统的 wiki。但基本上没有桌面的网络设置辅助的话，手动设置网络都需要再自行设置开启自动连接这一操作，需要记得设置</p><p>一般家庭网络都是路由器通过DHCP分发 ip，如果作为服务器的主机 ip 不确定的话日后操作会比较麻烦，所以索性直接静态固定下来，只是为了方便</p><p>打开SSH只是为了以后配置和操作都可以直接用其他设备连接，不需要再去动服务器</p><h2 id="服务">服务</h2><h3 id="docker">docker</h3><p>安装方法可以直接阅读官方文档：<a href="https://docs.docker.com/install/linux/docker-ce/debian/" target="_blank" rel="noopener">Get Docker Engine - Community for Debian</a>，如果选择 clear linux 等其他系统，可以直接依据官方提供方案（如 clear linux 集市）</p><p>需要注意的是，你需要了解你的CPU指令类型 —— x64/86 或者 arm32/64 。例如树莓派 3b 使用的指令集是arm7l，属于 32 位处理器，那么接下来的工作都应该寻找 32 位 arm 处理器的解决方案</p><p>可以使用 <code>uname -m</code> 来查看目前平台使用的处理器类型</p><h3 id="portainer">portainer</h3><p>这是一个可以管理 docker 容器的控制面板，可以对容器进行图形化的管理，控制运行状态比如运行停止重启、容器配置、删除容器镜像、拉取镜像构建、重新构建容器等等</p><p>应用本身开源：<a href="https://github.com/portainer/portainer" target="_blank" rel="noopener">portainer/portainer: Making Docker management easy.</a></p><p>推荐安装方式：直接 docker 拉取安装，镜像为官方提供，也提供了 arm 版本：<a href="https://hub.docker.com/r/portainer/portainer/" target="_blank" rel="noopener">https://hub.docker.com/r/portainer/portainer/</a>。使用单机版本就好了</p><h3 id="影音服务">影音服务</h3><p>一般来说需要两种东西：下载机 + 媒体服务器</p><h4 id="下载（aria2）">下载（aria2）</h4><p>如果是 linux 纯命令下载机应该非 aria2 莫属了</p><p>这里推荐一个项目：<a href="https://github.com/wahyd4/aria2-ariang-docker" target="_blank" rel="noopener">wahyd4/aria2-ariang-docker</a></p><p>这样下载机与在线文件管理就有了（网盘应用不喜欢可以换一个，比如 <code>Nextcloud</code>）</p><h4 id="媒体服务">媒体服务</h4><p>媒体服务有很多种协议，最后选择了 upnp dlna。原因很简单：</p><ul><li>通用性</li><li>综合来看 dlna 速度最快，相对稳定（亲测长时间观看情况下能把树莓派看挂…</li></ul><p>大多数电视厂商在自带媒体播放器也会内置 dlna 协议，所以综合来看 dlna 面对客户端也是麻烦最少的一种方式</p><p>那么服务应用就选择 minidlna 了，x86_64 可以直接使用这个镜像：<a href="https://hub.docker.com/r/vladgh/minidlna/" target="_blank" rel="noopener">https://hub.docker.com/r/vladgh/minidlna/</a></p><p>可惜的是arm 的 minidlna 最好是自己构建镜像，如果嫌麻烦的话，这个镜像未尝不能接受：<a href="https://hub.docker.com/r/fmartingr/minidlna-arm" target="_blank" rel="noopener">https://hub.docker.com/r/fmartingr/minidlna-arm</a></p><p>这里的网络需要设置，默认下 docker 会使用 docker 网段，所以需要允许容器使用 <code>host</code>，这样方便家庭网络环境中的设备自动寻找，简单来说就是方便电视机主动发现。应用配置没有太多讲究，只需要保证所映射目录下有 <code>Movie</code> , <code>Music</code> , <code>Picture</code> 目录即可，dlna 服务会自动识别</p><p>至于播放器的话，其他平台支持 dlna 的播放器有很多，安卓可以使用 vlc，iOS可以使用 infuse 等等</p><h4 id="Plex">Plex</h4><p>媒体服务还有一个选择：Plex</p><p>可以说 Plex 才是专业的影音库，它可以对你的电影和音乐进行分类，电影可以自动获取电影信息、下载封面等。如果用过早期Windows Vista 或者 7 专业版，都会见到一个叫做 Windows Media Center 的应用，跟这个相似</p><p>具体可以查看官方站点：<a href="https://www.plex.tv/zh/" target="_blank" rel="noopener">https://www.plex.tv/zh/</a></p><h2 id="最后">最后</h2><p>总的来说，用 NAS 主要还是存储功能， webdav、time mechine 啥的都可以依赖 NAS 应用（可能）的服务</p><p>但是自己搭建独立服务器目的是「全可控」，例如我现在有些玩具（闹钟，永远滴神），就在依赖这个服务（websocket 拉满！</p><p>比较不推荐的是在家<strong>搭建 Git 服务器</strong>，我不知道普通人有什么样的代码是需要藏着的；还有 <strong>NPM 服务器</strong>，你不会用到几次的，各种镜像源很快，而且 npm 包会塞爆你服务器硬盘</p>]]></content:encoded>
      
      <comments>https://colmugx.github.io/blog/2020/06/07/home-server/#disqus_thread</comments>
    </item>
    
    <item>
      <title>我如何用 hammerspoon 实现剪贴板历史</title>
      <link>https://colmugx.github.io/blog/2020/06/04/hammerspoon-clipboard/</link>
      <guid>https://colmugx.github.io/blog/2020/06/04/hammerspoon-clipboard/</guid>
      <pubDate>Thu, 04 Jun 2020 14:30:36 GMT</pubDate>
      <description>
      
        &lt;p&gt;这应该是连载得最近的一次，书接上回：&lt;a href=&quot;/blog/2020/06/02/hammerspoon-ts/&quot;&gt;《或许可以用 TypeScript 编写 hammerspoon》&lt;/a&gt;（也就是下面那篇）&lt;/p&gt;
&lt;p&gt;这里只会描述通过 &lt;code&gt;TypeScript&lt;/code&gt; 实现的过程&lt;/p&gt;
&lt;p&gt;以下内容可能产生不适（因为&lt;code&gt;hammerspoon&lt;/code&gt;的 &lt;code&gt;d.ts&lt;/code&gt; 全是 &lt;code&gt;interface&lt;/code&gt; 一把梭，编码不好看）&lt;/p&gt;
&lt;h2 id=&quot;TL-DR&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;创建界面&lt;/li&gt;
&lt;li&gt;实现剪贴板读取&lt;/li&gt;
&lt;li&gt;存储数据&lt;/li&gt;
&lt;li&gt;绑定快捷键&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>这应该是连载得最近的一次，书接上回：<a href="/blog/2020/06/02/hammerspoon-ts/">《或许可以用 TypeScript 编写 hammerspoon》</a>（也就是下面那篇）</p><p>这里只会描述通过 <code>TypeScript</code> 实现的过程</p><p>以下内容可能产生不适（因为<code>hammerspoon</code>的 <code>d.ts</code> 全是 <code>interface</code> 一把梭，编码不好看）</p><h2 id="TL-DR">TL;DR</h2><ul><li>创建界面</li><li>实现剪贴板读取</li><li>存储数据</li><li>绑定快捷键</li></ul><a id="more"></a><h2 id="创建界面">创建界面</h2><p><code>hammerspoon</code>有很多种交互接口，其中<code>chooser</code>就是某小黑帽那种对话式弹窗，用这个挺合适的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// choice 就是当你对着选项按下 enter 之后，这个被选择对象的内容</span></span><br><span class="line"><span class="keyword">const</span> completionFn = <span class="function"><span class="params">choice</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 一般来说这个判断不可省略，这样可以方便排除取消的情况</span></span><br><span class="line">  <span class="keyword">if</span> (choice) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> chooser = hs.chooser.new(completionFn)</span><br></pre></td></tr></table></figure><p>这样<code>chooser</code>就是一个实例，可以使用相应的方法，例如显示或隐藏</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chooser.show()</span><br><span class="line">chooser.hide()</span><br></pre></td></tr></table></figure><h2 id="剪贴板操作">剪贴板操作</h2><p>关于剪贴板的操作都已经封装在<code>hs.pasteboard</code>这个模块中，通过两个函数获取到我们对于剪贴板历史比较常用的两种内容类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pasteboard.readString() <span class="comment">// 读取最后一次剪贴板的文本</span></span><br><span class="line">pasteboard.readImage() <span class="comment">// 读取最后一次剪贴板的图片数据</span></span><br></pre></td></tr></table></figure><p>如何得知我的剪贴板已经有新内容了？社区基本上的方案都是通过对比剪贴次数来判定更新的，如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pasteboard.changeCount()</span><br></pre></td></tr></table></figure><p>所以操作大概是：使用定时器，在若干时间后检查一次次数，如发生改变即更新剪贴板历史</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clipboard = <span class="keyword">new</span> Clipboard()</span><br><span class="line"><span class="comment">// 我选择 1s 检查一次</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> clipWatcher = hs.timer.new(<span class="number">1</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> now = hs.pasteboard.changeCount()</span><br><span class="line">  <span class="keyword">if</span> (now !== preCount) &#123;</span><br><span class="line">    pcall(clipboard.save.bind(clipboard))</span><br><span class="line">    preCount = now</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">clipWatcher.start()</span><br></pre></td></tr></table></figure><h2 id="操作数据">操作数据</h2><h3 id="识别数据">识别数据</h3><p>只要出现对比差异，就可以执行保存操作</p><p>日常使用中一般会复制到文本和图像（截图），先做到如何区分来源类型</p><p>通过苹果开发者文档关于 <a href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html#//apple_ref/doc/uid/TP40001319-CH202-CHDHIJDE" target="_blank" rel="noopener">UTI</a>，可以得到大概文本就是<code>public.plain-text</code>，图像就是<code>public.{pic format}</code></p><p>我截图是<code>png</code>的，舍远求近直接只识别我自己使用的两种格式：<code>public.png</code>, <code>public.utf8-plain-text</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">save() &#123;</span><br><span class="line">  <span class="keyword">const</span> types = hs.pasteboard.contentTypes&lt;ModelChoice[<span class="string">'type'</span>]&gt;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">type</span> of types) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isImgType(<span class="keyword">type</span>)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.saveImage(<span class="keyword">type</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isTextType(<span class="keyword">type</span>)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.saveText(<span class="keyword">type</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="保存数据">保存数据</h3><p>对应的，当知道数据来源是什么类型之后就可以<a href="#%E5%89%AA%E8%B4%B4%E6%9D%BF%E6%93%8D%E4%BD%9C">相应操作</a>了</p><p>保存我采用了<code>sqlite</code>，因为 hammerspoon 带了数据库操作模块<code>hs.sqlite3</code>。主要原因：</p><ul><li>timer可能会崩溃导致不会继续捕获，重启服务数据丢失</li><li>数据库查询比较快</li><li>数据库我还另有其用，不亏</li></ul><p>这部分直接看 github</p><h2 id="启用">启用</h2><h3 id="绑定快捷键">绑定快捷键</h3><p>hammerspoon 的快捷键模块<code>hs.hotkey</code>，可以将快捷键绑定到具体操作上</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hs.hotkey.bind(clipboardConf.hotkey[<span class="number">0</span>], clipboardConf.hotkey[<span class="number">1</span>], <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  clipboard.show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>一套组合键，<code>chooser</code> 就可以显示了</p><h3 id="加载内容">加载内容</h3><p>一般来说，在显示对话框时再去加载数据可以保证数据是新的，所以使用<code>chooser.choices(choices)</code>加载数据，再<code>chooser.show()</code>展示</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.chooser!.choices(choices)</span><br><span class="line"><span class="keyword">this</span>.chooser!.show()</span><br></pre></td></tr></table></figure><p>至于获取数据的形式，就是需要查询数据库，还是查询文件，还是另有其他方式而已</p><h2 id="参考连接">参考连接</h2><p><a href="https://ahonn.me/blog/how-to-implement-clipboard-history-with-hammerspoon" target="_blank" rel="noopener">《如何使用 Hammerspoon 实现剪贴板历史》 —— Ahonn</a><br><a href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html#//apple_ref/doc/uid/TP40001319-CH202-CHDHIJDE" target="_blank" rel="noopener">Uniform Type Identifier Concepts</a></p>]]></content:encoded>
      
      <comments>https://colmugx.github.io/blog/2020/06/04/hammerspoon-clipboard/#disqus_thread</comments>
    </item>
    
    <item>
      <title>或许可以用 TypeScript 编写 hammerspoon</title>
      <link>https://colmugx.github.io/blog/2020/06/02/hammerspoon-ts/</link>
      <guid>https://colmugx.github.io/blog/2020/06/02/hammerspoon-ts/</guid>
      <pubDate>Tue, 02 Jun 2020 14:59:20 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;code&gt;lua&lt;/code&gt; 这个语言真的有意思，它由 C 语言构成，又实现了 C 语言所没有的「对象」。早在不知道哪年搞 &lt;code&gt;cocos2d&lt;/code&gt; 的时候，就接触了这个语言&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hammerspoon&lt;/code&gt; 也不是什么新鲜东西了，早在 18 年，公司内部一次「杂鱼分享会」就有人提到了这个工具 —— 快速将光标切到目标显示器以及窗口调整&lt;/p&gt;
&lt;p&gt;早期是用过一段时间，写了一个代替小黑帽🎩的工具，后来不了了之。主要还是觉得现在不想用这个语言，太阴间了&lt;/p&gt;
&lt;p&gt;当然还有其他方案，比如常见的用到了 &lt;code&gt;moonscript&lt;/code&gt;，这是一个类 &lt;code&gt;coffeescript&lt;/code&gt; 的语言，属于 lua 生态圈的东西。但用这个就意味着你需要在本机构建一个 lua 环境（luarock），这么一想那不想干了，现在不用 lua 了还留一个完全不用的开发环境&lt;/p&gt;
&lt;p&gt;前些日子关注到有一个项目 &lt;a href=&quot;https://github.com/TypeScriptToLua/TypeScriptToLua&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TypeScriptToLua / TypeScriptToLua&lt;/a&gt;，一直没尝试，这波机会刚好。而且老前端了，谁还没有个 typescript/node 环境呢&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><code>lua</code> 这个语言真的有意思，它由 C 语言构成，又实现了 C 语言所没有的「对象」。早在不知道哪年搞 <code>cocos2d</code> 的时候，就接触了这个语言</p><p><code>hammerspoon</code> 也不是什么新鲜东西了，早在 18 年，公司内部一次「杂鱼分享会」就有人提到了这个工具 —— 快速将光标切到目标显示器以及窗口调整</p><p>早期是用过一段时间，写了一个代替小黑帽🎩的工具，后来不了了之。主要还是觉得现在不想用这个语言，太阴间了</p><p>当然还有其他方案，比如常见的用到了 <code>moonscript</code>，这是一个类 <code>coffeescript</code> 的语言，属于 lua 生态圈的东西。但用这个就意味着你需要在本机构建一个 lua 环境（luarock），这么一想那不想干了，现在不用 lua 了还留一个完全不用的开发环境</p><p>前些日子关注到有一个项目 <a href="https://github.com/TypeScriptToLua/TypeScriptToLua" target="_blank" rel="noopener">TypeScriptToLua / TypeScriptToLua</a>，一直没尝试，这波机会刚好。而且老前端了，谁还没有个 typescript/node 环境呢</p><a id="more"></a><h2 id="安装">安装</h2><p>虽然是个编译工具，但没必要全局安装，<code>npm init</code> 一个项目出来，直接用即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br><span class="line">yarn add typescript-to-lua --dev</span><br></pre></td></tr></table></figure><p>然后在 <code>package.json</code> 的 <code>script</code> 中加一行<code>build</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;tstl --watch&quot;,</span><br><span class="line">&quot;build&quot;: &quot;tstl&quot;</span><br></pre></td></tr></table></figure><p>也就能用了。建议是看一下<a href="https://typescripttolua.github.io/docs/getting-started" target="_blank" rel="noopener">这个文档</a>，有一些需要「通过类型文件也就是 d.ts 来控制产物」的文档，还是有必要读一下的</p><h2 id="梭">梭</h2><h3 id="类型文件">类型文件</h3><p>有需要的朋友可以看一下我的 <a href="https://github.com/colmugx/dotfiles/blob/master/hammerspoon/src/typings.d.ts" target="_blank" rel="noopener">typings.d.ts</a>，真的靠<code>interface</code>一把梭，不考虑程序设计，只求能 work</p><p>当然这个「不合理」是要解决的，择日解决完之后，发个包，封装一下</p><h3 id="注意点">注意点</h3><h3 id="函数、方法">函数、方法</h3><p>开发的这个过程是没有什么点，不要玩花，正常使用<code>typescript</code>即可。只是通过这次重构，我才领悟到「方法」和「函数」的区别…</p><p>hammerspoon docs 提到函数其实就是 <code>static</code>，表现是<code>.</code>连接的；而实例化之后所使用的方法，是<code>:</code>连接的。所以这里要注意的就是产物的<code>self</code>指向。函数的话需要在 d.ts 中写上<code>@noSelf</code>，不然编译时会被改成<code>:</code></p><h3 id="pcall">pcall</h3><p>一个执行函数的函数，这里有一个坑：被执行的函数需要指定一下<code>this</code>，也就是<code>xxx.bind(Cla)</code>，不然会因为<code>self</code>指向了全局而触发不到对应的方法</p>]]></content:encoded>
      
      <comments>https://colmugx.github.io/blog/2020/06/02/hammerspoon-ts/#disqus_thread</comments>
    </item>
    
    <item>
      <title>docker 容器内通信</title>
      <link>https://colmugx.github.io/blog/2020/03/29/docker-container-bridge/</link>
      <guid>https://colmugx.github.io/blog/2020/03/29/docker-container-bridge/</guid>
      <pubDate>Sun, 29 Mar 2020 10:00:28 GMT</pubDate>
      <description>
      
        &lt;p&gt;除了正常工作（特殊时期太搞人了，虽然我一直在 remote…），最近也在准备一个专栏，同时也在找文本存储或者说自己喜欢的笔记方案。我对数据的掌控性有些洁癖，不是很想用 Bear 这类东西，也摸不着头脑所以退而求其次有一段时间依赖 iCloud&lt;/p&gt;
&lt;p&gt;最后整了一个本地 webdav 😆&lt;/p&gt;
&lt;p&gt;当然商业网盘支持 WebDav 国内公司也有的，就曾四处安利过的坚果云&lt;/p&gt;
&lt;p&gt;docker 好东西啊，一个宿主，一堆容器，互相隔离又互相吸引。自然 nextcloud 和数据库理所当然的处于两个容器。既然同 host 下，那容器应该内网连接就行了，这么一来人懵了&lt;/p&gt;
&lt;p&gt;**两个容器不在一个网段内…**因为有一个容器是处于一个 stack 内的&lt;/p&gt;
&lt;p&gt;所以，水一篇文，单纯记录一下&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>除了正常工作（特殊时期太搞人了，虽然我一直在 remote…），最近也在准备一个专栏，同时也在找文本存储或者说自己喜欢的笔记方案。我对数据的掌控性有些洁癖，不是很想用 Bear 这类东西，也摸不着头脑所以退而求其次有一段时间依赖 iCloud</p><p>最后整了一个本地 webdav 😆</p><p>当然商业网盘支持 WebDav 国内公司也有的，就曾四处安利过的坚果云</p><p>docker 好东西啊，一个宿主，一堆容器，互相隔离又互相吸引。自然 nextcloud 和数据库理所当然的处于两个容器。既然同 host 下，那容器应该内网连接就行了，这么一来人懵了</p><p>**两个容器不在一个网段内…**因为有一个容器是处于一个 stack 内的</p><p>所以，水一篇文，单纯记录一下</p><a id="more"></a><h2 id="解决方案">解决方案</h2><p>用 <code>--link</code> 参数确实可以让容器联系起来，但想着就觉得可能会出现无法维护的情况。而且 docker 是有 <code>network</code> 的，最好还是通过创建不同的「内网」使容器可以在「正确的网路」内相互通信</p><h3 id="创建网络">创建网络</h3><p>这类操作要的只是一个网桥，所以创建一个桥叫做<code>my-bridge</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge my-bridge</span><br></pre></td></tr></table></figure><h3 id="连接容器">连接容器</h3><p>家庭服务我是上了 <code>dashboard(portianer)</code> 的，所以两个容器在 <code>network</code> 区分别下拉拿到网桥点击添加就完事了，谁愿意写命令啊毕竟在家装b没人看（X</p><p>用命令行的话也就是把控制台自动做的繁琐操作手动做了一遍 —— 关掉容器然后添加 <code>--network</code> 运行容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --network my_bridge [...]</span><br></pre></td></tr></table></figure><p>PS：吐槽一下自己的文章分类，是时候应该整理一下了，或者好几年前开个文章编辑器坑要填上了……</p><p>PPS：nextcloud 是 <code>php + apache</code> 产品…意思就是找替代品是板上钉钉……</p>]]></content:encoded>
      
      <comments>https://colmugx.github.io/blog/2020/03/29/docker-container-bridge/#disqus_thread</comments>
    </item>
    
    <item>
      <title>利用 Context 传递多语言文本</title>
      <link>https://colmugx.github.io/blog/2020/01/31/react-translate/</link>
      <guid>https://colmugx.github.io/blog/2020/01/31/react-translate/</guid>
      <pubDate>Fri, 31 Jan 2020 06:38:39 GMT</pubDate>
      <description>
      
        &lt;p&gt;Gatsby 比 Hexo 更像一个通用框架，关于博客的工具真是全靠社区衬托。Nlvi 迁移遇到了标签云和分类等各种问题，还有一个多语言问题…&lt;/p&gt;
&lt;p&gt;找了一圈插件，i18n 大多数方案都是「一个站点同时多语言」，这对一个博客来说没必要啊（相对来说我博文是不是也得写个几份…），想了一圈好像也没必要上&lt;code&gt;react-intl&lt;/code&gt;，直接手作一个吧 —— 按照**「好看的皮囊千篇一律」**写一个&lt;/p&gt;
&lt;p&gt;但是主题毕竟是要开源的，所以如果有好兄弟萌觉得 i18n 处理不行，自行替换成 &lt;code&gt;gatsby-plugin-i18n&lt;/code&gt; 或者 &lt;code&gt;react-intl&lt;/code&gt; 就可以了&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Gatsby 比 Hexo 更像一个通用框架，关于博客的工具真是全靠社区衬托。Nlvi 迁移遇到了标签云和分类等各种问题，还有一个多语言问题…</p><p>找了一圈插件，i18n 大多数方案都是「一个站点同时多语言」，这对一个博客来说没必要啊（相对来说我博文是不是也得写个几份…），想了一圈好像也没必要上<code>react-intl</code>，直接手作一个吧 —— 按照**「好看的皮囊千篇一律」**写一个</p><p>但是主题毕竟是要开源的，所以如果有好兄弟萌觉得 i18n 处理不行，自行替换成 <code>gatsby-plugin-i18n</code> 或者 <code>react-intl</code> 就可以了</p><a id="more"></a><h2 id="Context">Context</h2><p>直接从 react 分出 <code>createContext</code> 方法，直接用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> langContext = createContext(&#123;&#125; <span class="keyword">as</span> ContextInterface)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建上下文后输出 Provider 和 Consumer 还是要的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Provider = langContext.Provider</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Consumer = langContext.Consumer</span><br><span class="line"></span><br><span class="line"><span class="comment">// ps: 其实 Consumer 用不上...</span></span><br></pre></td></tr></table></figure><h2 id="生成翻译">生成翻译</h2><p>hexo 版 nlvi 已经有语言文件，所以直接拿过来放到<code>lang</code>文件夹下，然后每个文件通过 yaml2json 转成<code>json</code>，简单一点就不上 yaml 了</p><p>大概思路就是：</p><ul><li>设定是通过主题的 <code>options</code> 传入 <code>lang</code> 属性，然后 <code>lang</code> 写到 <code>siteMetadata</code> 中</li><li>由 <code>layout</code> 读取语言，传入翻译生成文本，传入 <code>Provider</code></li><li>使用的地方使用 <code>formatMessage</code> 去接</li></ul><p>所以也就是接地气且极其简化啥都不考虑保证数据存在版的<code>react-intl</code>。方法可以这么写</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> genTranslate = <span class="function">(<span class="params">lang: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> _message = <span class="built_in">require</span>(<span class="string">`@/lang/<span class="subst">$&#123;lang&#125;</span>.json`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!_message) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;lang&#125;</span> language json was not found.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> formatMessage = (&#123; id, defaultMsg &#125;: FormatMessageType): <span class="function"><span class="params">string</span> =&gt;</span></span><br><span class="line">    <span class="comment">// _get 来自 lodash</span></span><br><span class="line">    _get(_message, id) || defaultMsg || <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> formatter = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; formatMessage, _message &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> formatter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用翻译">使用翻译</h2><p>直接用 <code>useContext</code> 去接，2020年该跟风用 hooks 了（大雾</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useIntl = (): <span class="function"><span class="params">ContextInterface</span> =&gt;</span> useContext(langContext)</span><br></pre></td></tr></table></figure><p>所以这么写的话，只要在 <code>layout</code> 下的组件都可以用这个方式拿到翻译</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; formatMessage: t &#125; = useIntl()</span><br></pre></td></tr></table></figure><p>这样一来其实跟使用 <code>react-intl</code> 是差不多的，就算日后要改也应该不用动业务代码</p><p>所以刚刚那句话还差一半来着？另一半应该是**「糜烂的灵魂（?）凑合对付」**！</p>]]></content:encoded>
      
      <comments>https://colmugx.github.io/blog/2020/01/31/react-translate/#disqus_thread</comments>
    </item>
    
    <item>
      <title>创建一个 rust web server</title>
      <link>https://colmugx.github.io/blog/2019/12/29/try-actix/</link>
      <guid>https://colmugx.github.io/blog/2019/12/29/try-actix/</guid>
      <pubDate>Sun, 29 Dec 2019 04:29:34 GMT</pubDate>
      <description>
      
        &lt;p&gt;玩了一段时间 Vapor，想不明白谁家会用 swift 跑生产，可能也就 &lt;code&gt;perfect&lt;/code&gt; 维护者背后的公司会用，至少在拆哪应该还是要快(la)准(man)狠(kpi)的。&lt;br&gt;
rust 社区中关注了 &lt;code&gt;rocket&lt;/code&gt; 一段时间，后面发现 &lt;code&gt;actix-web&lt;/code&gt; 在各方面更有优势，加上要好好点 rust 技能树，所以就选定这个了。&lt;/p&gt;
&lt;p&gt;这里会以重构我的闹钟后端作为蓝本，逐步做个记录。&lt;/p&gt;
&lt;h2 id=&quot;TL-DR&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;直接用 &lt;code&gt;cargo&lt;/code&gt; 创建应用&lt;/li&gt;
&lt;li&gt;装载 &lt;code&gt;actix-web&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;写一个 api&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>玩了一段时间 Vapor，想不明白谁家会用 swift 跑生产，可能也就 <code>perfect</code> 维护者背后的公司会用，至少在拆哪应该还是要快(la)准(man)狠(kpi)的。<br>rust 社区中关注了 <code>rocket</code> 一段时间，后面发现 <code>actix-web</code> 在各方面更有优势，加上要好好点 rust 技能树，所以就选定这个了。</p><p>这里会以重构我的闹钟后端作为蓝本，逐步做个记录。</p><h2 id="TL-DR">TL;DR</h2><ul><li>直接用 <code>cargo</code> 创建应用</li><li>装载 <code>actix-web</code></li><li>写一个 api</li></ul><a id="more"></a><h2 id="创建应用">创建应用</h2><p>官方没有开箱即用的模板，所以还是从<code>cargo new</code>开始，这里定义了默认使用<code>git</code>作为版本控制</p><blockquote><p>&gt; cargo new --vcs git actix-demo</p></blockquote><p>在<code>Cargo.toml</code>中添加这些</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">actix-web</span> = <span class="string">"2.0"</span></span><br><span class="line"><span class="attr">actix-rt</span> = <span class="string">"1.0"</span></span><br><span class="line"><span class="comment"># env</span></span><br><span class="line"><span class="attr">dotenv</span> = <span class="string">"0.15.0"</span></span><br><span class="line"><span class="attr">log</span> = <span class="string">"0.4.8"</span></span><br><span class="line"><span class="attr">env_logger</span> = <span class="string">"0.7.1"</span></span><br></pre></td></tr></table></figure><p>然后在<code>main.rs</code>创建启动函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> actix_web::&#123;App, HttpServer, get&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[get(<span class="meta-string">"/"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">index</span></span>() -&gt; HttpResponse &#123;</span><br><span class="line">    HttpResponse::<span class="literal">Ok</span>().body(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[actix_rt::main]</span></span><br><span class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> app = || App::new().service(index);</span><br><span class="line"></span><br><span class="line">    info!(<span class="string">"serving on localhost:7001"</span>);</span><br><span class="line"></span><br><span class="line">    HttpServer::new(app)</span><br><span class="line">        .bind(<span class="string">"localhost:7001"</span>)?</span><br><span class="line">        .run()</span><br><span class="line">        .await</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说这样就可以运行了</p><h2 id="配置应用">配置应用</h2><p>按照习惯，工程结构还是愿意设置成这样：</p><ul><li>controller</li><li>services</li><li>models</li><li>middleware</li></ul><p>所以目录先确定下来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-- src</span><br><span class="line">| +-- controller</span><br><span class="line">| | +-- mod.rs</span><br><span class="line">| +-- services</span><br><span class="line">| | +-- mod.rs</span><br><span class="line">| +-- models</span><br><span class="line">| | +-- mod.rs</span><br><span class="line">| +-- middleware</span><br><span class="line">| | +-- mod.rs</span><br></pre></td></tr></table></figure><p>为什么每个目录下都需要<code>mod.rs</code>？原因是人家<code>rust</code>对模块就是这么处理的啊！</p><p>接着，<code>Cargo.toml</code>需要加点东西，比如<code>json</code>的支持（可是你用的不是 GraphQL 吗！）</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="comment"># serde</span></span><br><span class="line"><span class="attr">serde</span> = <span class="string">"1.0.104"</span></span><br><span class="line"><span class="attr">serde_derive</span> = <span class="string">"1.0.104"</span></span><br><span class="line"><span class="attr">serde_json</span> = <span class="string">"1.0.44"</span></span><br><span class="line"><span class="attr">json</span> = <span class="string">"0.12.0"</span></span><br></pre></td></tr></table></figure><p>接下来对代码作出一些改动，首先是一个通用的<code>json</code>结构体，创建 <code>models/payload</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> serde_derive::&#123;Serialize, Deserialize&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Serialize, Deserialize, Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Payload</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> code: <span class="built_in">isize</span>,</span><br><span class="line">    <span class="keyword">pub</span> message: <span class="built_in">String</span>,</span><br><span class="line">    <span class="meta">#[serde(skip_serializing_if = <span class="meta-string">"Option::is_none"</span>, default)]</span></span><br><span class="line">    <span class="keyword">pub</span> payload: <span class="built_in">Option</span>&lt;T&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，从<code>controller/index</code>开始</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Deserialize)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Info</span></span> &#123;</span><br><span class="line">    message: <span class="built_in">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[get(<span class="meta-string">"/"</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> async <span class="function"><span class="keyword">fn</span> <span class="title">index</span></span>(query: web::Query&lt;Info&gt;) -&gt; <span class="built_in">Result</span>&lt;HttpResponse, Error&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Query拿到与 Info 结构一样的参数</span></span><br><span class="line">    <span class="comment">// 如果你这么写，那么如果调用时如果不传 query 会报错，param 同理</span></span><br><span class="line">    <span class="comment">// rust 真严格..</span></span><br><span class="line">    <span class="keyword">let</span> result = crate::services::index::get_helloworld(query.message.clone());</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(HttpResponse::<span class="literal">Ok</span>().json(result))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，<code>services/index</code>，暂时不用<code>middleware</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::models::payload::Payload;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单写一个服务</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_helloworld</span></span>(msg: <span class="built_in">String</span>) -&gt; Payload&lt;()&gt; &#123;</span><br><span class="line">    Payload &#123;</span><br><span class="line">        code: <span class="number">0</span>,</span><br><span class="line">        message: msg.to_string(),</span><br><span class="line">        payload: <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后改一下<code>main.rs</code></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+mod controllers;</span></span><br><span class="line"><span class="addition">+mod models;</span></span><br><span class="line"><span class="addition">+mod services;</span></span><br><span class="line"></span><br><span class="line">#[actix_rt::main]</span><br><span class="line">async fn main() -&gt; io::Result&lt;()&gt; &#123;</span><br><span class="line"></span><br><span class="line">    let app = || App::new()</span><br><span class="line"><span class="deletion">-        .service(index);</span></span><br><span class="line"><span class="addition">+        .service(controllers::index::index);</span></span><br><span class="line"></span><br><span class="line">    info!("serving on localhost:7001");</span><br><span class="line"></span><br><span class="line">    HttpServer::new(app)</span><br><span class="line">        .bind("localhost:7001")?</span><br><span class="line">        .run()</span><br><span class="line">        .await</span><br></pre></td></tr></table></figure><p>测试一下，调用 <code>localhost:7001?message=helloworld</code>，就可以看到回复了！</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"helloworld"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里我其实还用这些：</p><ul><li><code>router</code></li><li>写了一个配置的结构体用来封装 HOST, PORT 和数据库地址</li><li>环境变量配置</li></ul><p>文章就不写了，大概就那样。</p><h2 id="后记">后记</h2><ul><li>建议用 CLion，VSCode 和 VIM 实在是太… IDE 也好，数据库分步调试什么的很方便</li><li>没 key 怎么办，找一个长期维护的开源项目，嫖就完事儿了</li><li>前端本来也想用<code>rust(yew)</code>的，可是在<code>raspbian</code>运行，不清楚结果。也不清楚其他选型，所以只能继续<code>electron + react</code>了，可能会去掉<code>umi</code></li></ul><p>下一期整数据库连接</p>]]></content:encoded>
      
      <comments>https://colmugx.github.io/blog/2019/12/29/try-actix/#disqus_thread</comments>
    </item>
    
    <item>
      <title>如果我把 Rust 用在网页呢</title>
      <link>https://colmugx.github.io/blog/2019/10/13/try-wasm/</link>
      <guid>https://colmugx.github.io/blog/2019/10/13/try-wasm/</guid>
      <pubDate>Sun, 13 Oct 2019 15:47:21 GMT</pubDate>
      <description>
      
        &lt;p&gt;已知&lt;code&gt;Rust&lt;/code&gt;是个很硬核的编程语言&lt;/p&gt;
&lt;p&gt;又已知&lt;code&gt;JavaScript&lt;/code&gt;或者说在浏览器上的&lt;code&gt;JavaScript&lt;/code&gt;在某种情况无法胜任工作。&lt;/p&gt;
&lt;p&gt;So？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🦀 Rust + 🕸 Wasm = ❤&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是，单纯把教程或者 tutorial 拿出来复述是没意思的。So，搞点事情&lt;/p&gt;
&lt;p&gt;那么前提是，你已经弄清楚了 &lt;code&gt;wasm-pack&lt;/code&gt; 是怎么回事了&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>已知<code>Rust</code>是个很硬核的编程语言</p><p>又已知<code>JavaScript</code>或者说在浏览器上的<code>JavaScript</code>在某种情况无法胜任工作。</p><p>So？</p><blockquote><p>🦀 Rust + 🕸 Wasm = ❤</p></blockquote><p>但是，单纯把教程或者 tutorial 拿出来复述是没意思的。So，搞点事情</p><p>那么前提是，你已经弄清楚了 <code>wasm-pack</code> 是怎么回事了</p><a id="more"></a><h2 id="题干？">题干？</h2><p>最近着手一个项目，使用浏览器的<code>crypto</code>实现了加解密，加解密都需要在浏览器处理。但毕竟解释型，最多只是混淆。即使我在编写时已经使用了花里胡哨的东西，就差整上钓鱼的那套手段了。不过，毕竟二进制的东西，总比混淆型更不容易肉眼解析，人脑编译</p><p>这里倒是可以交代，我用到了<code>aes-256-cfb</code>，所以我们大概需要这些东西</p><h2 id="板条箱？">板条箱？</h2><p>毕竟是 Rust，注定是“简陋”的，所以我决定直接去找现有的密码学类库。目前已经亲测的密码学库有：</p><ul><li><a href="https://github.com/DaGenix/rust-crypto" target="_blank" rel="noopener">DaGenix/rust-crypto</a></li><li><a href="https://github.com/RustCrypto" target="_blank" rel="noopener">RustCrypto 系列</a></li></ul><p>如果运行在 <code>wasm</code>，第一个库需要使用另外一个有针对适应的</p><ul><li><a href="https://github.com/buttercup/rust-crypto-wasm" target="_blank" rel="noopener">buttercup/rust-crypto-wasm</a></li></ul><p>在写文章前我已经都“绕”过一遍了…在这之间反复横跳。刚开始以为这些库无法适用<code>wasm</code>（报错无法定位），后来觉得用起来好难（写得很绕），再后来发现是我写错了…</p><p>接着，可能需要一个随机数库，只能是<code>rand</code>了，而且也是<code>crates.io</code>下载量最多的（为什么…）</p><h2 id="创建？">创建？</h2><blockquote><p>&gt; cargo generate --git <a href="https://github.com/rustwasm/wasm-pack-template" target="_blank" rel="noopener">https://github.com/rustwasm/wasm-pack-template</a></p></blockquote><p>接着，安排上依赖</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">wasm-bindgen</span> = <span class="string">"0.2"</span> <span class="comment"># 核心</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">"0.7.2"</span> <span class="comment"># 但接下来用不上</span></span><br><span class="line"><span class="attr">aes</span> = <span class="string">"0.3.2"</span> <span class="comment"># 添加这个只是为了分组依赖与类型</span></span><br><span class="line"><span class="attr">cfb-mode</span> = <span class="string">"0.3.2"</span> <span class="comment"># 这个才是加密核心</span></span><br></pre></td></tr></table></figure><p>然后运行一遍<code>cargo build</code>或者<code>wasm-pack build</code>，因为<code>rust</code>在编译时会检查依赖情况，所以索性我就直接通过这种方式安装依赖了，就像写<code>swift</code>随手<code>cmd + b</code></p><h2 id="食用？">食用？</h2><h3 id="编译源码">编译源码</h3><ol><li>加载 crate（上板条！）</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> aes;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> cfb_mode;</span><br></pre></td></tr></table></figure><ol start="2"><li>声明依赖，或者说<code>import</code></li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> aes::Aes256; <span class="comment">// 使用 256</span></span><br><span class="line"><span class="keyword">use</span> cfb_mode::stream_cipher::&#123;NewStreamCipher, StreamCipher&#125;; <span class="comment">// cfb是基于流加密其中一种</span></span><br><span class="line"><span class="keyword">use</span> cfb_mode::Cfb; <span class="comment">// 需要用这个结构体</span></span><br></pre></td></tr></table></figure><ol start="3"><li>声明一个类型别名，方便使用<br>Rust 可以声明类型别名。为了后面方便实用，定义一个</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Cfb 结构体作为加密类型，Cfb 本身又需要一个类型…使用 Aes256 结构体声明长度</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">AesCfb</span></span> = Cfb&lt;Aes256&gt;;</span><br></pre></td></tr></table></figure><ol start="4"><li>随便写个加密</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[wasm_bindgen]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">test</span></span>() -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> key: &amp;[<span class="built_in">u8</span>; <span class="number">32</span>] = b"nashizhendeniup,,nashizhendeniup<span class="string">";</span></span><br><span class="line"><span class="string">  let iv: &amp;[u8; 16]  = b"</span>unique,un,unique<span class="string">";</span></span><br><span class="line"><span class="string">  let msg = "</span>那你是真的牛皮<span class="string">";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  let mut buffer = msg.as_bytes().to_vec();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  AesCfb::new_var(key, iv).unwrap().encrypt(&amp;mut buffer);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  buffer</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="到前端使用">到前端使用</h3><p>经过编译<code>wasm-pack build</code>，可以得到一个<code>pkg</code>目录。目录下的文件就很熟悉了！</p><ul><li>package.json</li><li>&lt;xxx&gt;.wasm</li><li>&lt;xxx&gt;.d.ts</li><li>……</li></ul><p>你甚至可以直接把这个包上到<code>npm</code>，让更多人可以使用。这里我们就只是<code>yarn link</code>，然后创建一个前端项目</p><blockquote><p>&gt; npm init wasm-app www</p></blockquote><p>接着，有着 50 年前端经验的老前端应该都会接下来的步骤了：<code>yarn</code> -&gt; <code>yarn link &lt;xxx&gt;</code></p><p>然后，把<code>JavaScript</code>的代码改改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;test&#125; <span class="keyword">from</span> <span class="string">'crypto-test'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test())</span><br></pre></td></tr></table></figure><p>因为 <code>Rust</code> 是强类型的语言，所以在类型推断不会有太多麻烦。同时，在通过工具编译到<code>wasm</code>时会多编译一个<code>d.ts</code>文件。这样，就算暴露给<code>JavaScript</code>的代码再复杂，只要使用 VSCode 或者支持 TS 的 Language Server 也没有太大压力</p><p>所以这样我就得到一个加密数据集合，<code>Vec&lt;u8&gt;</code>到<code>JavaScript</code>那边会直接变成<code>UTF8</code>类型数组，所以我们会打印出这东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uint8Array(21) [230, 156, 59, 211, 78, 162, 142, 118, 193, 154, 45, 255, 203, 56, 123, 8, 143, 173, 46, 120, 25]</span><br></pre></td></tr></table></figure><p>用<code>node</code>的话，一般会把加密数据转成字符串保存（比如我提到的我在做的项目），这里就先裸着吧</p><p>那<code>wasm</code>画风是怎样的呢？给个节选参考一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  get_local $p0</span><br><span class="line">  i32.load</span><br><span class="line">  get_local $p1</span><br><span class="line">  call $core::fmt::Write::write_char::h90a3bac002e2aa8d)</span><br><span class="line">(func $&lt;&amp;T_as_core::fmt::Debug&gt;::fmt::h110ce52a73dd639b (type $t6) (param $p0 i32) (param $p1 i32) (result i32)</span><br><span class="line">  get_local $p0</span><br><span class="line">  i32.load</span><br><span class="line">  get_local $p1</span><br><span class="line">  call $core::fmt::num::&lt;impl_core::fmt::Debug_for_usize&gt;::fmt::hf84d386a4f5a1afb)</span><br><span class="line">(func $__rdl_dealloc (type $t7) (param $p0 i32) (param $p1 i32) (param $p2 i32)</span><br><span class="line">  i32.const 1056732</span><br><span class="line">  get_local $p0</span><br></pre></td></tr></table></figure><p>看得我都有女装的冲动了（大雾</p><h2 id="结束？">结束？</h2><p>文章的目标只有两个：</p><ul><li>体验<code>rust + wasm</code></li><li>干一手加密，看看是否能取代浏览器的<code>crypto</code>，不考虑性能</li></ul><p>因为<code>Rust</code>的发展快接近完整了，这个时候入坑应该挺合适。所以接下来我就指望靠这个语言接近计科的世界了</p><p>最后，有一点需要注意，所选择的<code>AES</code>长度不同，会影响你需要的秘钥长度。所以，这个时候可以唠唠加密？</p><h2 id="（附加资料）加密？">（附加资料）加密？</h2><h3 id="分组密码">分组密码</h3><p>分组密码将明文分成多个等长的模块（block），使用确定的算法和对称密钥对每组分别加密解密。所以，这种加密方式带来的问题就是：对越长的字符串进行加密，代价越大</p><h3 id="AES">AES</h3><p>对称加密的一种（对称加密就不解释了），也是目前最流行的对称加密算法之一。该算法属于分组加密算法。</p><p>AES的区块长度固定为128比特，密钥长度则可以是128，192或256比特。</p><p>加密方式也有很多模式：ecb, cfb, gcm, cbc。其中 ecb 没有 iv</p><p>我们在使用密码库的时候，都会接触到 <code>key</code>, <code>iv</code> 还有可能需要<code>padding</code></p><h4 id="iv">iv?</h4><p>初始化向量（IV，Initialization Vector）是许多任务作模式中用于将加密随机化的一个位块，由此即使同样的明文被多次加密也会产生不同的密文，避免了较慢的重新产生密钥的过程。</p><p>在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个IV。对于CBC和CFB，重用IV会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。对于OFB和CTR而言，重用IV会导致完全失去安全性。</p><p>一般来说，向量用于分组加密中其中第一个块的加密，其他块均为自动生成（就是提供向量）</p><h4 id="key">key?</h4><p>加密密钥，对于 aes 来说就是每个块使用到的加密密钥</p><h4 id="padding">padding?</h4><p>padding 是用来填充最后一块使得变成一整块，所以对于加密解密两端需要使用同一的 PADDING 模式，大部分 PADDING 模式为PKCS5, PKCS7, NOPADDING。</p><h3 id="AES256-128">AES256? 128?</h3><p>其中，<code>iv</code>肯定是 16 位。因为加密块的长度就是这么限制的</p><p>区别在于密钥长度，<code>Aes128</code> 的密钥长度需要 16 位，而 <code>Aes256</code> 需要的密钥长度是 32 位</p><p>为什么呢？算一下不就知道了</p><h3 id="AES256CFB">AES256CFB?</h3><p>就是使用 aes，长度 256，那么 cfb 呢？</p><p>密文反馈（CFB，Cipher feedback），可以理解是反向 CBC，因为 CFB 的解密过程几乎就是颠倒的CBC的加密过程</p><p>那，也不用想太多，就是使用 AES 加密，长度使用 256，模式使用 cfb</p>]]></content:encoded>
      
      <comments>https://colmugx.github.io/blog/2019/10/13/try-wasm/#disqus_thread</comments>
    </item>
    
    <item>
      <title>来自 swift 的跨界执法（一） —— Vapor</title>
      <link>https://colmugx.github.io/blog/2019/06/23/try-vapor-0/</link>
      <guid>https://colmugx.github.io/blog/2019/06/23/try-vapor-0/</guid>
      <pubDate>Sun, 23 Jun 2019 08:17:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;Vapor 应该是目前比较成熟的服务器应用框架了，更新快，社区“繁荣”&lt;/p&gt;
&lt;p&gt;所以，直接干吧&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Vapor 应该是目前比较成熟的服务器应用框架了，更新快，社区“繁荣”</p><p>所以，直接干吧</p><a id="more"></a><h2 id="安装">安装</h2><p>直接装个工具集吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap vapor/tap</span><br><span class="line">brew install vapor/tap/vapor</span><br></pre></td></tr></table></figure><h2 id="生成应用">生成应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vapor new Hello</span><br></pre></td></tr></table></figure><p>等待一会，出现水滴图案时就初始化完成了</p><p>接着进目录，生成<code>xcode</code>可以使用的工程文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./Hello</span><br><span class="line">vapor xcode</span><br></pre></td></tr></table></figure><p>依然是等待一会之后，<code>cmd</code>会询问你是否打开<code>XCode</code>，打开便是</p><h2 id="编写体验">编写体验</h2><p>vapor 默认会给几种方案，如果直接 new 的话默认是<code>api</code>方案，也就是“接口服务器”。</p><p>所以一打开，就能看到工程已经被“安排好了”：一般所需要的目录结构，以及默认使用<code>SQLite3</code>数据库（运行在内存）</p><p>本来我打算通过<code>Todos</code>练练手，现在看起来好像参考答案已经给出来了…默认情况下也不需要怎么去补充，按照自己的编程习惯直接用就行了。</p><p>但这里用内存数据库属实8合适，所以改一下数据库存储方式</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DirectoryConfig.detect().workDir 项目绝对路径</span></span><br><span class="line"><span class="keyword">let</span> storePath = <span class="type">DirectoryConfig</span>.detect().workDir + <span class="string">"Db/store.db"</span></span><br><span class="line"><span class="keyword">let</span> sqlite = <span class="keyword">try</span> <span class="type">SQLiteDatabase</span>(storage: .file(path: storePath))</span><br></pre></td></tr></table></figure><p>这样一来就把数据库位置移动到工程中<code>Db</code>目录下了，第一次运行就会直接创建数据库</p><p>对了，Vapor 自己带一个 ORM <code>Fluent</code>，所以关系型数据库操作不会太操蛋</p><p>所以下一篇应该是讨论一个更合适的<code>restful</code>写法？或者是用上<code>gRPC</code>？</p><h2 id="相关信息">相关信息</h2><p>Vapor 自己提供一个<a href="http://vapor.university/" target="_blank" rel="noopener">「大学」</a>，这里都是组织自己录的教学视频，基本点都涵盖到了</p>]]></content:encoded>
      
      <comments>https://colmugx.github.io/blog/2019/06/23/try-vapor-0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>来自 swift 的跨界执法（零） —— Perfect</title>
      <link>https://colmugx.github.io/blog/2019/06/07/try-swift-perfect/</link>
      <guid>https://colmugx.github.io/blog/2019/06/07/try-swift-perfect/</guid>
      <pubDate>Fri, 07 Jun 2019 08:39:39 GMT</pubDate>
      <description>
      
        &lt;p&gt;因为不可抗力没上班，看着新&lt;code&gt;swift&lt;/code&gt;和&lt;code&gt;swiftUI&lt;/code&gt;发布，决定搞&lt;code&gt;Perfect&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个框架可是听说很久了，匆忙看了两眼就没有下文。当时来说是最强 Server-site 框架（为什么要说当时？）&lt;/p&gt;
&lt;p&gt;篇幅不长，仅做一个尝试和介绍，原因在最后。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;安装还是相当容易，官方编译器起一个可执行类型项目&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;swift package &lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt; --type=executable&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>因为不可抗力没上班，看着新<code>swift</code>和<code>swiftUI</code>发布，决定搞<code>Perfect</code>。</p><p>这个框架可是听说很久了，匆忙看了两眼就没有下文。当时来说是最强 Server-site 框架（为什么要说当时？）</p><p>篇幅不长，仅做一个尝试和介绍，原因在最后。</p><h2 id="安装">安装</h2><p>安装还是相当容易，官方编译器起一个可执行类型项目</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift package <span class="keyword">init</span> --type=executable</span><br></pre></td></tr></table></figure><a id="more"></a><p>其次，在<code>Package.swift</code>中添加依赖</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies: [</span><br><span class="line">    .package(url: <span class="string">"https://github.com/PerfectlySoft/Perfect-HTTPServer.git"</span>, from: <span class="string">"3.0.0"</span>)</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>接着，编译即安装依赖（熟悉啊！）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift build</span><br></pre></td></tr></table></figure><p>最后，生成<code>xcodeproj</code>文件以<code>xcode</code>打开，接下来工作交还给<code>xcode</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift package generate-xcodeproj</span><br></pre></td></tr></table></figure><p>不得不说，你果<code>XCode</code>到从系统<code>10.10</code>开始那会到如今 9102 年了，体验还是这么糟糕。然而苹果家的两个语言，不用<code>XCode</code>体验更糟…</p><h2 id="编写体验">编写体验</h2><p>初始化项目什么目录都没有，作为一个毫无后端经验的 API 拼装师，只能假把式创建<code>controllers</code>与<code>models</code>目录，加上习惯加一个<code>constant</code>目录。</p><p><s>后来发现，我好像用不上</s></p><p>按照习惯创建了一个结构体用来存放配置内容</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GlobalConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> baseRoute = <span class="string">"/api/v1"</span></span><br><span class="line">    <span class="keyword">let</span> httpPort = <span class="number">8081</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，清空<code>main.swift</code>，根据<code>swift</code>的逻辑：只有库需要引用，业务文件同一项目下不需要<code>import</code>。所以引入<code>perfect</code>，并初始化</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PerfectHTTP</span><br><span class="line"><span class="keyword">import</span> PerfectHTTPServer</span><br><span class="line"><span class="comment">// 字典不是JSON，使用库中方法得以把字典转为JSON</span></span><br><span class="line"><span class="keyword">import</span> PerfectLib</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> config = <span class="type">GlobalConfig</span>()</span><br><span class="line"><span class="keyword">let</span> server = <span class="type">HTTPServer</span>()</span><br><span class="line"><span class="keyword">var</span> routes = <span class="type">Routes</span>(baseUri: config.baseRoute)</span><br></pre></td></tr></table></figure><p>然后制定一个<code>restful</code>类型路由（原本写在<code>Router.swift</code>）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: [[<span class="type">String</span>: <span class="type">Any</span>]] = [</span><br><span class="line">    [<span class="string">"name"</span>: <span class="string">"index"</span>, <span class="string">"url"</span>: <span class="string">"/home"</span>, <span class="string">"method"</span>: <span class="type">HTTPMethod</span>.<span class="keyword">get</span>],</span><br><span class="line">    [<span class="string">"name"</span>: <span class="string">"show"</span>, <span class="string">"url"</span>: <span class="string">"/home/&#123;id&#125;"</span>, <span class="string">"method"</span>: <span class="type">HTTPMethod</span>.<span class="keyword">get</span>],</span><br><span class="line">    [<span class="string">"name"</span>: <span class="string">"create"</span>, <span class="string">"url"</span>: <span class="string">"/home"</span>, <span class="string">"method"</span>: <span class="type">HTTPMethod</span>.post],</span><br><span class="line">    [<span class="string">"name"</span>: <span class="string">"update"</span>, <span class="string">"url"</span>: <span class="string">"/home/&#123;id&#125;"</span>, <span class="string">"method"</span>: <span class="type">HTTPMethod</span>.put],</span><br><span class="line">    [<span class="string">"name"</span>: <span class="string">"delete"</span>, <span class="string">"url"</span>: <span class="string">"/home/&#123;id&#125;"</span>, <span class="string">"method"</span>: <span class="type">HTTPMethod</span>.delete]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>接着，通过<code>swift</code>的<code>map</code>（不是很合适）随便载入一套路由（有时候真的恨<code>swift</code>的类型安全）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RoutesConfig</span>().list.<span class="built_in">map</span> &#123;</span><br><span class="line">    routes.add(method: $<span class="number">0</span>[<span class="string">"method"</span>] <span class="keyword">as</span>! <span class="type">HTTPMethod</span>, uri: $<span class="number">0</span>[<span class="string">"url"</span>] <span class="keyword">as</span>! <span class="type">String</span>, handler: &#123; (request, response) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> json: [<span class="type">String</span>: <span class="type">Any</span>] = [<span class="string">"code"</span>: <span class="number">0</span>, <span class="string">"message"</span>: <span class="string">"success"</span>]</span><br><span class="line">        <span class="keyword">let</span> variables = request.urlVariables</span><br><span class="line">        <span class="keyword">var</span> newJson = json</span><br><span class="line">        <span class="keyword">if</span> (!variables.isEmpty) &#123;</span><br><span class="line">            <span class="keyword">for</span> e <span class="keyword">in</span> variables &#123;</span><br><span class="line">                newJson[e.key] = variables[e.key]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> output = <span class="keyword">try</span>! newJson   <span class="comment">// 因都是字面量，所以必有值（真nm安全，业务尽量不要这么搞）</span></span><br><span class="line">            .jsonEncodedString()</span><br><span class="line">        response</span><br><span class="line">            .setHeader(.contentType, value: <span class="string">"application/json"</span>)</span><br><span class="line">            .appendBody(string: output)</span><br><span class="line">            .completed()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由载入服务并指定端口（直接执行会默认<code>0.0.0.0:8081</code>）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.addRoutes(routes)</span><br><span class="line">server.serverPort = <span class="type">UInt16</span>(config.httpPort)</span><br></pre></td></tr></table></figure><p>最后（简单）执行</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> server.start()</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"\(error)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原因">原因</h2><ul><li>文档虽是详细，但是周边很少，社区冷淡（都不知道有没有）。而且资料很少，很难查到关于这个框架的讨论或者内容。</li><li>Star 虽然证明不了什么，但是从昔日第一，到现在第二，距离第一也有很大差距。又语言关系，并不会有像某些库那样的宗教化。故必有某些原因。</li></ul><p>所以，你好<code>Vapor</code>！这可能是目前<code>swift server side</code>最优解决方案。并且这也是标题从“零”开始的原因。</p><p>并且在文章提交之前，发现<code>Vapor</code>已经支持<code>Swift 5.1</code>，本体也更新频繁，大概知道为什么<code>Perfect</code>为什么会没落了。</p><p>不过，我觉得可以先尝试<code>Vapor</code>，再看看哪个使用手感更适合我。</p>]]></content:encoded>
      
      <comments>https://colmugx.github.io/blog/2019/06/07/try-swift-perfect/#disqus_thread</comments>
    </item>
    
    <item>
      <title>react函数级写法和继承写法有什么区别？</title>
      <link>https://colmugx.github.io/blog/2019/05/28/react-component-method/</link>
      <guid>https://colmugx.github.io/blog/2019/05/28/react-component-method/</guid>
      <pubDate>Tue, 28 May 2019 15:48:21 GMT</pubDate>
      <description>
      
        &lt;p&gt;这问题真的是土到我了，立刻就发了一个知乎想法。但后来我发现，他会不会想问的是几百年前，在盘古开天辟地之后的&lt;code&gt;react 0.x&lt;/code&gt;时代，于是我默默把想法干掉了。&lt;/p&gt;
&lt;p&gt;如果是&lt;code&gt;createClass&lt;/code&gt;和&lt;code&gt;extends React.Component&lt;/code&gt;，还有点意思。如果是&lt;code&gt;functional component&lt;/code&gt;，那您怎么不用同样很「渐进式」同时又更牛逼的&lt;code&gt;vue&lt;/code&gt;呢？&lt;/p&gt;
&lt;p&gt;简单对比：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;createClass&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Component/PureComponent&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;ES5&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;ES6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;propTypes/getDefaultProp&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Component.defaultProps/Component.propType&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;this 已被指定&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;属性 this 不默认指向组件（实例）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;mixin&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;mixin（被取消，不建议，做不到，HOC）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中对我来说，这两个的区别可能&lt;code&gt;mixin&lt;/code&gt;最有意思&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>这问题真的是土到我了，立刻就发了一个知乎想法。但后来我发现，他会不会想问的是几百年前，在盘古开天辟地之后的<code>react 0.x</code>时代，于是我默默把想法干掉了。</p><p>如果是<code>createClass</code>和<code>extends React.Component</code>，还有点意思。如果是<code>functional component</code>，那您怎么不用同样很「渐进式」同时又更牛逼的<code>vue</code>呢？</p><p>简单对比：</p><table><thead><tr><th style="text-align:center">createClass</th><th style="text-align:center">Component/PureComponent</th></tr></thead><tbody><tr><td style="text-align:center">ES5</td><td style="text-align:center">ES6</td></tr><tr><td style="text-align:center">propTypes/getDefaultProp</td><td style="text-align:center">Component.defaultProps/Component.propType</td></tr><tr><td style="text-align:center">this 已被指定</td><td style="text-align:center">属性 this 不默认指向组件（实例）</td></tr><tr><td style="text-align:center">mixin</td><td style="text-align:center">mixin（被取消，不建议，做不到，HOC）</td></tr></tbody></table><p>其中对我来说，这两个的区别可能<code>mixin</code>最有意思</p><a id="more"></a><h2 id="编写风格">编写风格</h2><p><code>createClass</code> 用的是给函数传递一个对象的方式创建组件，风格很像<code>vue</code>，<code>Component</code>用的是对象继承的方式创建组件。好像没什么好说的。</p><h2 id="default-props">default props</h2><p><code>createClass</code>依然跟现在的<code>vue</code>写法很像，不过从<code>vue</code>中<code>props[xxx].default</code>变成<code>getDefaultProp</code>方法，同时对象内通过<code>propTypes</code>做接口类型检查。</p><p><code>classes</code>型的默认接口和接口检查都是来源于对象两个静态对象。</p><h2 id="this">this</h2><p><code>createClass</code>同样与<code>vue</code>差不多，<code>this</code>会指向到组件上，应该还是处于同一对象中的原因。<code>classes</code>类型的可没那么顺利，<code>this</code>会指向到类上，所以写<code>react</code>的时候，方法难免还要在构造函数中<code>bind</code>一次，当然如果方法是箭头函数的话麻烦少很多。</p><h2 id="mixin">mixin</h2><p><code>createClass</code>依然与<code>vue</code>的差不多（<code>vue</code>抄得妙啊），遗憾<code>classes</code>不支持<code>mixin</code>了。</p><p>我也不喜欢<code>mixin</code>，也觉得这东西不适合<code>react</code>的理念。<code>mixin</code>是把一个对象的内容与另一个对象的内容合并，看起来复用性利用率很高（别bb抽就完事儿了嗷），但，同名函数怎么办？改动怎么办？东西一多就沉浸在不断重写<s>与复读</s>，造成副作用，牵一发而动全身的情况。</p><p>高阶函数多好，编写一个可复用函数，把计划使用复用内容的函数或对象以参数形式传入，在使用组件或者函数的同时又把复用内容执行完。首先<code>HOC</code>可以想象成是「悠米」——它挂在你身上，加盾，加速，加血，加自适应。它挂在谁身上都一样，不受干扰。</p><blockquote><p>只要我的队友还活着，我就不会遭受苦难 —— 悠米</p></blockquote><p>而每次经过高阶函数之后又是一个新的函数，每个新函数相对独立，不存在副作用。</p><p>但<code>HOC</code>写起来还是有两种，以<code>react</code>返回<code>Component</code>来说，返回的对象又会有两种。</p><ul><li>返回的<code>Component</code>继承于全新的<code>React.Component</code>(react-redux:connect)</li><li>返回的<code>Component</code>继承于参数的<code>Component</code>(反向继承)(reabit:inject)</li></ul><p>第一种最后的结果是<code>render</code>时以组件的形式调用参数，第二种则是通过<code>super</code>在各种地方执行（整个方法执行直接在构造函数执行<code>super([传入适用原组件props])</code>），各有利弊。</p><p>而因为反向继承的关系，我可以获得组件很多内容，所以某种意义上可以当做<code>mixin</code>使用。</p><p>不过毕竟<code>HOC</code>，有一个问题：原组件如果存在<code>static</code>方法将不能被使用。</p>]]></content:encoded>
      
      <comments>https://colmugx.github.io/blog/2019/05/28/react-component-method/#disqus_thread</comments>
    </item>
    
    <item>
      <title>defineProperty? Proxy?</title>
      <link>https://colmugx.github.io/blog/2019/04/20/why-vue-proxy/</link>
      <guid>https://colmugx.github.io/blog/2019/04/20/why-vue-proxy/</guid>
      <pubDate>Sat, 20 Apr 2019 04:47:12 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;听说 Vue3 数据绑定要切换到 Proxy，为什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就是这篇文章的原因，来源于某个牛逼公司的面试。&lt;s&gt;我真的应该学会怎么清楚表达观点…&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;defineProperty&lt;/code&gt; 和 &lt;code&gt;Proxy&lt;/code&gt; 使用方式和效果看起来是差不多的，但如果翻译成中文的话，一个是定义属性，一个是代理，并且 MDN 上描述有所不同。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 —— MDN&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。  —— MDN&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;defineProperty&quot;&gt;defineProperty&lt;/h2&gt;
&lt;p&gt;这是一个 &lt;code&gt;ES5&lt;/code&gt; 的方法。一个 &lt;code&gt;defineProperty&lt;/code&gt; 需要三个参数，都是 &lt;code&gt;require&lt;/code&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>听说 Vue3 数据绑定要切换到 Proxy，为什么？</p></blockquote><p>这就是这篇文章的原因，来源于某个牛逼公司的面试。<s>我真的应该学会怎么清楚表达观点…</s></p><p><code>defineProperty</code> 和 <code>Proxy</code> 使用方式和效果看起来是差不多的，但如果翻译成中文的话，一个是定义属性，一个是代理，并且 MDN 上描述有所不同。</p><blockquote><p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 —— MDN</p></blockquote><blockquote><p>Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。  —— MDN</p></blockquote><h2 id="defineProperty">defineProperty</h2><p>这是一个 <code>ES5</code> 的方法。一个 <code>defineProperty</code> 需要三个参数，都是 <code>require</code></p><a id="more"></a><blockquote><p>Object.defineProperty(obj, prop, descriptor)<br>obj: object, 定义的对象（我理解为附着于哪个对象）<br>prop: 定义的对象名称(key)<br>descriptor: 将被定义或修改的属性描述符。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'colmugx'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>descriptor</code> 存在可选项：</p><table><thead><tr><th style="text-align:left">key</th><th style="text-align:left">value</th></tr></thead><tbody><tr><td style="text-align:left">configurable</td><td style="text-align:left">该属性为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</td></tr><tr><td style="text-align:left">enumerable</td><td style="text-align:left">该属性为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。</td></tr><tr><td style="text-align:left">value</td><td style="text-align:left">该属性对应的值。</td></tr><tr><td style="text-align:left">writable</td><td style="text-align:left">该属性为 true 时，value才能被赋值运算符改变。默认为 false。</td></tr><tr><td style="text-align:left">get</td><td style="text-align:left">getter 方法</td></tr><tr><td style="text-align:left">set</td><td style="text-align:left">setter 方法</td></tr></tbody></table><p>除了 <code>boolean</code> 类型，值都默认为 <code>undefined</code></p><h2 id="Proxy">Proxy</h2><p>这是一个 <code>ES6</code> 的方法，<code>Proxy</code> 参数比较简单</p><blockquote><p>new Proxy(target, handler)<br>target: 目标对象<br>handler: 属性/操作对象，当执行一个操作时定义代理的行为的函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, name) &#123;</span><br><span class="line">    <span class="keyword">return</span> name <span class="keyword">in</span> target ? target[name] : target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="？">？</h2><h3 id="数据拦截">数据拦截</h3><p>先看看 <code>Vue</code> 那种数据拦截是怎样的，做一个简单实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> value = <span class="literal">undefined</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'key'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span>(val) &#123;</span><br><span class="line">    value = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>很明显，我可以劫持一个对象的 <code>getter</code> 和 <code>setter</code>，同时也很明显，貌似需要一个缓存量。</p><p>如果说和 <code>Proxy</code> 比较呢？因为 <code>Proxy</code> 实现的是代理下整个对象，那么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;<span class="attr">key</span>: <span class="literal">undefined</span>&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">    <span class="comment">// 由于代理了所有操作，那么返回 404 纯属意愿</span></span><br><span class="line">    <span class="keyword">return</span> prop <span class="keyword">in</span> target ? target[prop] : <span class="string">'404 Not Found'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span>(val) &#123;</span><br><span class="line">    target[prop] = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>写法有点像<code>computed</code></p><p>那么，为什么<code>defineProperty</code>不直接<code>target[prop] = val</code>？因为劫持关系，你会看到狗咬尾巴的奇观。也就是说，<code>defineProperty</code> 对原对象操作就会触发劫持，而<code>Proxy</code>操作的是实例对象，每个实例对象相对独立。</p><p>所以通过两次面试，闭环了这个知识。另外一篇：<a href="/blog/2018/03/16/vue-watcher">vue watch存在永动吗？</a></p><p>然而<code>Vue</code>换方式，显然不止因为这个，或许连这个都谈不上。</p><h3 id="只需要-defineProperty？怎么可能？">只需要 defineProperty？怎么可能？</h3><p>首先，上面例子这种方式可以看出，我每次操作都只能监听一个值，但一个应用不可能只有一个属性，而且没办法及时知道哪一个属性获得了更新。在深入了解之后，<code>Vue</code>好像用了订阅的方式在做这些事情。</p><p><a href="https://github.com/vuejs/vue/blob/52719ccab8/src/core/observer/index.js#L109" target="_blank" rel="noopener">vue/src/core/observer/index.js#L109</a></p><p>除了简单（没有深度）数据，其他一概遍历进观察者。</p><h3 id="为什么-Proxy？">为什么 Proxy？</h3><ol><li><code>defineProperty</code> 对数组有硬伤</li></ol><p>因为设定关系，<code>defineProperty</code>不能观察到数组内部，如果直接修改数组而不是返回新数组的话，无法触发劫持。<code>Vue</code>文档以一个简单的方式解释了<a href="https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B" target="_blank" rel="noopener">这个问题</a>，解决这个问题的方法有点骚，<a href="https://github.com/vuejs/vue/blob/52719ccab8fccffbdf497b96d3731dc86f04c1ce/src/core/observer/array.js#L11" target="_blank" rel="noopener">相关源码位置</a>。但这只是让数组方法可以“正常使用”，万一有人<code>arr[0] = 0</code>呢？</p><ol start="2"><li>一个方法只能监听一个属性</li></ol><p>如果我需要监听这个对象里所有键，我需要把所有键都<code>defineProperty</code>一次。需要创建一个缓存变量倒不是什么“难事”，封装成一个方法就成了，但：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">d</span>: &#123; <span class="attr">e</span>: <span class="string">'???'</span> &#125;&#125;&#125;&#125;&#125;  <span class="comment">// ???</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>Proxy</code> 可以做到上面所有事情</li></ol><p>上面提到，<code>Proxy</code>是代理了整个对象，而且是以根据 target 创建实例来进行接下来的工作，每一个都相对独立。</p><p>第一个问题，因为我们有这个“对象”的所有操作权，而且每次<code>set</code>都能返回新的“对象”，并且我们可以自己定义“数据如何改变”</p><p>第二个问题，因为<code>Proxy</code>实现的是观察到整个对象而不是对象属性，那自然不存在这个问题了。</p><ol start="4"><li>除了 <code>getter</code>, <code>setter</code>，<code>Proxy</code>还有其他用法</li></ol><p>比如<code>apply</code>，可以劫持对象的函数（我的理解是把对象可以执行，当然JavaScript中，一切都是对象）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  apply(target, context, args) &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所以你可以执行一些东西，甚至是通过方法创建/改变得到一个对象（对 target 直接修改）</p><p>感觉，如果<code>Vue3</code>用<code>Proxy</code>改写之后，代码会简洁非常多。而且性能可能会比现在提高好几倍（？），毕竟看目前得到的信息，对每一个数据创建<code>Observer</code> + <code>defineProperty</code>，性能挺要命的……</p><h3 id="补充">补充</h3><p><code>Proxy</code>在这里的用法只能说是「能当对象使用的对象」吧，毕竟它还是一个实例(Proxy(…)，而<code>defineProperty</code>操作的是意义上的对象。</p><p>而且我本以为我应该会先读<code>React</code>的源码，没想到…</p><h2 id="为什么-Vue2-不直接用-Proxy">为什么 Vue2 不直接用 Proxy</h2><p><code>Vue</code> 最早出现于 2013 年，<code>ES2015</code> 规范确定于 2015年，目前找不到 <code>Vue2</code> 第一个 commit 是什么时候（懒），推算了一下，不应该是赶不上，所以有第二种猜想：兼容性问题。</p><p><code>Vue</code>可以支持到 IE9+，目前的兼容性是 IE10+。首先<code>Proxy</code>就已经把 IE 完整的抛弃掉了，一点点都不支持。就算上 <code>polyfill</code>，也仅可以使用<code>get</code>, <code>set</code>, <code>apply</code>, <code>construct</code>，而 <code>Proxy</code> 的钩子(陷阱)达到十几种，显然物尽其能是不可能。</p><p>时代不同了，现在是现代浏览器时代，IE 淡出，连 Edge 都投靠敌台了。话说我最喜欢的就是最后一代斯巴达，渲染很快又开始支持插件。</p><h2 id="Vue-React">Vue &amp; React</h2><p>18 年我经常说的就是，如果技术参差不齐的团队，显然<code>Vue</code>更合适。反正你照着说明书一行一行抄肯定不会抄出问题。<strong>所以我不喜欢 Vue 就是因为不够自由，但如果无法驾驭自由，React 性能会更差。</strong></p><p>其中一个原因就是 <code>Vue</code> 跟 <code>React</code> 对数据的操作是不一样的。<code>React</code>单向，通过对比来更新数据，所以今日会有两种组件创建方式：<code>Component</code>, <code>PureComponent</code>。</p><blockquote><p>为什么 React 不学 Vue 搞这手，表单验证之类工作不是很好实现</p></blockquote><p>大家的想法都不一样为什么要强比较？所以我的回答是：</p><blockquote><p>这是 React 的设计原因，React 的做法是数据流单向，利用函数式的思想，像管道一样的操作使得副作用更加可控。</p></blockquote><p>只是回答得不完美，我有面试就紧张的坏心态。我的本意是我可以清楚数据的流向，同时采用数据不可变，这样根本不用担心数据在中途突然被什么做了修改。因为前面的原因，第二个问题忘记回答了：因为用函数式的思想，那么表单验证我可以用高阶函数呀。</p><p>但并不是说<code>Vue</code>的做法不是高阶函数，其实也是的。只是我们在用<code>React</code>的时候，感觉<code>React</code>只提供了把代码转成视图的功能，就没了，什么都没有什么都是自己实现。而<code>Vue</code>已经实装了非常多的操作使得开发过程不用想多一些问题。举一个小栗子：<code>React</code>渲染一个列表，靠的是自己用<code>JavaScript</code>的方法生成一个装着<code>ReactNode</code>的数组，而<code>Vue</code>只需要在模板中标记列表数据和在哪个节点渲染，把要渲染的内容写在其中即可。</p>]]></content:encoded>
      
      <comments>https://colmugx.github.io/blog/2019/04/20/why-vue-proxy/#disqus_thread</comments>
    </item>
    
    <item>
      <title>关于 Nlvi 「添加到桌面」</title>
      <link>https://colmugx.github.io/blog/2019/04/17/about-nlvi-pwa/</link>
      <guid>https://colmugx.github.io/blog/2019/04/17/about-nlvi-pwa/</guid>
      <pubDate>Wed, 17 Apr 2019 09:36:28 GMT</pubDate>
      <description>
      
        &lt;p&gt;其实这个功能早在 2.x 版本就加入了，那时候对 PWA 并没有什么概念。&lt;s&gt;好想换 iPad Mini (new)&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/Image/nlvi-ios-desktop.gif&quot; alt=&quot;nlvi-ios-desktop&quot;&gt;&lt;/p&gt;
&lt;p&gt;目前 3.x 只改了启动图，适配了 iPad 横屏和 iPhone 全面屏（普通屏和plus后续加）。之前看到苹果对 PWA 持拒绝态度我是震惊的，你 tm 早就给 safari 加入了这个功能，也有相关&lt;code&gt;meta&lt;/code&gt;配置（包括”识别为&lt;code&gt;WebApp&lt;/code&gt;“），然后你告诉我这东西不是 PWA？&lt;/p&gt;
&lt;p&gt;本来确实想支持 PWA 的，想到除了要 &lt;code&gt;manifest.json&lt;/code&gt;，还要搞定对应生成 &lt;code&gt;service worker&lt;/code&gt;，使用不是很友好，所以取消计划。这部分添加功能就是一个尝试的甜点，所以也没有拿出来说。目前 3.x 开启 &lt;code&gt;pjax&lt;/code&gt; 然后添加到桌面，阅读体验还是挺好的。&lt;/p&gt;
&lt;p&gt;所以这次打算讲讲「苹果式网页应用安装」，其实挺简单的。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>其实这个功能早在 2.x 版本就加入了，那时候对 PWA 并没有什么概念。<s>好想换 iPad Mini (new)</s></p><p><img src="/blog/Image/nlvi-ios-desktop.gif" alt="nlvi-ios-desktop"></p><p>目前 3.x 只改了启动图，适配了 iPad 横屏和 iPhone 全面屏（普通屏和plus后续加）。之前看到苹果对 PWA 持拒绝态度我是震惊的，你 tm 早就给 safari 加入了这个功能，也有相关<code>meta</code>配置（包括”识别为<code>WebApp</code>“），然后你告诉我这东西不是 PWA？</p><p>本来确实想支持 PWA 的，想到除了要 <code>manifest.json</code>，还要搞定对应生成 <code>service worker</code>，使用不是很友好，所以取消计划。这部分添加功能就是一个尝试的甜点，所以也没有拿出来说。目前 3.x 开启 <code>pjax</code> 然后添加到桌面，阅读体验还是挺好的。</p><p>所以这次打算讲讲「苹果式网页应用安装」，其实挺简单的。</p><a id="more"></a><h2 id="meta">meta</h2><p>这里没有列出所有关于 safari 支持的 meta，只针对这个功能部分。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-touch-fullscreen"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-capable"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-title"</span> <span class="attr">content</span>=<span class="string">"Colmugx's Blog"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-status-bar-style"</span> <span class="attr">content</span>=<span class="string">"default"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon"</span>  <span class="attr">sizes</span>=<span class="string">"72x72"</span>  <span class="attr">href</span>=<span class="string">"icon.ico"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon-precomposed"</span>  <span class="attr">sizes</span>=<span class="string">"72x72"</span>  <span class="attr">href</span>=<span class="string">"icon.ico"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-startup-image"</span> <span class="attr">media</span>=<span class="string">"(device-width: 375px)"</span> <span class="attr">href</span>=<span class="string">"apple-launch-1125x2436.png"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-startup-image"</span> <span class="attr">media</span>=<span class="string">"(orientation: landscape)"</span> <span class="attr">href</span>=<span class="string">"apple-touch-startup-image-2048x1496.png"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从上到下分别是：</p><ul><li>添加到主屏幕后，是否全屏显示</li><li>是否显示 safari 菜单</li><li>应用默认名称（在添加的时候可以修改）</li><li>打开时，顶上状态栏应该呈现什么颜色（白色，黑色，透明）</li><li>设置 icon (72x72, 114x114)，图标在「书签」也可适用</li><li>设置启动画面（这里只设置了手机与平板横置）</li></ul><h2 id="apple-touch-startup-image">apple-touch-startup-image</h2><p>其他的没什么坑点，只是<code>apple-touch-startup-image</code>会复杂一些。它分成很多分辨率，设置不清楚的话就不会显示。而且它不能像图标一样设置<code>size</code>。只能用<code>media</code>一行一行写。</p><p>比如 iPad，设置倒是不需要跟手机一样那么多图片，只需要准备一张垂直一张水平。垂直 <code>768x1024</code>，水平<code>748x1024</code>，水平图也需要摆成垂直的，也就是<code>1024x748</code>，当然内容也是横直，相当于顺时针 90°。接着就考虑一下屏幕用的是二倍图还是三倍图了。</p><p>参考文章：<a href="https://medium.com/appscope/adding-custom-ios-splash-screens-to-your-progressive-web-app-41a9b18bdca3" target="_blank" rel="noopener">Adding Custom iOS Splash Screens To Your Progressive Web App</a></p>]]></content:encoded>
      
      <comments>https://colmugx.github.io/blog/2019/04/17/about-nlvi-pwa/#disqus_thread</comments>
    </item>
    
    <item>
      <title>我今天给 let 安排了</title>
      <link>https://colmugx.github.io/blog/2019/03/27/you-dont-know-let/</link>
      <guid>https://colmugx.github.io/blog/2019/03/27/you-dont-know-let/</guid>
      <pubDate>Wed, 27 Mar 2019 10:13:29 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Round-1&quot;&gt;Round 1&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;- 我现在把所有东西都注释掉，改成这样&lt;br&gt;
function a() {&lt;br&gt;
return inner;&lt;br&gt;
let inner;&lt;br&gt;
}&lt;br&gt;
返回什么？&lt;/p&gt;
&lt;p&gt;- 那就应该 undefined 了，反正后面不执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自信的不行，出了门掏出全世界最牛逼的千元机&lt;strong&gt;坚果 Pro 2S&lt;/strong&gt;，验证了一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;inner is not defined&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;确实是不执行，但好像不是 &lt;code&gt;undefined&lt;/code&gt; 啊╭(*ﾟДﾟ*)╮&lt;/p&gt;
&lt;h3 id=&quot;Round-2&quot;&gt;Round 2&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;- 如果改成这样呢&lt;br&gt;
function a() {&lt;br&gt;
function inner() {}&lt;br&gt;
return inner;&lt;br&gt;
let inner;&lt;br&gt;
}&lt;br&gt;
返回什么？&lt;/p&gt;
&lt;p&gt;- 返回方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自信的不行，同样用全世界最牛逼的千元机&lt;strong&gt;坚果 Pro 2S&lt;/strong&gt;，验证了一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Identifier ‘inner’ has already been declared&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(ﾟДﾟ≡ﾟдﾟ)!? 你在返回你🐴呢？&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Round-1">Round 1</h3><blockquote><p>- 我现在把所有东西都注释掉，改成这样<br>function a() {<br>return inner;<br>let inner;<br>}<br>返回什么？</p><p>- 那就应该 undefined 了，反正后面不执行</p></blockquote><p>自信的不行，出了门掏出全世界最牛逼的千元机<strong>坚果 Pro 2S</strong>，验证了一下。</p><blockquote><p>inner is not defined</p></blockquote><p>确实是不执行，但好像不是 <code>undefined</code> 啊╭(*ﾟДﾟ*)╮</p><h3 id="Round-2">Round 2</h3><blockquote><p>- 如果改成这样呢<br>function a() {<br>function inner() {}<br>return inner;<br>let inner;<br>}<br>返回什么？</p><p>- 返回方法</p></blockquote><p>自信的不行，同样用全世界最牛逼的千元机<strong>坚果 Pro 2S</strong>，验证了一下。</p><blockquote><p>Identifier ‘inner’ has already been declared</p></blockquote><p>(ﾟДﾟ≡ﾟдﾟ)!? 你在返回你🐴呢？</p><a id="more"></a><h2 id="Why">Why?</h2><p>原本我以为只有 <code>var</code> 会变量提升，实际上错了，<code>var/let/const</code>都会。</p><p><code>var</code> 和 <code>let</code> 在某种时候是相似的，他们都会提升，但 <code>let</code> 少了初始化的过程。MDN 对 <code>let</code> 死区是这么解释的</p><blockquote><p>在 ECMAScript 2015 中，let 绑定不受变量提升的约束，这意味着 let  声明不会被提升到当前执行上下文的顶部。在块中的变量初始化之前，引用它将会导致 ReferenceError（而使用 var 声明变量则恰恰相反，该变量的值是 undefined ）。这个变量处于从块开始到 let 初始化处理的”暂存死区“之中。 —— MDN</p></blockquote><p>暂存死区又有这么个说法，用一个代码块解释一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  a = <span class="string">'caonima'</span> <span class="comment">// 下面有 let，a 直接被该块锁定，这里报错</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> a <span class="comment">// 到这里才完成初始化，变量开始正常使用，但变量早已提升</span></span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// 这里不是 caonima 而是 undefined</span></span><br><span class="line"></span><br><span class="line">  a = <span class="string">'woshinidie'</span></span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// woshinidie</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/getify/You-Dont-Know-JS/issues/767" target="_blank" rel="noopener">You-Dont-Know-JS#767</a> 讨论了这个问题, creeperyang 总结了四点</p><blockquote><ol><li>Hoisting includes both declare and initialize.</li><li>Only initialized variable can be used in a scope.</li><li>var do both declare and initialize, the two cannot be split for var.</li><li>let do firstly declare in the top of the scope, and do initialize when encounter the let xxx statements.<br>—— @creeperyang</li></ol></blockquote><p>另外，方应杭在知乎专栏的文章<a href="https://zhuanlan.zhihu.com/p/28140450" target="_blank" rel="noopener">《我用了两个月的时间才理解 let》</a>也总结出</p><blockquote><ol><li>let 的「创建」过程被提升了，但是初始化没有提升。</li><li>var 的「创建」和「初始化」都被提升了。</li><li>function 的「创建」「初始化」和「赋值」都被提升了。<br>—— <a href="https://www.zhihu.com/people/zhihusucks" target="_blank" rel="noopener">@方应杭</a></li></ol></blockquote><p>理论上 <code>const</code> 应该是 <code>let</code> 的不可修改版本，所以应该是类似的。但也仅限提升原理相同，因为 <code>const</code> 只能初始化时赋值一次。</p><p>不过，阮一峰的《ECMAScript 6 入门》是什么意思？在 let 有单独一小节讲 <a href="http://es6.ruanyifeng.com/#docs/let#%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87" target="_blank" rel="noopener">不存在变量提升</a>，虽然后面解释了暂时性死区，但……</p><p>总结：被安排明白了。根据 @Ahonn 所说，这个问题在高程有讲过，书读少了读少了</p><p>（最后感谢所有被引用的文章和作者，谢谢。）</p>]]></content:encoded>
      
      <comments>https://colmugx.github.io/blog/2019/03/27/you-dont-know-let/#disqus_thread</comments>
    </item>
    
    <item>
      <title>最后的 Nlvi</title>
      <link>https://colmugx.github.io/blog/2019/03/25/bye-nlvi/</link>
      <guid>https://colmugx.github.io/blog/2019/03/25/bye-nlvi/</guid>
      <pubDate>Mon, 25 Mar 2019 06:34:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;code&gt;Nlvi&lt;/code&gt; 可以说起源于正准备上班和刚上班工作不饱和(大雾。为了练习自己对语义化 HTML 理解和 CSS 的渐进式学习而诞生的，到现在已经 2 年了。&lt;/p&gt;
&lt;p&gt;那个时候还用 iPad 画草图然后慢慢写起来，而且当时编程能力确实还挺弱，hexo 很多都弄不清楚。现在对 hexo 就熟悉很多了，设计稿也从随便画画变成了用 sketch，但也是杀鸡用牛刀。&lt;/p&gt;
&lt;p&gt;过程中也是各种骚想法，比如用 Vue/React 改写啊；脱离 jQuery 啊；用 pjax 啊；用更复杂的动画啊……不过我现在想的是：新版本(我博客正在用的半成品)做完之后，就不想迭代了。&lt;/p&gt;
&lt;p&gt;为什么？因为一旦工作太忙没时间，又想到这个东西，好累啊……&lt;/p&gt;
&lt;p&gt;但，我的意思是，&lt;strong&gt;我不想维护 hexo 版本的 Nlvi 了&lt;/strong&gt;，我的意思是，诶嘿嘿嘿嘿嘿！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><code>Nlvi</code> 可以说起源于正准备上班和刚上班工作不饱和(大雾。为了练习自己对语义化 HTML 理解和 CSS 的渐进式学习而诞生的，到现在已经 2 年了。</p><p>那个时候还用 iPad 画草图然后慢慢写起来，而且当时编程能力确实还挺弱，hexo 很多都弄不清楚。现在对 hexo 就熟悉很多了，设计稿也从随便画画变成了用 sketch，但也是杀鸡用牛刀。</p><p>过程中也是各种骚想法，比如用 Vue/React 改写啊；脱离 jQuery 啊；用 pjax 啊；用更复杂的动画啊……不过我现在想的是：新版本(我博客正在用的半成品)做完之后，就不想迭代了。</p><p>为什么？因为一旦工作太忙没时间，又想到这个东西，好累啊……</p><p>但，我的意思是，<strong>我不想维护 hexo 版本的 Nlvi 了</strong>，我的意思是，诶嘿嘿嘿嘿嘿！</p><a id="more"></a><p>所以 2.0 到 3.0 大概的改动会是：</p><ul><li>根据我对统一风格的想法，(又)变动部分设计风格</li><li>根据我对统一风格的想法，调整部分部件展示形式</li><li>根据我对统一风格的想法，对颜色变量重新管理</li><li>去掉以前的标签云，重写一个</li><li>去掉以前的搜索框，重写一个</li><li>变动部分不成熟动画，改动动画曲线</li><li><strong>加入渐变色的设定！(Maybe)</strong></li></ul>]]></content:encoded>
      
      <comments>https://colmugx.github.io/blog/2019/03/25/bye-nlvi/#disqus_thread</comments>
    </item>
    
    <item>
      <title>做不完的题目</title>
      <link>https://colmugx.github.io/blog/2019/03/23/last-test-questions/</link>
      <guid>https://colmugx.github.io/blog/2019/03/23/last-test-questions/</guid>
      <pubDate>Sat, 23 Mar 2019 06:00:50 GMT</pubDate>
      <description>
      
        &lt;p&gt;又在「杂乱的工作台上」完成文章……&lt;/p&gt;
&lt;p&gt;没错又错过一个非常好的机会。与其说是因为时间不够做不完，还不如说是因为陷入斐波那契思考导致做不完。&lt;/p&gt;
&lt;p&gt;不留遗憾，把它搞完。题源就不说了。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>又在「杂乱的工作台上」完成文章……</p><p>没错又错过一个非常好的机会。与其说是因为时间不够做不完，还不如说是因为陷入斐波那契思考导致做不完。</p><p>不留遗憾，把它搞完。题源就不说了。</p><a id="more"></a><h2 id="1-现有-a-b-c-d-四个接口，找出最快的那个。异步用-setTimeout-模拟">1. 现有 /a, /b, /c, /d 四个接口，找出最快的那个。异步用 setTimeout 模拟</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requests: <span class="built_in">Promise</span>&lt;<span class="built_in">string</span>&gt;[]</span><br><span class="line">  = [<span class="string">'/a'</span>, <span class="string">'/b'</span>, <span class="string">'/c'</span>, <span class="string">'/d'</span>]</span><br><span class="line">  .map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">1000</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">`<span class="subst">$&#123;v&#125;</span> spent <span class="subst">$&#123;time&#125;</span>`</span>)</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race(requests).then(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://colmugx.github.io/blog/2019/03/23/last-test-questions/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Redux —— combineReducers</title>
      <link>https://colmugx.github.io/blog/2019/03/08/redux-combinereducers/</link>
      <guid>https://colmugx.github.io/blog/2019/03/08/redux-combinereducers/</guid>
      <pubDate>Fri, 08 Mar 2019 06:49:12 GMT</pubDate>
      <description>
      
        &lt;p&gt;事出有因，写 &lt;code&gt;rabbit&lt;/code&gt; 的时候，一条单测出了问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Reducer _object returned undefined during initialization.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想来必然是 &lt;code&gt;reducer&lt;/code&gt; 缺少默认的 &lt;code&gt;state&lt;/code&gt; 所致，&lt;s&gt;但是我的单测是从 &lt;code&gt;dva&lt;/code&gt; 直接拿过来改改就用的，应该不会出现问题，所以一定是哪里出了差错。后面发现了，虽然 &lt;code&gt;dva&lt;/code&gt; 可以接受 &lt;code&gt;reducers&lt;/code&gt; 是空对象，但应用运行起来有一样问题。&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;主要是这个问题无伤大雅，&lt;code&gt;model&lt;/code&gt; 不会出现只有 &lt;code&gt;reducers&lt;/code&gt; 这种情况。我也给出了解决：构建 &lt;code&gt;reducer&lt;/code&gt; 给一个默认 &lt;code&gt;state&lt;/code&gt; 顶着（但我认为一个 &lt;code&gt;model&lt;/code&gt; 应该强制存在 &lt;code&gt;state&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;显然这次并不想讲这个，而是想理解 &lt;code&gt;combineReducers&lt;/code&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>事出有因，写 <code>rabbit</code> 的时候，一条单测出了问题</p><blockquote><p>Reducer _object returned undefined during initialization.</p></blockquote><p>想来必然是 <code>reducer</code> 缺少默认的 <code>state</code> 所致，<s>但是我的单测是从 <code>dva</code> 直接拿过来改改就用的，应该不会出现问题，所以一定是哪里出了差错。后面发现了，虽然 <code>dva</code> 可以接受 <code>reducers</code> 是空对象，但应用运行起来有一样问题。</s></p><p>主要是这个问题无伤大雅，<code>model</code> 不会出现只有 <code>reducers</code> 这种情况。我也给出了解决：构建 <code>reducer</code> 给一个默认 <code>state</code> 顶着（但我认为一个 <code>model</code> 应该强制存在 <code>state</code>）</p><p>显然这次并不想讲这个，而是想理解 <code>combineReducers</code></p><a id="more"></a><p><code>combineReducers</code> 一共有 4 个方法：</p><ul><li><code>getUndefinedStateErrorMessage</code></li><li><code>getUnexpectedStateShapeWarningMessage</code></li><li><code>assertReducerShape</code></li><li>(主要方法) <code>combineReducers</code></li></ul><h2 id="getUndefinedStateErrorMessage">getUndefinedStateErrorMessage</h2><p>很明显，这是一个生成错误信息的方法。主要是限制 <code>reducer</code> 必须返回 <code>state</code></p><h2 id="assertReducerShape">assertReducerShape</h2><p>这是一个检查 <code>reducer</code> 是否合规的方法。</p><p>首先接受一个集合所有 <code>reducer</code> 的对象进行遍历，每一个抽出来检验，做一次运行尝试，看是否能得到 <code>state</code>。如果得到的 <code>state</code> 为  <code>undefined</code> 则该 <code>reducer</code> 是非法的。</p><p>文中开头提到的问题正是由这里报出，因为我们给出的 <code>reducers</code> 为空对象，且 <code>state</code> 为 <code>undefined</code>，所以自然会报错。<code>dva</code> 的单测只检查 <code>model</code> 的合理性，且 <code>state</code> 允许任何内容和 <code>reducers</code> 允许空对象，并没有考虑一个 <code>model</code> 同时不存在这两者的情况，不过显然没意义，所以目前是不清楚 <code>dva</code> 团队是没想到还是也觉得无所谓。</p><h2 id="combineReducers">combineReducers</h2><p>这是这组方法中的核心，该方法也作为默认方法导出。这组方法的目的是把一群 <code>reducer</code> 合并为一个方法供 <code>createStore</code> 使用。</p><p>上来是两组变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提取对象中所有字段名，一个 key 对应一个 reducer 方法</span></span><br><span class="line"><span class="keyword">const</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers)</span><br><span class="line"><span class="comment">// 由下面可得，该变量用来暂存基本合理（reducer 是一个方法）的 reducer 方法。</span></span><br><span class="line"><span class="keyword">const</span> finalReducers = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">'function'</span>) &#123;</span><br><span class="line">  finalReducers[key] = reducers[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果在非生产环境中，还会提示仅有 key 没有方法的值以方便我们修改调试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再把初步验证过的 reducer 取出</span></span><br><span class="line"><span class="keyword">const</span> finalReducerKeys = <span class="built_in">Object</span>.keys(finalReducers)</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> shapeAssertionError</span><br><span class="line"><span class="comment">// 放入刚刚用来验证 reducer 合规的方法进行第二次验证，并做错误处理</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  assertReducerShape(finalReducers)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  shapeAssertionError = e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是返回一个新的 <code>reducer</code>，并对所有传入的合规的 <code>reducer</code> 进行 diff。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个对比记录变量以及新 state</span></span><br><span class="line"><span class="keyword">let</span> hasChanged = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> nextState = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历刚刚验证完的 reducer key 数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> key = finalReducerKeys[i]</span><br><span class="line">  <span class="keyword">const</span> reducer = finalReducers[key]</span><br><span class="line">  <span class="comment">// 获取当前 state</span></span><br><span class="line">  <span class="keyword">const</span> previousStateForKey = state[key]</span><br><span class="line">  <span class="comment">// 通过执行 reducer 得到新的 state</span></span><br><span class="line">  <span class="keyword">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> nextStateForKey === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> errorMessage = getUndefinedStateErrorMessage(key, action)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(errorMessage)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 并将新 reducer 产物绑定到 nextState，key 不变。（方便对比）</span></span><br><span class="line">  nextState[key] = nextStateForKey</span><br><span class="line">  <span class="comment">// 右式第一个 hasChanged 表达：如果已经为 true 那么就肯定 true，没必要再去对比验证</span></span><br><span class="line">  hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回：有改变的返回新的，无改变返回原 state。</span></span><br><span class="line"><span class="keyword">return</span> hasChanged ? nextState : state</span><br></pre></td></tr></table></figure><p>所以这组方法目的就是把所有复杂的 <code>reducer</code> 和 <code>state</code> 组成新的状态树，统一管理。业务开发时可以根据需求拆分多个 <code>reducer</code> 和 <code>state</code>，便于开发和组织。</p>]]></content:encoded>
      
      <comments>https://colmugx.github.io/blog/2019/03/08/redux-combinereducers/#disqus_thread</comments>
    </item>
    
    <item>
      <title>看过 Redux 之后，我写了一个不负责任的状态管理</title>
      <link>https://colmugx.github.io/blog/2019/03/02/about-redux/</link>
      <guid>https://colmugx.github.io/blog/2019/03/02/about-redux/</guid>
      <pubDate>Sat, 02 Mar 2019 10:00:19 GMT</pubDate>
      <description>
      
        &lt;p&gt;我们现在小程序需要使用状态管理，但因为项目体量实在很小又没必要使用 redux 或者 mobx。所以我打算不负责任的写一个。&lt;/p&gt;
&lt;h2 id=&quot;createStore&quot;&gt;createStore&lt;/h2&gt;
&lt;p&gt;Redux 最核心的部分，提供基础的功能。&lt;code&gt;createStore&lt;/code&gt;接受三个参数：&lt;code&gt;reducer&lt;/code&gt;, &lt;code&gt;initialState&lt;/code&gt;, &lt;code&gt;enhancer&lt;/code&gt;。前两个比较好理解，&lt;code&gt;enhancer&lt;/code&gt;主要用在接受中间件中。返回产物我们主要使用三个方法：&lt;code&gt;getState&lt;/code&gt;, &lt;code&gt;dispatch&lt;/code&gt;, &lt;code&gt;subscribe&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getState&lt;/code&gt;：获取当前 state 值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;subscribe&lt;/code&gt;：接受监听，存入 &lt;code&gt;listeners&lt;/code&gt; 池中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dispatch&lt;/code&gt;：处理 &lt;code&gt;reducer&lt;/code&gt; 操作，触发 &lt;code&gt;listeners&lt;/code&gt; 方法&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>我们现在小程序需要使用状态管理，但因为项目体量实在很小又没必要使用 redux 或者 mobx。所以我打算不负责任的写一个。</p><h2 id="createStore">createStore</h2><p>Redux 最核心的部分，提供基础的功能。<code>createStore</code>接受三个参数：<code>reducer</code>, <code>initialState</code>, <code>enhancer</code>。前两个比较好理解，<code>enhancer</code>主要用在接受中间件中。返回产物我们主要使用三个方法：<code>getState</code>, <code>dispatch</code>, <code>subscribe</code>。</p><ul><li><code>getState</code>：获取当前 state 值</li><li><code>subscribe</code>：接受监听，存入 <code>listeners</code> 池中</li><li><code>dispatch</code>：处理 <code>reducer</code> 操作，触发 <code>listeners</code> 方法</li></ul><a id="more"></a><p>所有我们需要的东西都了解清楚了，其他的功能和边缘保护先不考虑，这也是为什么说是不负责任的状态管理(逃</p><h2 id="copy">copy</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">store</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currentState = state || &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> listeners = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; getState, dispatch, subscribe &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentState</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line">    listeners.push(listener)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    action.call(<span class="keyword">this</span>, currentState)</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">f</span> =&gt;</span> f.call(<span class="literal">null</span>))</span><br><span class="line">    <span class="keyword">return</span> currentState</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里修改了一些：订阅没有返回取消订阅操作。原因是懒。。<code>dispatch</code> 并不是接受一个纯函数进行数据更新，而是直接由业务修改状态然后通知更新，所以这其实不能算是一个 redux 产物，并且这很不可控。所以这更像是为了利用<code>react-redux</code>或者<code>taro-redux</code>而产生的一种状态保存方式。</p><p>原因还是业务比较简单，就是为了存几个不是很关键的数据但不想使用小程序的 <code>storage</code> 去管理而产生的方法。现在不仅满足业务，压缩后也只有 <code>270b</code> 左右，省点空间给小程序代码，有点赚的实际上。</p>]]></content:encoded>
      
      <comments>https://colmugx.github.io/blog/2019/03/02/about-redux/#disqus_thread</comments>
    </item>
    
    <item>
      <title>一位赌狗前端的自我修养</title>
      <link>https://colmugx.github.io/blog/2018/11/19/gamble-fn/</link>
      <guid>https://colmugx.github.io/blog/2018/11/19/gamble-fn/</guid>
      <pubDate>Mon, 19 Nov 2018 09:57:59 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;这两个月工作巨多，直到今天才有时间写点骚东西。&lt;/p&gt;
&lt;p&gt;可是要写点什么比较好呢？这时候看到了隔壁桌面上放着一张福彩，我脑子里有画面了。（所以这位赌狗不是我，我不买彩票）&lt;/p&gt;
&lt;p&gt;为了方便以后支持更多的彩票，直接搞个类&lt;/p&gt;
&lt;figure class=&quot;hig
        
      
      </description>
      
      <content:encoded><![CDATA[<p>这两个月工作巨多，直到今天才有时间写点骚东西。</p><p>可是要写点什么比较好呢？这时候看到了隔壁桌面上放着一张福彩，我脑子里有画面了。（所以这位赌狗不是我，我不买彩票）</p><p>为了方便以后支持更多的彩票，直接搞个类</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Gamble &#123;</span><br><span class="line">    <span class="keyword">static</span> dualColor(red: <span class="built_in">number</span> = <span class="number">6</span>, blue: <span class="built_in">number</span> = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> reds: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">1</span>, <span class="number">33</span>];</span><br><span class="line">        <span class="keyword">const</span> blues: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">1</span>, <span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">this</span>.randomVal(reds, red), <span class="keyword">this</span>.randomVal(blues, blue)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> randomVal(</span><br><span class="line">        fromto: <span class="built_in">number</span>[],</span><br><span class="line">        total: <span class="built_in">number</span>,</span><br><span class="line">        temp: <span class="built_in">number</span>[] = [],</span><br><span class="line">    ): <span class="built_in">number</span>[] &#123;</span><br><span class="line">        <span class="keyword">const</span> [head, ...body] = (!temp.length</span><br><span class="line">            ? [...Array(fromto[<span class="number">1</span>]).keys()]</span><br><span class="line">                  .map(<span class="function"><span class="params">item</span> =&gt;</span> item + <span class="number">1</span>)</span><br><span class="line">                  .splice(fromto[<span class="number">0</span>] - <span class="number">1</span>)</span><br><span class="line">            : fromto</span><br><span class="line">        ).sort(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">return</span> !total</span><br><span class="line">            ? temp</span><br><span class="line">            : <span class="keyword">this</span>.randomVal(body, total - <span class="number">1</span>, temp.concat(head));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://colmugx.github.io/blog/2018/11/19/gamble-fn/#disqus_thread</comments>
    </item>
    
    <item>
      <title>记在NPM抢空包名的经历</title>
      <link>https://colmugx.github.io/blog/2018/07/12/kill-parentless-on-npm/</link>
      <guid>https://colmugx.github.io/blog/2018/07/12/kill-parentless-on-npm/</guid>
      <pubDate>Thu, 12 Jul 2018 07:10:23 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;强烈谴责某些大厂，前端或者说 JavaScript 是一个极其依赖社区环境的语言，你们在招人之前能不能先调查一下准新人有没有在社区为非作歹？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;年前想搞定&lt;code&gt;React&lt;/code&gt;的时候想了个骚操作：尝试用&lt;code&gt;React&lt;/code&gt;的思路去做&lt;code&gt;Vue&lt;/code&gt;的事情。又诞生了「Vue生态统一可以聚合」的骚想法，开始产生做&lt;code&gt;Ahri&lt;/code&gt;的念头。想着那得搞个 npm 包吧，孤儿上线了。&lt;/p&gt;
&lt;p&gt;嘛，在 npm 拿《英雄联盟》英雄名字抢注包名的做法都很弱智了，还“大义凛然”的在描述里写着：&lt;code&gt;League of Legends hero.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;关于第一次遇到它的时候，我就想算了，重新找合适的名字吧，但后来因为其他原因就搁置了。现在重新回坑，依然遇到这个问题，这次我不忍了，我打算找 npm 肛他！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>强烈谴责某些大厂，前端或者说 JavaScript 是一个极其依赖社区环境的语言，你们在招人之前能不能先调查一下准新人有没有在社区为非作歹？</p></blockquote><p>年前想搞定<code>React</code>的时候想了个骚操作：尝试用<code>React</code>的思路去做<code>Vue</code>的事情。又诞生了「Vue生态统一可以聚合」的骚想法，开始产生做<code>Ahri</code>的念头。想着那得搞个 npm 包吧，孤儿上线了。</p><p>嘛，在 npm 拿《英雄联盟》英雄名字抢注包名的做法都很弱智了，还“大义凛然”的在描述里写着：<code>League of Legends hero.</code></p><p>关于第一次遇到它的时候，我就想算了，重新找合适的名字吧，但后来因为其他原因就搁置了。现在重新回坑，依然遇到这个问题，这次我不忍了，我打算找 npm 肛他！</p><a id="more"></a><h2 id="寻找入口">寻找入口</h2><p>首先看了<code>profile</code>页，发现没有举报入口。（从这里进了Twitter，让人感觉这是一个为了装逼而活着的人。</p><p>看看 npm 本身页面有没有什么入口，比如“联系我们”之类的邮箱总有吧，最后在最下面找到了<code>Reporting Abuse</code>。</p><p>不得不说 npm 连“因为名字打起来”的可能都想到了，那“因为孤儿操作”应该也会列入其中吧，果不其然。在骚扰举报一栏找到了控空包的情况：如果有用户注册无用空包，或者利用包进行乱七八糟的活动，可能有两种措施：ban 了这个用户；清除这些东西。</p><p>我一看到可以 ban 了他我就可兴奋了，于是，发邮件走起。</p><h2 id="采取行动">采取行动</h2><p>操起我400分的4级水平英语，就开始写。</p><blockquote><p>hi,<br>here a profile page: xxxxxx.</p><p>this account keep a lot of empty packages which name as a role name in a game, it cause difficulty for me.</p><p>I NEED HELP! THANK YOU!</p></blockquote><p>过了一会收到回信：</p><blockquote><p>Our support hours are Monday through Friday, 9:00AM - 6:00PM PST, excluding US holidays.</p><p>Your request is being reviewed by our support staff and we’ll be responding soon.</p><p>To add additional comments, reply to this email.</p></blockquote><p>噢，没在工作时间还行。过了几秒又收到一封邮件：</p><blockquote><p>Hey there,</p><p>Thank you for reaching out. We hope you’re having a great week thus far, and are looking forward to responding to your request.</p><p>The npm support staff will be off on Wednesday, July 4th in observance of Independence Day. Due to this, you may experience some delay in expected reply times.</p><p>Thanks for your patience.</p></blockquote><p>狗屎还带放假的？美国员工真的舒服啊，不加班，节假日放满。像我们这种997节假日还放不满的简直受到了6把无尽的暴击。</p><p>等了几天发现不对，没理我，再按照第一封发了一次，这次过了半天多才回。这次差点就怕我气到了，大概的意思就是你上次的 ticket 还没解决，如果你没问题了我们就关了。。。美国人上班都这么摸的？</p><p>又过了半天收到一封邮件，这次是技术客服（邮件是有人名的大佬）发来的：</p><blockquote><p>Thanks for reaching out.</p><p>I was not able to find an account associated with (我发信的邮箱). Was there a specific one of these user’s package names you are interested in for a project?</p><p>If so, we may assist you with a transfer request or granting access to that package, depending on the package and contents.</p></blockquote><p>有点着急，看了第一句之后，下面没仔细看，就有点想搞他，我就回信了。信的内容大概是这样：谢谢你的回复。这是我的项目名字（发了<code>Ahri</code>的GitHub Repo），这是我的 npm 账号（意识到发信的账号不对）。我对<code>Ahri</code>有兴趣，但他是个空的而且被占用了，我没办法使用，对吧？还有这个 B 恶意占用了大量的空包（跟上孤儿账号），他是不是同时违反了规则，是不是应该有所动作？</p><p>第二天（有时差），收到了回信，说包名已经转移到我的账号上：</p><blockquote><p>Thanks for getting back to me with that information.</p><p>It’s all yours now, but you won’t be able to re-use any version numbers used by the previous author. In fact, I’d suggest publishing your first update as a major release, i.e., v1.0.0. Please publish an update to the package as soon as possible with your code.</p></blockquote><p>我上了我的 npm 看了一眼，惊了…这就拿到了…</p><p>但并没有解放其他的空包和 <strong>ban 了他</strong>，这点我有点失望。总之，要到想要的包，这才是想要的结果。</p>]]></content:encoded>
      
      <comments>https://colmugx.github.io/blog/2018/07/12/kill-parentless-on-npm/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
