<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[使用JSX的VUE应用开发体验]]></title>
      <url>/PersonalBlog/2017/12/11/vue-jsx/</url>
      <content type="html"><![CDATA[<blockquote>
<p>我说我是做外包的肯定没人信，给你看看外包程序员瞎几把搞的热情！</p>
</blockquote>
<p>前排提醒：vue-jsx和react-jsx相差甚远，前者基本就是玩具生产链。很多想利用JS语言特性的骚套路基本上都不好实现，而且感觉奇奇怪怪的。所以你的生产环境，千万不要乱试vue-jsx这种搭配，够简单就无所谓了…</p>
<a id="more"></a>
<h2 id="开局搭环境"><a href="#开局搭环境" class="headerlink" title="开局搭环境"></a>开局搭环境</h2><p>要什么环境，<code>vue-cli</code>就行了，又不是什么大项目大团队需要约定<code>webpack</code>。</p>
<h2 id="装插件"><a href="#装插件" class="headerlink" title="装插件"></a>装插件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">npm install\</div><div class="line">  babel-plugin-syntax-jsx\</div><div class="line">  babel-plugin-transform-vue-jsx\</div><div class="line">  babel-helper-vue-jsx-merge-props\</div><div class="line">  babel-preset-env\</div><div class="line">  --save-dev</div></pre></td></tr></table></figure>
<p><code>.babelrc</code>主要是这个</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"plugins"</span>: [<span class="string">"transform-vue-jsx"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为其他的东西基本上都会有，主要是要添加这个东西。至此。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>没错的这文章本来是属于实践的又不是教程。还是要讲一下自己的体验的。</p>
<h3 id="渲染元素"><a href="#渲染元素" class="headerlink" title="渲染元素"></a>渲染元素</h3><p>感想最大的就是这个，Vue在使用jsx的时候很迷，最明显的感觉怪怪的地方有两个：</p>
<ol>
<li>它并不是哪个位置的方法都会有createElement函数的。</li>
<li>classes形式的组件找不到render函数！</li>
</ol>
<p>其实关于vue与jsx，tsx我是做了很多次尝试</p>
<p>首先第一种，常规的就是一个<code>object</code>对象，然后通过<code>Vue.component()</code>方法构建。这种可以说是我现在看来最没坑的一种形式了。平常的话还是像<code>*.vue</code>里的<code>script</code>标签一样，直接<code>export</code>打头开写，<code>&lt;template /&gt;</code>渲染部分移入了<code>render()</code>函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  render(<span class="comment">/* h / createElement */</span>) &#123;</div><div class="line">    <span class="keyword">return</span> &lt;h1&gt; Hello World &lt;/h1&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种情况的结构与单文件的代码结构是相差无几的，不过换了种渲染方式而已，而且<code>render()</code>函数可以做一些与渲染相关的子方法，比如条件渲染之类的。所以总的来说：</p>
<p>优点：</p>
<ol>
<li>顺手，完全单文件中的<code>script</code>标签</li>
<li>没了</li>
</ol>
<p>缺点：</p>
<ol>
<li>这么搞肯定容易眼花啊！</li>
<li>不好维护，不直观</li>
</ol>
<p>第二种，如果是这种结构的tsx的话，与jsx同理。</p>
<p>第三种，class形式的组件，需要<code>vue-class-component</code>插件。然后可以写出类似于这样的东西</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">    &lt;h1&gt;Hello World&lt;/h1&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">  @Component</div><div class="line">  export default class MainClass extends Vue &#123;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>乍一看你还以为这是<code>Angular</code>呢！Vue在这方面真的是取长补短的典范。对这种的话，就比传统的方式要好多了，首先全局变量或者<code>data()</code>函数返回值变得特别清晰；再者是原来<code>methods</code>存放的函数可以以<code>class</code>形式的函数来写，那<code>computeds</code>怎么办？直接用<code>get/set</code>关键词，太方便了有没有！</p>
<p>好了关键的来了…</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</div><div class="line">  </div><div class="line">  get render() &#123;</div><div class="line">    <span class="keyword">return</span> &lt;h1&gt; Hello World &lt;/h1&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// render or template not defind.</span></div></pre></td></tr></table></figure>
<p>这是什么鬼，可能是我操作不当，但是不加<code>get</code>的话不会注入createElement，但是这又是个<code>render()</code>函数，本来不需要加什么前缀的。但是不加有感觉会不会把<code>render()</code>函数识别成是传统写法中存在于<code>methods</code>的函数。</p>
<p>官方在自动注入这方面有一个栗子的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'jsx-example'</span>, &#123;</div><div class="line">  render () &#123; <span class="comment">// h will be injected</span></div><div class="line">    <span class="keyword">return</span> &lt;div id="foo"&gt;bar&lt;/div&gt;</div><div class="line">  &#125;,</div><div class="line">  myMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// h will not be injected</span></div><div class="line">    <span class="keyword">return</span> &lt;div id="foo"&gt;bar&lt;/div&gt;</div><div class="line">  &#125;,</div><div class="line">  someOtherMethod: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// h will not be injected</span></div><div class="line">    <span class="keyword">return</span> &lt;div id="foo"&gt;bar&lt;/div&gt;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">@Component</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</div><div class="line">  get computed () &#123; <span class="comment">// h will be injected</span></div><div class="line">    <span class="keyword">return</span> &lt;div id="foo"&gt;bar&lt;/div&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中<code>h</code>就是<code>createElement</code>的别称，而且在jsx的话一般都是不用写的。所以这个函数注入的就有点迷了，不过根据亲测，在<code>methods</code>定义的函数是有<code>h</code>的，可能最后也会在<code>render</code>函数里调用吧。</p>
<p>后来我尝试两三个星期之后，我就放弃了classes形式的jsx写法，等过几天又有经历的时候再继续尝试。目前自己在用的两套写法：例如<code>Hyper</code>那种的classes形式的vue+ts，传统方式的jsx。</p>
<p>还有就是，对于vue来说，有时候要时常关心<code>h</code>函数有没有被注入，这是一件挺不愉快的事情的。比如说你写了一个渲染函数，然后运行的时候发现惨了凉了函数刚好在渲染范围之外（比如把函数直接分离出去，并不存在于<code>render</code>函数中），这是不运行的，那怎么做？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">h, args</span>) </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>就是这样的！必须在render函数中调用而且<code>h</code>必须是第一个参数！不然不是报错就是不渲染！</p>
<h3 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h3><p>可能是解决刚刚提到的“经常找不到自动注入函数”的困扰吧。多了一个这么个东西。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  functional: <span class="literal">true</span>,</div><div class="line">  </div><div class="line">  render() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个关键词<code>functional</code>声明这个位置是个函数式组件。函数式可以直接看做一个能主动注入<code>h</code>的函数，因为它没有状态的，甚至是个RBQ，用完就丢（死无全尸，在组件树是看不到的，依托父组件生存）。同时最大的特点也就是可复用。想想<code>react</code>一个正常语法函数就能搞定的事情…</p>
<p>有利有弊，这种组件因为没状态，用过就丢，所以它需要的数据全靠传递。也就是单向数据，从父组件 -&gt; props -&gt; 处理 -&gt; 输出 -&gt; 销毁一条龙。很简单就是把它看做是<code>render</code>里面的一个函数就行，本意也是如此。</p>
<p>所以这种组件就两个接收参数：负责渲染的<code>h</code>，负责上下文<code>context</code>。各种所需的乱七八糟都在<code>context</code>中，比如全程最重要的<code>props</code>。而且多数组件的参数都有调整：</p>
<blockquote>
<ul>
<li><code>props</code>：提供 props 的对象</li>
<li><code>children</code>: VNode 子节点的数组</li>
<li><code>slots</code>: slots 对象</li>
<li><code>data</code>：传递给组件的 data 对象</li>
<li><code>parent</code>：对父组件的引用</li>
<li><code>listeners</code>: (2.3.0+) 一个包含了组件上所注册的 <code>v-on</code> 侦听器的对象。这只是一个指向 <code>data.on</code> 的别名。</li>
<li><code>injections</code>: (2.3.0+) 如果使用了 <a href="https://cn.vuejs.org/v2/api/#provide-inject" target="_blank" rel="external"><code>inject</code></a> 选项，则该对象包含了应当被注入的属性。</li>
</ul>
</blockquote>
<h3 id="JSX的一些小区别"><a href="#JSX的一些小区别" class="headerlink" title="JSX的一些小区别"></a>JSX的一些小区别</h3><p>因为我还没怎么体验过<code>react</code>，所以就只有一个关于dom书写的区别。在<code>react-jsx</code>中，<code>class</code>可是会被识别成关键词的，所以做样式的<code>class</code>要写成<code>className</code>，但在<code>vue-jsx</code>是不需要的。可能一开始这么做没想过后面竟然还有<code>class-component</code>的需求吧。</p>
<p><code>vue</code>现在大多奇技淫巧都是基于社区的各种<code>babel</code>插件，并不像<code>react</code>两个官方库皇帝级别支持，也不像<code>angular</code>自从诞生时期就声明“劳资要用TypeScript作为开发语言，你不用也得用ES6形式！”</p>
<p><code>vue-jsx</code>这种写法我现在也会用，搞点小的就直接这么写，而且这么做实际上思路会清晰一点——像在写一个应用而不是写一个网页，你只需要把dom相关的字段脑里想成一个字符串或者一个子函数就行了。（只是老遇到一些乱七八糟的问题）</p>
<p>（<code>angular</code>与<code>angular.js</code>至今还是两种东西，不要乱了）</p>
]]></content>
      
        <categories>
            
            <category> 实践尝试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[扯扯柯里化]]></title>
      <url>/PersonalBlog/2017/12/07/about-currying/</url>
      <content type="html"><![CDATA[<blockquote>
<p>在我的博客打开开发者工具 -&gt; console，输入 Nlvi.tools.scroll 试试？</p>
</blockquote>
<p>开个玩笑，我自己也不知道这算不算柯里化（逃</p>
<p>总之为什么这么写，我自己觉得这样容易理解，方便盲僧（理清）。</p>
<p>还有最近关于“如何治理别人爱装逼的毛病”系列中刚写的一坨，新鲜的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> menuItem = <span class="function">(<span class="params">list</span>) =&gt;</span> </div><div class="line">      list.map(<span class="function">(<span class="params">&#123;title, color, icon, descs&#125;</span>) =&gt;</span> </div><div class="line">        &lt;menu-item title=&#123;title&#125; color=&#123;color&#125; icon=&#123;icon&#125;&gt;&#123;</div><div class="line">          descs.map(<span class="function"><span class="params">v</span> =&gt;</span> &lt;span&gt;&#123;v&#125;&lt;<span class="regexp">/span&gt;)&#125;&lt;/m</span>enu-item&gt;)</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="柯里化是什么？"><a href="#柯里化是什么？" class="headerlink" title="柯里化是什么？"></a>柯里化是什么？</h2><p>好了讲柯里化，就是<strong>接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。柯里化属于函数式编程的内容</strong>。</p>
<p>在这里有一个<a href="http://www.zhangxinxu.com/wordpress/2013/02/js-currying/" target="_blank" rel="external">张鑫旭博客</a>讲关于柯里化（柯南嗑药）的例子，很方便理解。当然我想讲点自己的东西，拿<code>Nlvi.tools.scroll</code>说一下吧</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">tools.scroll = <span class="function"><span class="keyword">function</span> (<span class="params">win</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">    $(win).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> sct = $(win).scrollTop();</div><div class="line">      fn &amp;&amp; fn(sct);</div><div class="line">    &#125;);</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 实际上如果不作的话，这样就结束了</span></div><div class="line">tools.scroll = <span class="function"><span class="keyword">function</span>(<span class="params">win, fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> $(win).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sct = $(win).scrollTop();</div><div class="line">    fn&amp;&amp;fn(sct)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以函数柯里化看上去有一个特点，会嵌套函数。而且道理就跟柯里化的解释一样：用一些参数，剩下的函数作为返回值里的函数的参数。这样我在调用的时候怎么调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scrollTop = Nlvi.tools.scroll(<span class="built_in">window</span>);</div><div class="line">scrollTop(<span class="function"><span class="keyword">function</span>(<span class="params">sct</span>) </span>&#123;&#125;);</div></pre></td></tr></table></figure>
<p>首先我给个变量（实际上ES6直接用<code>const</code>，毕竟固定量）引用这个方法，方法传入第一个参数。接着里面的函数返回值函数是接收一个函数变量。</p>
<p>理一下，函数 - 的返回值 - 是个函数，这个函数接收一个 - 函数 - 的 - 变量。</p>
<p>然后这个函数参数传进去之后，实际上就是传一个方法进去以便于我等下里面的逻辑走完之后可以把这个函数参数运行起来，行程一个特别做作的回调函数。（当然回调函数带的是当前滚动条的数据）</p>
<p>为什么这么做呢？一点就是我觉得这样思路就清晰多了，而且在调用区域写起来干净。第二点就是参数复用。</p>
<p>虽然这个例子看不出什么，但是难免会遇到一些情况，就是明明一个变量或者一个参数，我只要取一次然后调用一次之后，剩下的内容我只要在这个情况之上去处理就行。但是如果传统单函数的做法的话，就会使得这个局外参数也跟着在里面做一些乱七八糟的运动，比如跟着去递归，被扯着去多次判断，这样就会莫名其妙浪费了一堆性能。很简单我举个例子：4x100，明明你交接之后剩下的就接下来的人跑就行了，你非得交接之后跟着跑，边跑边喊加油？</p>
<p>第三点就是延时</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> total = <span class="number">0</span></div><div class="line"><span class="comment">// normal</span></div><div class="line"><span class="keyword">var</span> nSum = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</div><div class="line">  total += num</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//currying</span></div><div class="line"><span class="keyword">var</span> cSum = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">var</span> nums = []</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</div><div class="line">      <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, nums)</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">Array</span>.prototype.push.apply(nums, <span class="built_in">arguments</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sum = cSum(<span class="function">(<span class="params">x</span>) =&gt;</span> total += x)</div></pre></td></tr></table></figure>
<p>如果是常规的话，那么肯定会立刻计算出结果，而柯里化之后，会把计算的步骤储存起来，然后一起计算。</p>
<h2 id="柯里化误区"><a href="#柯里化误区" class="headerlink" title="柯里化误区"></a>柯里化误区</h2><p>在写这篇东西的时候，我关注到了一尊大神的博客 <a href="http://www.cnblogs.com/pengchen/p/5434705.html" target="_blank" rel="external">JavaScript函数柯里化的一些思考</a>，吓得我赶紧回看了自己的函数有没有“画蛇添足”的成分。嗯。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 拿下来继续学习一下</span></div><div class="line"><span class="keyword">var</span> scrollTop = Nlvi.tools.scroll(<span class="built_in">window</span>);</div><div class="line">scrollTop(<span class="function"><span class="keyword">function</span>(<span class="params">sct</span>) </span>&#123;&#125;);</div></pre></td></tr></table></figure>
<p>这里我想到的是，我只需要把<code>window</code>传到这个函数之后引用出一个新函数，然后我就可以带着这个函数跑了，如果是不嫌麻烦版本的话我需要则么做？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">tools.scroll = <span class="function"><span class="keyword">function</span>(<span class="params">win, fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> $(win).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sct = $(win).scrollTop();</div><div class="line">    fn&amp;&amp;fn(sct)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">// and so</span></div><div class="line">tools.scroll(<span class="built_in">window</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)</div></pre></td></tr></table></figure>
<p>这样就会造成，我每次想监听滚动的时候，每用一次这个方法，我就要把<code>window</code>传进去一次。如果包一下的话，我就可以拿后面那个函数走就行了，也就是我的<code>window</code>只要传一次就畅通无阻。这也是另一个好处：分段计算。好比我玩Switch，我在外面突然想玩马车的时候，如果我的卡带在卡包里，那我换上就可以玩了，就不需要等回到家把卡带从包装盒里拿出来装到机器上。</p>
<p>实际上到这里的话应该有所经验了，到这里还会不会觉得<code>apply(), call(), bind()</code>使用机会少之又少？这就是数学的魅力吧，可是我数学不好。</p>
<h2 id="柯里化-lt-gt-闭包函数？"><a href="#柯里化-lt-gt-闭包函数？" class="headerlink" title="柯里化 &lt; - &gt; 闭包函数？"></a>柯里化 &lt; - &gt; 闭包函数？</h2><p>又是每期一问了，柯里化跟闭包函数是否也有关系？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 经典面试题</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</div><div class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</div><div class="line">             setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">              <span class="built_in">console</span>.log(i);</div><div class="line">        &#125;,<span class="number">0</span>)</div><div class="line">    &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么，柯里化函数和闭包函数应该怎么区分？还是的确有联系？</p>
<p>最后感谢所有被引用的文章及其作者，感谢帮助学习。</p>
]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[你还在用Console.log()？]]></title>
      <url>/PersonalBlog/2017/11/20/js-console/</url>
      <content type="html"><![CDATA[<blockquote>
<p>也许主题应该改为：你只会使用Console.log()？</p>
</blockquote>
<p>现在的前端虽说是越来越复杂，但是我怎么觉得现在前端的要求越来越低了？应该说现在的人，看个几遍vue，知道console.log()，知道var, {}, []，就敢出来找工作了。但是<code>console</code>就这么个方法？</p>
<p>搞笑，你在你的浏览器输入<code>console</code>，自己看看有多少东西！所以为了高效调试我觉得有必要全了解一遍。<br><a id="more"></a></p>
<h2 id="log-info-error-warn"><a href="#log-info-error-warn" class="headerlink" title="log(), info(), error(), warn()"></a>log(), info(), error(), warn()</h2><p>这几个放在一起讲</p>
<blockquote>
<p>log() 普通输出</p>
</blockquote>
<p>这是最普通，最常见，最没什么东西好讲的。输出的样式是普通样式。</p>
<blockquote>
<p>info() 提醒输出</p>
</blockquote>
<p>这是一个早期chrome才能看到的效果，现在的FireFox也能看到，是一个圆形中间一个叹号的标记。作提醒作用。chrome不是不会显示，是显示成普通样式。</p>
<blockquote>
<p>error() 错误输出</p>
</blockquote>
<p>这个应该跟<code>log()</code>同个使用数量级的，表示错误，大红颜色。chrome表现是一整行都是红色的，很显眼。用来显示错误信息。比如throw 错误之类的。如果一套都是<code>log()</code>的话肯定很难一眼看到错误。珍爱视力，路还长着…</p>
<blockquote>
<p>warn() 警告输出</p>
</blockquote>
<p>就是警告咯，可能用的比较少，但是工具类和一些库肯定会容易看到，原来跟<code>info()</code>平起平坐，现在应该是替代了。显示效果会显眼的黄色，chrome会有黄色背景。</p>
<blockquote>
<p>debug() 调试输出</p>
</blockquote>
<p>这个就是<code>log()</code>，用来输出调试信息的。不过现在的调试信息都在花式<code>log()</code>，也不需要用到这个了。</p>
<h2 id="exception-debug"><a href="#exception-debug" class="headerlink" title="_exception(), debug()"></a>_exception(), debug()</h2><p>这组只有两个，因为这两个没卵用…为什么…</p>
<blockquote>
<p>_exception() 例外输出</p>
</blockquote>
<p>说白了就是用来输出错误的，那错误不能用<code>error()</code>吗？！</p>
<blockquote>
<p>debug() 调试输出</p>
</blockquote>
<p>早期可能还有区别，但是这就是一个<code>log()</code>，不过现在各前端都在花式<code>log()</code>调试信息，可能也有些人<code>debug()</code>都没听说过。</p>
<h2 id="assert-…-clear-count"><a href="#assert-…-clear-count" class="headerlink" title="assert(…), clear(), count()"></a>assert(…), clear(), count()</h2><p>为什么第一个函数搞了三个点？</p>
<blockquote>
<p>assert() 断言输出：判断第一个参数是否为真，false的话抛出异常并且在控制台输出相应信息。——MDN</p>
</blockquote>
<p>从这里开始就要骚了，这是一个判断的方法，里面需要填写参数，然后得到返回值。如果值为真，就什么都不会发生，反之则以<code>error()</code>通知你。这是个多参数的，除了第一个参数之外，后面接的参数是被输出的对象也好，字符串也好，并且会拼接。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.assert(<span class="number">1</span>&gt;<span class="number">2</span>, <span class="string">"你这么骚的？"</span>)</div><div class="line"></div><div class="line">Assertion failed: 你这么骚的？ <span class="comment">// 假装这里是红字红色背景</span></div></pre></td></tr></table></figure>
<blockquote>
<p>clear() 清空控制台</p>
</blockquote>
<p>就是把控制台全清空，terminal里面的<code>clear</code></p>
<blockquote>
<p>count() 次数输出：以参数为标识记录调用的次数，调用时在控制台打印标识以及调用次数。——MDN</p>
</blockquote>
<p>并且MDN明确指出，这个不应该列入正常使用范围，因为这是非标准方法。这是这组里最骚的方法。用来输出本身被调用了几次…虽然如果测试循环的话，一般都直接log(i)的，直接看1234567不是更明确嘛。显示效果就是，每运行一次就会在控制台打印 n + 1。</p>
<h2 id="dir-dirxml"><a href="#dir-dirxml" class="headerlink" title="dir(), dirxml()"></a>dir(), dirxml()</h2><p>这两个一起说是因为，有相同点和不同点。</p>
<blockquote>
<p>dir() 对象结构输出</p>
<p>dirxml() 节点结构输出</p>
</blockquote>
<p>这两个都是输出一个树状结构，就是前面有个小三角。但不同点就是，<code>dir()</code>是把一个对象按照对象的形式呈现，当然用来输出节点就是把节点信息按object呈现。<code>dirxml()</code>是把节点呈现出来，就还是保留xml的样式呈现。都是非标准，偶尔用用还行？</p>
<h2 id="group-groupCollapsed-groupEnd"><a href="#group-groupCollapsed-groupEnd" class="headerlink" title="group(), groupCollapsed(), groupEnd()"></a>group(), groupCollapsed(), groupEnd()</h2><p>这是上面那组的正房版。都是打印结构。我就不一行一行解释了有点累…</p>
<p>第二跟第一都是打印树状结构，但是第一个会自动打开显示结构里面有什么结构（没问题的），第二个叫内联树状，默认不打开。</p>
<p>而且只要你不结束，你可以一直联下去的，这样一个父节点可以一直续下去…直到通过<code>groupend()</code>来结束。</p>
<h2 id="table-…"><a href="#table-…" class="headerlink" title="table(…)"></a>table(…)</h2><p>我必须强调！<strong>这是最棒的我最喜欢的console方法，没有之一！</strong></p>
<blockquote>
<p>table() 表格输出</p>
</blockquote>
<p>这个方法必须传入内容，内容的类型是array或者object，输出的样式是一个key:value的表格！如果你觉得输出成对象不方便检查的话，那就用<code>table()</code>吧！（当然在表格下方还是会return一次对象或者数组）</p>
<p>而且不仅是key:value，<strong>你甚至还能多元数组！对象套对象！甚至是JSON！</strong></p>
<h2 id="另外的技巧就是可以用占位符了"><a href="#另外的技巧就是可以用占位符了" class="headerlink" title="另外的技巧就是可以用占位符了"></a>另外的技巧就是可以用占位符了</h2><p>跟C语言的<code>printf()</code>没有区别，就是可以利用占位符然后再把参数接在后面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"%d年%d月%d日"</span>,<span class="number">2017</span>,<span class="number">11</span>,<span class="number">20</span>)</div></pre></td></tr></table></figure>
<p>最后感谢MDN，也感谢AlphaGo！</p>
]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[引用等于指针吗？]]></title>
      <url>/PersonalBlog/2017/10/17/reference-equal-pointer/</url>
      <content type="html"><![CDATA[<blockquote>
<p>一篇思考文，关于JS的reference和Go的指针。（臆想型论文？）</p>
</blockquote>
<p>最近投入大量时间接触<code>Golang</code>，了解“指针”的时候，想起了以前学习C语言时对“指针”的疑问：指针是什么。</p>
<p>以前还小不理解指针和野指针，只知道野指针会出现内存溢出或者值不正确的情况。而且网上大多讲指针的文章看起来都很难。就像现在的知乎：一句话能说清楚的东西恨不得从它的诞生还是写起。就连LOL赛评也是这副P样。</p>
<p>以至于我后面对C语言没好感，对C++厌恶，对有“指针”的语言直接没兴趣。</p>
<p>在看到Go的指针的时候，我已经想放弃了。但是想回来，毕竟上一次接触指针已经6年了，也许现在看就能理解出什么呢。（过程中接触的OC根本不能算经验，因为当时完全就是靠抄靠背来写iOS应用，最后还是嫌弃OC麻烦进阶无法理解去学习了swift）<br><a id="more"></a></p>
<h2 id="Reference-Pointer"><a href="#Reference-Pointer" class="headerlink" title="Reference == Pointer?"></a>Reference == Pointer?</h2><p>以前看到什么内存地址啊，指向啊就已经乱了，满脑子都在想内存里面是什么样的，内存地址，寄存器又是什么东西。跟着官方教程走了一遍，了解到<strong>指针就是通过一个变量去指向一个有的变量或者说是对象，从而产生一种绑定。通过修改指针变量也可以达到修改本体的效果</strong>。</p>
<p>这让我想到JS，因为每天都在操作对象，知道：如果你要建立一个新的变量，比如<code>a = 1</code>，我可以通过<code>var b = a</code>得到一个新的变量。但是如果是对象则不是。如果是<code>a = {};  var b = a</code>的话，b只是单纯指向了a，并没有复制a</p>
<p>所以我立刻去搜索<em>关于JavaScript的指针</em>。得到这么一个结果 <a href="https://www.baidu.com/link?url=2Xxo3-ptdvabLARr0p-DcoBbeysd2lvRxH-jEevvWHBJ7pNBk-mkxGqaB6h8UTWVRi-2lc56zjWVMYPUgv6tfK&amp;wd=&amp;eqid=e1820c9600002f360000000659e5b92d" target="_blank" rel="external">JavaScript 的<em>指针</em>是什么? - 知乎</a></p>
<blockquote>
<p>JavaScript 里头什么时候有指针的概念？倒是有 reference （引用）的说法。 —— <a href="https://www.zhihu.com/people/sansmana" target="_blank" rel="external">陈木野</a></p>
</blockquote>
<p>关于this的总结，不单我自己，网络上已经大量的文章了。不管是详细解析，还是总结，都已经很多了。但是如果说：指针就是一种指向变量的话，那JavaScript就很多了，遍地都是。而这样的话，就跟reference有关系了。</p>
<p>说起来也是邪门了，今天打算把《红宝书》拿出来翻一下，翻到了第四章4.1.2，看到了这么一句</p>
<blockquote>
<p>当使用 num1 的值来初始化 num2 时，num2 中也保存了值 5。但 num2<br>中的 5 与 num1 中的 5 是完全独立的，该值只是 num1 中 5 的一个副本。</p>
<p>当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到<br>为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一<br>个对象。复制操作结束后，两个变量实际上将引用同一个对象。</p>
</blockquote>
<p>于是我的想法 “引用是一种指针” 或许成立。（复习有好处的！）</p>
<h2 id="Point-Reference"><a href="#Point-Reference" class="headerlink" title="Point == Reference"></a>Point == Reference</h2><p>如果反过来，还能成立吗？我觉得不行。</p>
<p>C++，让我很崇拜很信仰的，却因不理解和学不会让我产生厌恶的语言，在这方面是两者皆有。由于根本不懂所以不参加讨论。</p>
<p>Java，他也有reference，但是在<a href="https://www.baidu.com/link?url=bI4EsfOKw8lfPjTwX3_gY7pbn2LFMOwmFPmoalBBNr7lFCv9ZltHfuravfoA7uVHrNJtSUxm0Epjk-IW5Zr2z_&amp;wd=&amp;eqid=ee91ddc5000508bd0000000659e60253" target="_blank" rel="external">Java的<em>Reference</em>感觉很象C++的<em>指针</em>,但是区别是本质的 - f…_博客园</a> 提到：</p>
<blockquote>
<p>Java中你无法对这个地址进行任何数学运算，并且这个地址你不知道，是Java Runtime分配给你的，它随时还要调整这个地址（After GC,Memory要Compact，这时候一个Object Reference的地址就会改变）。</p>
</blockquote>
<p>我不是很理解，所以我也不敢评论什么。我只想关于Go和JS的东西。</p>
<p>也许是心理隔阂，也许是真理。我怎么都想不出怎么让“指针是一种引用”成立。</p>
<p>老是想内存内存，不如想成一个盒子，指针就是给盒子里的东西连了一条线。这样做就不用我找这个东西的时候去盒子里找，而是直接去找这条线？</p>
<p>可是在JS中，引用也不能修改和做任何运算吗？</p>
<h2 id="Reference-Pointer-1"><a href="#Reference-Pointer-1" class="headerlink" title="Reference === Pointer?"></a>Reference === Pointer?</h2><p>我不是语言专家，我一点都不敢保证。或者说我不懂。</p>
<p>我不知道所谓的指针是什么东西，但是我知道<code>reference</code>是一个<code>object</code>，毕竟不知道哪篇文章写道：函数是JavaScript第一公民。但并不是很纯的函数式编程语言。</p>
<p>其实思考到现在，我又有新的问题了：<strong>前端语言，或者说函数式编程语言，有没有内存，指针一说？</strong></p>
<p>不过现在可以知道的是：</p>
<p>​    在指令式编程中，数值就是数值，一切工作之后无非就是想得到一个值，过程中也在围绕着值。</p>
<p>​    在函数式编程中，函数还是占主要地位，它需要以数学的方式去解决编程的问题。</p>
<p>那我现在可不可以有一种新的理解：</p>
<p>​    比如C语言这种，他定义指针是需要 <code>*</code> 这种东西，也就是<code>int *a = b</code>是用a指针指向b，我可以通过a来修改b。但是如果直接<code>int a = b</code>的话，我就相当于复制了这个变量了，没权修改b变量了。而如果<code>int a</code>是一个函数的话，那它最后也需要返回一个<code>int</code>返回值。所以它并没有“用函数搞事”的权利。</p>
<p>​    而JS语言这种，我想用一个代码框来写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 还是根据红宝书的例子</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b = a;	<span class="comment">// 一种复制，相互独立</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> x = &#123;<span class="attr">a</span>: <span class="number">5</span>&#125;</div><div class="line"><span class="keyword">var</span> y = x	<span class="comment">// 一种引用，实际上操作y的时候还是在操作x</span></div><div class="line"></div><div class="line"><span class="comment">//现在暂时借用一下以 _ 代替*</span></div><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">5</span> &#125;</div><div class="line"><span class="keyword">var</span> _b = o.a	<span class="comment">// 达到继承的目的？</span></div><div class="line"></div><div class="line"><span class="comment">// var _b = int *b   在某种意义上？</span></div></pre></td></tr></table></figure>
<p>在红宝书接下来有一句：</p>
<blockquote>
<p>换句话说，obj1和 obj2 都指向同一个对象。这样，当为 obj1 添加 name 属性后，可以通过 obj2 来访问这个属性，<br>因为这两个变量引用的都是同一个对象。</p>
</blockquote>
<p>按我的角度翻译一下，就是：<strong>我定义一个b出来，无非就是给a多了一个出口</strong></p>
<p>所以综上所述，我认为，对我来说，或者对C系除外的语言来说，<strong>把“指针”说成“指向”，或许让人更好理解。</strong></p>
<p>哼，计算机真是有趣。</p>
<p>（最后感谢所有被引用的文章和作者，谢谢。）</p>
]]></content>
      
        <categories>
            
            <category> 编程议论 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[总有一天我会死在骚操作上…]]></title>
      <url>/PersonalBlog/2017/10/09/diary-vue-jsx/</url>
      <content type="html"><![CDATA[<p>得考虑去弄个图床，滥用github不太好。</p>
<p><img src="https://github.com/ColMugX/GitBed/raw/master/diary/vue-render1.png" alt=""></p>
<p><img src="https://github.com/ColMugX/GitBed/raw/master/diary/vue-render2.png" alt=""></p>
<p><img src="https://github.com/ColMugX/GitBed/raw/master/diary/vue-render3.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 毫无意义 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用桌面应用写hexo博客是什么体验？]]></title>
      <url>/PersonalBlog/2017/09/19/what-the-feeling-about-hyper/</url>
      <content type="html"><![CDATA[<blockquote>
<p>稳的稳的，这次真是为了需求造轮子了。Hyper = Hexo + Typer. </p>
</blockquote>
<p>接触到hexo是因为，hexo可以是一个前端博客生成器，直接生成一个前端静态页面，做到可以上传到github“个人页面”作为博客网站。</p>
<p>不过，毕竟是基于<code>node</code>的生成器，编写过程很geek。首先创建和预览甚至发布，依赖<code>terminal</code>和<code>node</code>。你要使用一个你喜欢的<code>markdown</code>编辑器，或者直接就在代码编辑器搞例如<code>vscode</code>。原来我也是用这个写博客。因为自带了<code>terminal</code>，直接创建了搞完直接上。后来生活逐渐好点，用的 iterm2 + zsh 之后，编辑器改用了<code>Typora</code>。然而关于这段的话，我上一篇<a href="http://blog.co1mugx.tk/2017/08/22/do-markdown-hexo/" target="_blank" rel="external">搞electron+vue+webpack2+TypeScript什么体验</a> 已经讲得够多了，所以不赘述了。</p>
<p>但是现在，可能生活会更好了…</p>
<p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/1.png" alt=""></p>
<a id="more"></a>
<h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><p>这是个<code>electron</code> + <code>Typescript</code> + <code>vue</code>的产物。也就是首先它是桌面应用了，由于<code>electron</code>意味着它可能可以跨平台。不过我没有想过…所以现在是 MacOS 版本。</p>
<p>为什么想起写这个，原因就两点</p>
<ul>
<li>原来的方式太过于繁琐，甚至感觉不到自己是在写博客。</li>
<li>对计算机理解和操作都不是顺畅的人会带来很多麻烦。</li>
</ul>
<p>博客博客，文字记录自己的生活或者技术探讨。多少写手或者说喜欢分享的人，喜欢hexo又不会用没办法用。当分享被技术限制之后，那么写文章也就不是专注于文章了。（比如我写文章也一直很跳，跟性格有关吧）</p>
<p>所以我才想要实现这么个东西，实际上在早之前就已经打算了，当时前端太菜。也不知道<code>electron</code>是什么东西。还是个<code>swift</code>新教徒的时候。有想过用MacOS 原生的方式去做这个东西，后来放弃了，原因还是因为技术上的问题。</p>
<p>这次实现这个东西的时候，巧了，跟<a href="http://www.ahonn.me" target="_blank" rel="external">@Ahonn</a>几乎不约而同的想到了一起。他也说他很早就想做了，不过大神不是因为技术原因，而是开坑不填工期延后…</p>
<p>不过他的实现方式是不同的，他想使用<code>cljs</code>去实现这个东西。我为了求稳，还有还是熟悉一下<code>TypeScript</code>作为脚本使用的感觉，用了这么套技术栈。</p>
<p>Ahonn的项目地址是这个：<a href="https://github.com/ahonn/hexdit" target="_blank" rel="external">ahonn / hexdit</a>。利益相关的话：还是算关系挺好的校友吧…</p>
<h2 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h2><p>不搞事情，不吹牛逼，这次为了 <del>装逼</del> 测试一下软件大概“正常使用”有没有什么问题。所以这次我这篇文章完完全全使用<code>Hyper</code>创建、编写、保存、修改，甚至我等下生成发布也直接用这个。</p>
<p>确实，这才像在写博客。</p>
<p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/2.png" alt=""></p>
<p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/7.png" alt=""></p>
<p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/9.png" alt=""></p>
<p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/10.png" alt=""></p>
<p>我甚至都不怕被你看！</p>
<p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/5.png" alt=""></p>
<p>（因为编辑器的样式还有预览的样式还没上，所以现在看起来还是很丑的，不过测试功能嘛，我等下还会用其他编辑器看）</p>
<p>但不管怎么说！就是好看！<strong>简就是美！甚至还有点少女心！</strong></p>
<p>在首屏直接载入<strong>整个博客程序文件夹</strong>之后，就会到达这个界面，左边是显示你当前博客程序里面的文章（名字我都不怕给你看，这名字最后会显示到网址上！），文章列表上面三个按钮分别是 “创建”，“预览”，“生成/发布”。每一个文章名称前面一个“绿色的勾”是提醒你，当前这篇文章是可见的。没错文章可以是隐藏的，这在<code>hexo</code>的文档上有提到，<code>source</code>文件夹中不会上传文件名前带’_’的文件。所以自然可以过滤“草稿”和“不想发布”的文章。所以隐藏的文章会显示一个红色的叉。</p>
<p>点击想编辑的文章之后，其实会有动画回馈，但是不会常驻高亮。然后右边会跳出目前文章的内容以及一些编辑文章会用到的功能。实际上我应该做一个当前编辑文件高亮的！</p>
<p>右边编辑区中第一个“笔样子”的图标我是放着玩的…一些测试的工作会挂在上面当starter。然后保存和删除这个应该能看懂。右边有个开关，这个开关就是作为<strong>“选择当前文章是否隐藏”</strong>的作用。当然如果是<code>off</code>状态的话就是显示了，默认也是显示的。最右边的“X”就是关闭当前编辑区咯。</p>
<p>下面一整个编辑区，写文章可以用，不过<code>markdown</code>了，应该熟悉的是不会用到的吧，可能会用到两个功能：一个是全屏编辑，一个是分屏编辑。噢插入表格也可以有，<code>markdown</code>的表格真是蛋疼。</p>
<h3 id="另外还给对hexo不熟悉的写手准备了一个大功能。"><a href="#另外还给对hexo不熟悉的写手准备了一个大功能。" class="headerlink" title="另外还给对hexo不熟悉的写手准备了一个大功能。"></a>另外还给对hexo不熟悉的写手准备了一个大功能。</h3><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/3.png" alt=""></p>
<p>那就是简易设置了！漂不漂亮我不敢说！反正我就喜欢清静的感觉，看看<code>Nlvi</code>！是不是还有一股禅意！</p>
<p>截图的信息是我在做测试的时候，我当前导入的是当时用来测试主题功能的一个示例博客，官方提供的。毕竟不敢把自己的博客导入进去，万一弄瞎了不就真瞎了…</p>
<p>就我遇到的很多情况看，还是会有刚接触前端或者刚接触hexo的人不知道hexo的配置文件应该是怎么弄的。虽然我在<a href="https://github.com/ColMugX/hexo-theme-Nlvi" target="_blank" rel="external">hexo-theme-Nlvi</a>里面写到：如果主题有使用问题的话，你可以提ISSUE，或者直接到知乎上锤我！</p>
<p>但事实上，很多给我知乎发私信的同学，问的都基本不是主题使用的问题，反而是博客本身的使用问题。所以我重新整理了博客配置文件，并把一些比较重要的，必须要的功能作为一张设置界面出来，这样就方便使用了。只要这张填的满，按道理说博客的显示和发布就没问题了。</p>
<p>而且这张设置界面就这么多内容，在地址设置下面也就多了一个“文章代码是否高亮”和“部署地址”。这样而已。然后就可以保存完事。</p>
<p>由于还是在测试和进一步编写。所以一些难看的目前用不到的我都<code>display:none</code>了，所以看不到完整设置。</p>
<p>初来乍到，第一次写这种软件，还是有很多问题的。如果你看到问题了还希望你能帮我指正。我也是想服务一下社区，给喜欢但是不会用的人一点帮助。</p>
<h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>其实介绍文章按正常来说到上面就结束了。这也是为什么 “是什么 -&gt; 为什么 -&gt; 怎么做”反而是这种顺序。</p>
<p>关于是什么，应该很多人都不愿意去关心了，这里是我想记录的一些心得和学习遇到的坑。</p>
]]></content>
      
        <categories>
            
            <category> 实践尝试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> electron </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搞electron + vue + webpack2 + TypeScript什么体验]]></title>
      <url>/PersonalBlog/2017/08/22/do-markdown-hexo/</url>
      <content type="html"><![CDATA[<p>本来是想放弃的，后来歪打正着，成功运行。最后搞一个ts类型的启动器，不想再懵了。</p>
<p><a href="https://github.com/ColMugX/vue-ts-electron-starter" target="_blank" rel="external">vue-ts-electron-starter</a></p>
<p>想看看原项目<code>electron-vue</code>有没有这个打算，没有的话自己fork个分支出来。这个将就。</p>
<p>这次搞这个项目目的就很明显了，想做一个Hexo博客的编辑器（没错就是我这个博客的核心）。Hexo的话，属于页面生成器类的博客系统。直接一套生成静态页面，然后随意访问。因为一整套静态页面故还是有人喜欢直接干一套SPA上去，体验也好。</p>
<p>其实搞这个，我去年就想搞了。可是去年的话，明显前端的技术都不扎实更别说搞了，当时的想法是写一个Mac App（我swift应该还行，随便写写问题不大。不过可能现在的话问题就大了）。不过就一直拖拖拖，导致swift3.0都有苗头了我还是没想写。而且关于如何操作terminal命令，还是个问题。</p>
<p>这次心就大了。搞了再说，搞一半不行了就让他荒了。以后想起来再搞，再搞的时候技术肯定又上涨。如果这波做成了，开源，我不管有没有人用，总有人喜欢用。<br><a id="more"></a></p>
<h2 id="讲在前面"><a href="#讲在前面" class="headerlink" title="讲在前面"></a>讲在前面</h2><p>在这之前我用的是<a href="https://github.com/CodeFalling/blog-admin" target="_blank" rel="external">CodeFalling / blog-admin</a>。这是一个Emacs的插件，当然spacemacs也能弄来用一下。这是一个在github很活跃的大神写的（我经常看到，同时也是hexojs成员），也是很出名的Emacs教徒。不过据说他现在用的是webstorm + vim插件了…</p>
<p>当然今天不想吹Emacs，而且工作上我也不敢用Emacs，原因不说。</p>
<p>其实就是一直想做一个方便用一点的。在emacs之前我都是开一个terminal+一个编辑器来做的。在emacs之前是用<code>typora</code>和<code>vscode</code>做的。总这样不好吧太麻烦了。而且这东西又算刚需…所以算了，还是尝试一下吧，顺便把<code>electron</code>和<code>vuex</code>给学清楚了，而且顺便练一下<code>TypeScript</code>。</p>
<p>所以这次打算的技术选型是：</p>
<ul>
<li>TypeScript</li>
<li>electron</li>
<li>vue</li>
<li>vuex</li>
</ul>
<p>electron + vue环境的话，直接使用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="external">SimulatedGREG/<em>electron-vue</em></a>，这样<code>electron</code>，<code>vue</code>，<code>webpack</code>就都完成了。如果针对<code>TypeScript</code>的话<code>webpack</code>应该要小改一下。</p>
<h2 id="为什么使用TypeScript"><a href="#为什么使用TypeScript" class="headerlink" title="为什么使用TypeScript"></a>为什么使用TypeScript</h2><p>TypeScript是微软开发的语言，由于师出同门所以跟<code>C#</code>的语法是极其像的，不过由于是<code>JavaScript</code>的超类，所以还会考虑到ES的语法。所以很早的时候<code>ES6</code>还没流行起来的时候，<code>TypeScript</code>已经开始使用像ES6一样的语法，并提供编译把TS的代码编译成ES5的代码，在没有<code>es6</code>和<code>babel</code>的世界，需要用JS来创造更强大的程序无疑是福音。</p>
<p>一开始看到的时候，我觉得JS也就那样了，还能怎样…到后来去接触的原因，是因为它的语法跟我先接触的<code>swift</code>很像，我觉得可能能通过TS学好swift或者说通过对swift的理解去学TS，反正都能编译成JS的嘛。</p>
<p>再后来就遇到了游戏，接触Unity3D的时候，最热门最成熟的语言是C#，而我当时是个软黑。转而让我发现了Egret，Egret竟然把TS作为开发语言，我就想要不把TS也弄清楚了，以后如果接触C#可能也不会太难。可是经过几轮跌爬滚打之后，我竟然放弃了…对这就是我小时候的不懂事…大学快毕业的时候几乎每天就在后悔，为什么当时不好好学TS，而在ES6789流行开的时代里，语法完整功能完善的TS优势也没有那么大了。现在浏览器都能直接用ES7了…</p>
<p>但是现在说没优势都是骗人的…如果你只是单纯用JS写的话，一如果出现类型错误，不好控制。二在万物都是函数的世界中，可能如果要实现一些其他功能，可能会考虑不周。即使能考虑到了，写上去。也会造成很大的工作量。但是TS编译器都替我们想好和做好了，为什么不去用？</p>
<p>所以，如果是应用开发的话，为什么不考虑应用级别的开发语言呢？我是这么想的。</p>
<p>如果是web，但是要强大的框架比如vue，reactjs，我会选择用JS。如果是需要更强大的能力和稳定、可控的app，我肯定是选择TS。</p>
<h2 id="干！填坑！"><a href="#干！填坑！" class="headerlink" title="干！填坑！"></a>干！填坑！</h2><p>两点核心</p>
<ul>
<li><code>webpack</code>需要配置对<code>TypeScript</code>的编译。</li>
<li>从入口到组件都使用<code>TypeScript</code></li>
</ul>
<p>因为我也是误打误撞突然可以正常运行，所以我是开一个新的项目进行接下来的工作。 （结果发现并不是误打误撞，而是本来就是正确的，那么为什么会错误…）</p>
<p>首先npm安装<code>typescript</code>, <code>ts-loader</code>, <code>vue-class-component</code>，这三个都很重要。<code>typescript</code>提供的是语言支持，也可以说是提供内部编译，当然如果说你本身就全局装过了，那么你直接<code>link</code>就行了</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">npm i -S typescript ts-loader vue-class-component</div><div class="line"></div><div class="line"><span class="comment"># or</span></div><div class="line">npm i -S ts-loader vue-class-component</div><div class="line">npm link typescript</div></pre></td></tr></table></figure>
<p>然后是<code>webpack.renderer.config.js</code>，不出意外的话在<code>25:3</code>入口，<code>26:58</code>把<code>js</code>改成<code>ts</code>，下面的rule添加对ts的支持</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	test: <span class="regexp">/\.ts$/</span>,</div><div class="line">	loader: <span class="string">'ts-loader'</span>,</div><div class="line">	exclude: <span class="regexp">/node_modules|vue\/src/</span>,</div><div class="line"> 	options: &#123;</div><div class="line">		appendTsSuffixTo: [<span class="regexp">/\.vue$/</span>]</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果有需要<code>tslint</code>的话（说实话我还不会用…而且我觉得ts约束本来就很厉害了），需要安装</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i -S tslint tslint-loader</div></pre></td></tr></table></figure>
<p>老位置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	test: <span class="regexp">/\.(ts)$/</span>,</div><div class="line">	enforce: <span class="string">'pre'</span>,</div><div class="line">	exclude: <span class="regexp">/node_modules/</span>,</div><div class="line">	use: &#123;</div><div class="line">		loader: <span class="string">'tslint-loader'</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二，就是把关于<code>vue</code>部分的入口改成<code>main.ts</code>。这样接近完成。</p>
<p>第三，最重要的，<code>typescript</code>能不能用就靠这个了，<code>jsconfig.json</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tsc --init	<span class="comment">#通过tsc初始化得到</span></div></pre></td></tr></table></figure>
<p>至于怎么配置，<code>vue</code>官方也给了一个推荐配置，<code>vue-class-component</code>也给了一个。</p>
<p>但不管怎样，建议把<code>allowjs</code>打开了，可以调用<code>js</code>文件。</p>
<h3 id="开始填坑"><a href="#开始填坑" class="headerlink" title="开始填坑"></a>开始填坑</h3><ul>
<li>入口必须是<code>.ts</code></li>
</ul>
<p>这点说起来很坑，TS的话，只要有<code>allowjs</code>就可以调用JS文件，运行是没问题的。但是反过来就不行了，毕竟超类能认，但JS根本不知道TS是个什么鬼，所以无法编译</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Module build failed: Error: Could not find file: <span class="string">'...*.ts'</span> </div><div class="line"></div><div class="line"><span class="comment"># 或者</span></div><div class="line">Module build failed: Error: Could not find file: <span class="string">'...*.vue'</span></div></pre></td></tr></table></figure>
<p>所以必须是TS入口</p>
<ul>
<li>建议关于<code>script</code>部分分开写。</li>
</ul>
<p>当然是可以直接在<code>.vue</code>写你的逻辑的，不过为了防止<code>typescript</code>有小脾气，或者关于类型推断，总的来说就是为了编译少点麻烦吧，我觉得还是分开写是最保险的。当然在组件内写也不是不可以。</p>
<ul>
<li><code>vue-class-component</code>核心</li>
</ul>
<p>如果用了TS的话，那么漂亮的组件代码肯定就是<code>class</code>了，通过修饰<code>@component</code>声明该位置是一个组件，然后开始写组件代码，继承自<code>vue</code>，然后就可以像写一个程序类一样去写这部分组件。看起来是相当漂亮的。举个例子，在通过<code>electron-vue</code>创建出来的工程中，对实例组件<code>LandingPage.vue</code>进行改写</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">  name: <span class="string">'landing-page'</span>,</div><div class="line">  components: &#123;</div><div class="line">    SystemInformation</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> LandingPage <span class="keyword">extends</span> Vue &#123;</div><div class="line">  open (link) &#123;</div><div class="line">    (<span class="keyword">this</span> <span class="keyword">as</span> <span class="built_in">any</span>).$electron.shell.openExternal(link)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>漂亮，清晰。（当然复杂一点，就复杂了！）</p>
<ul>
<li>关于对Vue进行扩展</li>
</ul>
<p>在添加<code>axios</code>的时候我遇到了问题：无法扩展<code>Vue</code>，原因好像是无法推断<code>vue</code> 的类型。这个问题的话，我还得去研究一下。</p>
]]></content>
      
        <categories>
            
            <category> 实践尝试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
            <tag> electron </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript的call()，bind()，apply()]]></title>
      <url>/PersonalBlog/2017/08/14/js-call-apply-bind/</url>
      <content type="html"><![CDATA[<blockquote>
<p>联动水文，大约半年前记录了Javascript的this。顺水推舟理一下call()，bind()，apply()</p>
</blockquote>
<p>扩展阅读：<a href="https://colmugx.github.io/PersonalBlog/2017/03/03/js-this/">关于JavaScript的this</a></p>
<p>还是上次的代码，修改一下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> test = obj.getName</div><div class="line">test()					<span class="comment">//undefined.</span></div></pre></td></tr></table></figure>
<p>（敲黑板！）复习一下！为什么就<code>undefined</code>了！原因就是，<code>this</code>指向不同了。那么直接运行是否可以</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">obj.getName()		<span class="comment">//koala</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>因为有时候并没办法这么自由的随便调用，那如果要搞个变量出来用，怎么做？</p>
<h2 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h2><blockquote>
<p><strong>call</strong></p>
<ul>
<li>vi. 呼叫；拜访；叫牌</li>
<li>vt. 呼叫；称呼；召集</li>
<li>n. 电话；呼叫；要求；访问</li>
<li>n. (Call)人名；(瑞典、罗)卡尔；(英)考尔<br>以上来自有道翻译</li>
</ul>
</blockquote>
<p>有一手有道翻译就方便了，就是call（叫）它，把要用的方法call（叫）出来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> cal = obj.getName	<span class="comment">//先定义出来</span></div><div class="line">cal.call(obj)		<span class="comment">//koala   （指向还给他，不动其他把它叫出来</span></div></pre></td></tr></table></figure>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h2><blockquote>
<p><strong>apply</strong></p>
<ul>
<li>v.应用；使用；涂；敷</li>
<li>Web申请；适用；套用<br>以上来自bing词典，感谢微软爸爸</li>
</ul>
</blockquote>
<p>再来一手必应翻译简直就是，不谈了！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> apy = obj.getName	<span class="comment">//这手还是不变</span></div><div class="line">apy.apply(obj)		<span class="comment">//koala  （可以说不是指向还给他，这不是假装了，而是直接套用</span></div></pre></td></tr></table></figure>
<p>有人要问，那你这手跟<code>call()</code>不是一样的么，为什么要区分开来。这个问题<a href="/2017/08/14/js-call-apply-bind/#call-和-apply-区别">下面再讲</a></p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h2><p>是不是以为我要用百度翻译了？我偏不！</p>
<blockquote>
<p><strong>bind</strong></p>
<p><strong>n.</strong> 窘境；讨厌的事情；捆绑；植物的藤蔓<br><strong>v.</strong> 捆绑；约束；装订；（使）结合；使关系密切<br>以上来自沪江小d，我学日语就靠它</p>
</blockquote>
<p><del>顺便，请以上三家公司尽快给我打钱，谢谢合作。</del></p>
<p><code>bind()</code>有点土匪的意思，它就是想抢走你老婆借用一晚的意思。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> bid = obj.getName	<span class="comment">// [Function: getName]          (这手还是不变</span></div><div class="line"></div><div class="line"><span class="comment">// 接着这样做，把this指向回去，变成一个可以自由操作的变量</span></div><div class="line">bid = bid.bind(obj)		<span class="comment">// [Function: bound getName]</span></div><div class="line"></div><div class="line">bid()					<span class="comment">// koala   （这样才会运行，因为刚刚只是抢过来了</span></div></pre></td></tr></table></figure>
<h2 id="call-和-apply-区别"><a href="#call-和-apply-区别" class="headerlink" title="call()和#apply()区别"></a>call()和#apply()区别</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> cal = obj.getName</div><div class="line">cal.call(obj)		<span class="comment">//koala</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> apy = obj.getName</div><div class="line">apy.apply(obj)		<span class="comment">//koala</span></div></pre></td></tr></table></figure>
<p>说是这么说了，可是，他们并不是说就这么改变<code>this</code>方向然后就没什么用处了啊，可以借用<code>call()</code>和<code>apply()</code>传参数的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName(param1, param2) &#123;</div><div class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' params: '</span> + param1 + param2</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> cal = obj.getName</div><div class="line">cal.call(obj, <span class="number">1</span>, <span class="number">2</span>)		<span class="comment">//koala params: 12</span></div></pre></td></tr></table></figure>
<p>那么<code>apply()</code>就有区别了？哎！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> apy = obj.getName	<span class="comment">//这手还是不变</span></div><div class="line">apy.apply(obj, [<span class="number">1</span>, <span class="number">2</span>])		<span class="comment">//koala params: 12</span></div></pre></td></tr></table></figure>
<p><code>apply</code>后面接参数，只接受数组，<code>call</code>的话按顺序怼进去就行了。就这点区别。</p>
<p>暂时先这样，以后更深入的使用再深入的理解一下。现在大概就用到这些。</p>
<p><strong>下一篇，讲Javascript的柯基化！</strong></p>
]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于Javascript的条件判断]]></title>
      <url>/PersonalBlog/2017/08/09/about-conditionals/</url>
      <content type="html"><![CDATA[<blockquote>
<p>记录这个不为什么，就是遇到SB，不想争执。</p>
</blockquote>
<p>撕逼文，小标题都会比较小，方便撕逼思路的连续性！<br><a id="more"></a></p>
<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>之所以想到写这个。是因为，公司给我安排的领导一直做的J2SE，没怎么过JS。然后接触了点ES6就疯狂装逼，看谁都是错的。要代码优雅但不愿意开ESLint；不要滥用语法糖却强制让人所有函数使用Promise；代码强调简洁但是非常简单的类似于<code>() =&gt; console.log(&#39;hello world&#39;))</code>都要分成三行写。这就是这次撕逼的源头了。</p>
<h3 id="JS的条件判断需不需要花括号？"><a href="#JS的条件判断需不需要花括号？" class="headerlink" title="JS的条件判断需不需要花括号？"></a>JS的条件判断需不需要花括号？</h3><blockquote>
<p>大多数语言中，条件判断语句后不接花括号的话，默认只会取接下来的语句作为子语句。</p>
</blockquote>
<p>在这点的话，无论Java或者Javascript都是一样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (;;) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 可以是这样的</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (;;) <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么这么说没有什么说服力，比如这样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一种</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) <span class="built_in">console</span>.log(i)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 第二种</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</div><div class="line">  	<span class="built_in">console</span>.log(i)</div><div class="line">&#125;</div><div class="line"></div><div class="line">test1() <span class="comment">// 01234</span></div><div class="line">test2() <span class="comment">// 01234</span></div></pre></td></tr></table></figure>
<p>那么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一种</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) <span class="built_in">console</span>.log(i)</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'你真TM搞笑'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 第二种</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</div><div class="line">  	<span class="built_in">console</span>.log(i)</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'你真TM搞笑'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 第三种</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</div><div class="line">  	<span class="built_in">console</span>.log(i); <span class="built_in">console</span>.log(<span class="string">'你真TM搞笑'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的，三个答案是不是一样的？建议看到的如果不清楚答案，可以去试一下，如果你的node是从官网下的的话，就是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">你真TM搞笑</div></pre></td></tr></table></figure>
<p>很失望是不是！为什么第二种不是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">你真TM搞笑</div><div class="line">1</div><div class="line">你真TM搞笑</div><div class="line">2</div><div class="line">你真TM搞笑</div><div class="line">3</div><div class="line">你真TM搞笑</div><div class="line">4</div><div class="line">你真TM搞笑</div></pre></td></tr></table></figure>
<p><strong>那语言设计就是这样的，我能怎么办，我也很绝望啊</strong></p>
<p>那么“大神怎么说的”</p>
<blockquote>
<p>某“ES6专家”：你忘记的时候多写一行就会出现bug</p>
</blockquote>
<p>这又是什么情况呢？原题目的话是这样的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (exist) <span class="keyword">return</span> <span class="string">'该数据存在'</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="string">'不存在数据，需要添加'</span></div></pre></td></tr></table></figure>
<p>这实在让我抓破了头都不知道他想表达什么。难道他的意思是这样的？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (exist) <span class="keyword">return</span> <span class="string">'该数据存在'</span>  <span class="comment">// 不存在else 报错？</span></div><div class="line"><span class="comment">// else return '不存在数据，需要添加'</span></div><div class="line"></div><div class="line"><span class="comment">//或者第二种情况</span></div><div class="line"><span class="keyword">if</span> (exist) <span class="keyword">return</span> <span class="string">'该数据存在'</span></div><div class="line"><span class="comment">// else return '不存在数据，需要添加'</span></div><div class="line"><span class="built_in">console</span>.log(exist) <span class="comment">// 报错？</span></div></pre></td></tr></table></figure>
<p>但是，根据JS “没有花括号的情况下只会把接下来的第一句作为子语句” 已经证明不存在该问题了。那么他要说明什么？</p>
<h3 id="可能声明式编程真的会出现这种错误"><a href="#可能声明式编程真的会出现这种错误" class="headerlink" title="可能声明式编程真的会出现这种错误"></a>可能声明式编程真的会出现这种错误</h3><h4 id="第一种情况，if中为Boolean类型报错。"><a href="#第一种情况，if中为Boolean类型报错。" class="headerlink" title="第一种情况，if中为Boolean类型报错。"></a>第一种情况，if中为Boolean类型报错。</h4><p>就上面问题，我去百度了（这种垃圾问题Google什么？是看不起百度还是看不起谷歌还是你想装逼展示你会把梯子竖起来？）关键词<code>java if 不写大括号 报错</code></p>
<p>在CSDN确实有一处，<a href="http://blog.csdn.net/androidiscoding/article/details/47725347" target="_blank" rel="external"><a href="http://blog.csdn.net/androidiscoding/article/details/47725347" target="_blank" rel="external">你不知道java问题if后面加不加括号的问题</a></a>。（感谢大神分享）确实明确提到了</p>
<blockquote>
<p>if (boolean) 后面不使用花括号时，里面不能出现声明语句。</p>
</blockquote>
<p>哦，那还真对不起了ES6大神。</p>
<h4 id="第二种情况，作用域错误"><a href="#第二种情况，作用域错误" class="headerlink" title="第二种情况，作用域错误"></a>第二种情况，作用域错误</h4><p>这个可能需要代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog) </div><div class="line">Dog d = (Dog) a;</div></pre></td></tr></table></figure>
<p>这里还是CSDN得内容，<a href="http://bbs.csdn.net/topics/391057013?page=1" target="_blank" rel="external">为什么省略if后的大括号｛｝会报错</a>，其中<a href="http://my.csdn.net/finemi" target="_blank" rel="external">@finemi</a>提到，可能是java虚拟机的作用域问题，会把下面那句当做大作用域的内容，并不归属于if语句了。这是因为作用域错乱导致的错误，所以用花括号括住保证if内部作用域不受污染。</p>
<p>哦~<strong>私的ES6大神是本当对不起了！</strong></p>
<p>这也说明了，声明式编程在语法上确实比较严谨，看起来比较安全。我当时学习Objective-C的时候也确实踩了不少类似于奇怪语法的坑，不过后来信仰了Swift的结构式时候会好了很多。</p>
<h3 id="最后补一手关于ES6箭头函数的换行与不换行"><a href="#最后补一手关于ES6箭头函数的换行与不换行" class="headerlink" title="最后补一手关于ES6箭头函数的换行与不换行"></a>最后补一手关于ES6箭头函数的换行与不换行</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">() =&gt; <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</div></pre></td></tr></table></figure>
<p>（有时候真感觉语法糖害死人，不过也方便了我们作死和捣乱）</p>
<p>其实关于这个，阮一峰老师的开源书<a href="http://es6.ruanyifeng.com/#docs/function#箭头函数" target="_blank" rel="external">函数的扩展 - ECMAScript 6入门</a></p>
<blockquote>
<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</p>
<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。</p>
</blockquote>
<p>代码例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>也就是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> test1 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">let</span> test2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 如果有些变态喜欢这么写</span></div><div class="line"><span class="keyword">let</span> test3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后阮老师强调了</p>
<blockquote>
<p><strong>箭头函数使得表达更加简洁。</strong></p>
<p><strong>如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</strong></p>
</blockquote>
<h3 id="最后总结一手"><a href="#最后总结一手" class="headerlink" title="最后总结一手"></a>最后总结一手</h3><p>在知乎，轮子哥解释过函数式编程</p>
<blockquote>
<p>函数是语言都倾向于让你用函数来组成函数，而不是把函数看成是一个数据弄成另一个数据的过程。</p>
</blockquote>
<p>还有我最喜欢的<a href="https://www.zhihu.com/people/be5invis" target="_blank" rel="external">@Belleve</a>贴了一张图说明了“越往下面走离函数式编程越远”</p>
<p><img src="https://pic4.zhimg.com/v2-a31b50055c9b896f7e3b9bb4467204e3_b.png" alt=""></p>
<p>另外，在Javascript中，虽然被称为“玩具语言”，但是就现在被开发的情况来说，Javascript绝对是目前最灵活和最强大的语言了，虽然它运行环境苛刻而严格，还不能做到anyway。</p>
<p>不过一码归一码，我这么说是想表达，Javascript发展到现在，应该说还有一大块大陆需要去探索，可能这个语言就像我们大脑一样，虽然很厉害了，实际上才开发了一点点而已吧。我也是正在学习这个语言，我只是想说，从想成为JSer开始，就意味着要不断学习。因为这个语言只会随着时间被开发得越来越多。</p>
<p>而且，几乎每每都能看到有人一直强调：<strong>函数是JS的第一公民</strong>。</p>
<p>这是什么意思？如果是函数式编程的话，那么，它所定义的每一个语句或者每一个代码块都可以视为函数。</p>
<p>声明式编程是让你声明某些东西，把内容转化为数据，数据转化为数据。而很明显javascript并不隶属这一家族。而且，js好像连Object都是Function类型的吧！</p>
<p>而且script，脚本语言+函数式语言，这才是我热爱并追随的地方。虽然我在JS是真的菜！</p>
<p>最后</p>
<p style="font-size:24px;font-weight:500;text-align:center;">把Javascript当做指令式编程的人都是神经病！</p>



<p>（最后感谢所有被引用的文章和作者，谢谢。）</p>
]]></content>
      
        <categories>
            
            <category> 编程议论 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[也许是第一个最好理解的Vuex入门]]></title>
      <url>/PersonalBlog/2017/04/14/easyknow-vuex/</url>
      <content type="html"><![CDATA[<p>刚用vue不久，应该说还有大量的API还没用过还没熟悉过的时候，突然接受一个新内容，而且还是个很抽象的东西，说实话刚接触的时候完全不知道这东西有什么用…只听说过它能状态管理啊，什么全局控制啊。好牛逼啊666啊。</p>
<p><strong>哦，然后呢？</strong></p>
<p>后来稍微理解之后，决定写出来。浅入浅出的理解一下vuex。<a id="more"></a></p>
<h2 id="what-s-vuex"><a href="#what-s-vuex" class="headerlink" title="what s vuex"></a>what s vuex</h2><p>官方文档：<a href="https://vuex.vuejs.org/zh-cn/" target="_blank" rel="external">Introduction · GitBook</a>，vue的内容都挺良心的，都是看似官方的中文文档…</p>
<p>Vuex还是跟上面所述…一个应用的状态管理模式。</p>
<blockquote>
<p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
</blockquote>
<p>所以只能说它是一个接近于redux，类似于react与redux的那种存在。可是印象没记错的话，react和redux其实是可以独立使用的，这完全就是两个东西，只是可以配合到一块儿去。而vue+vuex不同，vuex之为vue工作，并不能为react等其他框架使用。（也就是redux和vuex都可以为vue服务！不同在于vuex是正室redux是娼！）</p>
<p>至于“什么是状态管理模式”，官方给了一个例子，看例子就行了。</p>
<p>什么看不懂？看得懂就不用看这个了？好的可以。开始举例子了啊！</p>
<p>比如你现在看到桌面上有个馒头，然后你觉得不够吃不爽，你又从冰箱里拿出了一个叉烧包放在桌子上。所以这个时候桌面上就会有一个馒头和一个叉烧包。然后你是哪种什么难吃先吃什么的人（没酱！干吃！反驳我的人晚上别吃饭了！），然后你拿起一个馒头咬了一口然后放在手上。</p>
<p>OK举例完了。这就是状态管理。</p>
<p>我们一个vue实例（我就以我会用的2.0角度说），首先会有一个template，模板文件，里面存放的是dom。然后是<code>data()</code>方法，存放固定或不固定的数据。还有一个<code>methods</code>，存放方法，各种方法。对吧没问题吧！你看到(<code>view or template</code>)桌面上<code>{ mantou: 1 }</code>，你觉得不爽去拿(<code>methods -&gt; take()</code>)，然后多了一个叉烧包放在桌子上<code>{ mantou: 1, chashaobao: 1 }</code>，然后你拿起馒头就吃(<code>methods -&gt; ate()</code>)，还拿在手上(保持状态) ，当然data()目前肯定是 { mantou: 0.9, chashaobao: 1 }。<strong>其实我有个梦想，去教小朋友学编程，从小把路给他带歪掉。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="comment">// state</span></div><div class="line">  data () &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      food: &#123;</div><div class="line">        mantou: <span class="number">1</span>,</div><div class="line">        chashaobao: <span class="number">0</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// view</span></div><div class="line">  template: <span class="string">`</span></div><div class="line"><span class="string">    &lt;div class="table"&gt;</span></div><div class="line"><span class="string">		&lt;p&gt;&#123;&#123; food.mantou &#125;&#125; &lt;/p&gt;</span></div><div class="line"><span class="string">		&lt;p&gt;&#123;&#123; food.chashaobao &#125;&#125; &lt;/p&gt;</span></div><div class="line"><span class="string">	&lt;/div&gt;</span></div><div class="line"><span class="string">  `</span>,</div><div class="line">  <span class="comment">// actions</span></div><div class="line">  methods: &#123;</div><div class="line">    ate () &#123;</div><div class="line">      <span class="keyword">this</span>.mantou -= <span class="number">0.1</span></div><div class="line">    &#125;,</div><div class="line">    take () &#123;</div><div class="line">      <span class="keyword">this</span>.chashaobao += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>那么按照vuex开说，就是三种状态，<code>state</code>, <code>action</code>,<code>view</code>。分别就状态，动作，视图。按照官方说的，如果是按照单向数据流来说的话就是 视图 -&gt; 动作 -&gt; 状态 -&gt; 视图。当然刚刚那个例子很明显，都在一个组件内…涉及到多个组件了。就会出现“单向数据流简洁性被破坏”</p>
<blockquote>
<ul>
<li>多个视图依赖于同一状态。</li>
<li>来自不同视图的行为需要变更同一状态。</li>
</ul>
</blockquote>
<p>就好比现在只是你一个人在做这些事而已，如果家里来了个女朋友呢？（对不起我知道你没有。那你还是单组件管理就行了）。</p>
<p>官方的意思就是：如果多个视图依赖一个状态，就会出现组件嵌套特别繁琐，而且状态数据也不好传递。如果不同视图行为都要变一个状态，意思就是你咬了一口的馒头你女朋友直接从你嘴里叼走一块！那怎么办！你可以选择不带套路的顺便亲一下是吧！<strong>但是程序并不会“亲一下”。</strong></p>
<p>所以<code>vuex</code>或者说<code>redux</code>就是因为这个“状态共享解决”而诞生的。（或者说vuex的诞生就是为了提醒你你还没有女朋友。</p>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>按照官方文档，核心概念一共有5个：<code>State</code>, <code>Getters</code>, <code>Mutations</code>, <code>Actions</code>, <code>Modules</code>，一整个vuex在项目里称为<code>store</code>。</p>
<blockquote>
<ol>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交(commit) mutations</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li>
</ol>
</blockquote>
<p>首先是在main.js先声明你要用vuex，你要把vuex导入</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></div><div class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"></div><div class="line">Vue.use(Vuex)</div></pre></td></tr></table></figure>
<p>然后创建一个基础的Store，是这样的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * main.js</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  state: &#123;</div><div class="line">    mantou: <span class="number">1</span></div><div class="line">  &#125;,</div><div class="line">  mutations: &#123;</div><div class="line">    ate: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</div><div class="line">      state.mantou -= <span class="number">0.1</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>要记得实例要调用一下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  ...,</div><div class="line">  ...,</div><div class="line">  store</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>冰箱啊！也叫做单一状态树，也就是说一整个应用就只有这么一个state，因为放在store中，而store又是一个全局的，所以这是一个人人都能用的大冰箱！（你女朋友也能开</p>
<p>那么，比如冰箱现在是这么些东西。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">state = &#123;</div><div class="line">  mantou: <span class="number">1</span>,</div><div class="line">  chashao: <span class="number">3</span>,</div><div class="line">  panzi: <span class="string">'红烧鱼'</span>,</div><div class="line">  wan: &#123;</div><div class="line">    name: <span class="string">'卤水鸡腿'</span>,</div><div class="line">    num: <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后这么取出东西：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">store.state.mantou 	<span class="comment">//获取馒头的值(数量)</span></div><div class="line">store.state.panzi 	<span class="comment">//红烧鱼</span></div></pre></td></tr></table></figure>
<p>如果在vue实例中，应该这么取</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.$store.state.mantou 	<span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>之所以有<code>$store</code>这种定义，是因为已经作为vue的一个插件了，一开始是不是有<code>Vue.use</code>过。</p>
<h3 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h3><p>这就是决定是你女朋友吃还是你自己吃了</p>
<blockquote>
<p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutations 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong>。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mutations = &#123;</div><div class="line">  ate (state) &#123;</div><div class="line">    state.mantou -= <span class="number">0.1</span></div><div class="line">  &#125;,</div><div class="line">  take (state) &#123;</div><div class="line">    state.chashao -= <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然是在<code>mutaitons</code>构造方法，但这个载体并不是一个方法载体，等下讲。</p>
<p>那么如果决定是谁吃：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * SingleDog.js</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  ... ,</div><div class="line">  ... ,</div><div class="line">  method: &#123;</div><div class="line">    ...() &#123;</div><div class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'ate'</span>)  <span class="comment">//mantou: 0.9</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不一定非要这么写，反正只要能调用就行了。</p>
<h3 id="mutations-payload"><a href="#mutations-payload" class="headerlink" title="mutations payload"></a>mutations payload</h3><p>还有一个是mutations 的载荷（payload），就是在上面那种调用的基础上再传入第二个参数，第二个参数就叫payload。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mutations = &#123;</div><div class="line">  take (state, value) &#123;</div><div class="line">    state.chashao -= value</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如这样，首先构建的时候已经有准备可以传入第二个参数，然后调用的时候同理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">store.commit(<span class="string">'take'</span>, <span class="number">1</span>)		<span class="comment">//chashao - 1</span></div></pre></td></tr></table></figure>
<p>或者payload也可以是个Object（对象！你没有！）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mutations = &#123;</div><div class="line">  take (state, obj) &#123;</div><div class="line">    state.chashao -= obj.num</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * GirlFriend.js</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  ... ,</div><div class="line">  ... ,</div><div class="line">  method: &#123;</div><div class="line">    ...() &#123;</div><div class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'take'</span>, &#123;</div><div class="line">        num: <span class="number">1</span></div><div class="line">      &#125;)  <span class="comment">//chashao - 2 （刚被狗吃了一个）</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>暂时先总结这两个。</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="1-mutations-amp-actions"><a href="#1-mutations-amp-actions" class="headerlink" title="1. mutations &amp; actions"></a>1. mutations &amp; actions</h3><p><a href="https://www.zhihu.com/question/48759748" target="_blank" rel="external">vuex中为什么把把异步操作封装在action，把同步操作放在mutations？ - 知乎</a></p>
<p>官方也有提到，mutations跟actions是差不多的，不同在于</p>
<blockquote>
<ul>
<li>Action 提交的是 mutation，而不是直接变更状态。</li>
<li>Action 可以包含任意异步操作。</li>
</ul>
</blockquote>
<p>也就是按我的理解，他们的关系是这样的：<strong>mutations直接操作state内容，actions直接操作的是mutations。如果需要用actions去操作state的话建议做法就是通过actions操作mutations使state发生变化。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">actions = &#123;</div><div class="line">  onAte (someOne) &#123;</div><div class="line">    someOne.commit(<span class="string">'ate'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个怎么举例啊…你劝着你女朋友：来嘛来嘛吃一口嘛。这样？</p>
<p>那么如何劝？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">store.dispatch(<span class="string">'onAte'</span>)</div></pre></td></tr></table></figure>
<p>不仅这样，mutations和actions分开使用还有一个场景：<strong>同步和异步</strong>。</p>
<p>这个就好比，如果你只是使用<code>mutations</code>来操作state的话，就是你只能看着你女朋友吃完然后你吃剩下的。</p>
<p>而使用<code>actions</code>的话，你可以边劝你女朋友吃一口，你自己还可以顺便咬一口，因为异步不受限制。</p>
<p>关于同步跟异步的代码例子，官方已经列举特别特别多了。</p>
<p><a href="https://vuex.vuejs.org/zh-cn/actions.html" target="_blank" rel="external">Actions · GitBook</a></p>
<p>结束！</p>
]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
            <tag> vuex </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue2.0的网络请求 - Axios]]></title>
      <url>/PersonalBlog/2017/04/07/axios-tutorial/</url>
      <content type="html"><![CDATA[<blockquote>
<p>我没进传销！真是日了皮皮虾了…</p>
</blockquote>
<p>由于Vue2.0之后，<code>vue-resource</code>也停止更新了，改为使用尤老师钦点的<code>axios</code>。<a href="https://github.com/mzabriskie/axios" target="_blank" rel="external">mzabriskie/axios: Promise based HTTP client for the browser and node.js</a></p>
<p>那反正不管！他说不合适我不用，我就去学个新的。其实接触过微信小程序的话，稍加理解，这就是一个比较厉害点但是又有局限的<code>wx.request()</code></p>
<h2 id="what-s-Axios"><a href="#what-s-Axios" class="headerlink" title="what s Axios"></a>what s Axios</h2><a id="more"></a>
<blockquote>
<p>Promise based HTTP client for the browser and node.js</p>
</blockquote>
<p>就是一个基于ES6的<code>Promise</code>的网络请求库，其实说干净了就是一个打包好的<code>XMLHttpRequests</code>，也就是说不过一个Ajax库。</p>
<p>所以它一样可以实现：</p>
<ul>
<li>在浏览器里建立XHR</li>
<li>通过nodejs进行http请求</li>
<li>转换或者拦截请求数据或者相应数据</li>
<li>支持<code>Promise</code>的API</li>
<li>可以取消请求</li>
<li>自动转换JSON</li>
<li><strong>可以防御XSRF攻击！</strong></li>
</ul>
<p>浏览器支持问题也没什么问题，IE这种本时代异端都能支持到8+，这问题是不大了。（VUE不也是8+！）</p>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>如果有用npm管理包的话，那么安装还是老规矩的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install axios</div></pre></td></tr></table></figure>
<p>或者用到了bower（反正我没用过）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bower install axios</div></pre></td></tr></table></figure>
<h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">axios.get(<span class="string">'/* url */'</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// Do Somethings</span></div><div class="line">  <span class="comment">// console.log(response)</span></div><div class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(error)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>因为可以使用Promise的API，那么毫无悬念它的运行肯定也是以Promise来运行。</p>
<p>而且url，可以是带参数的，例如<code>/user?id=666</code>，或者也可以拆分开来</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">axios.get(<span class="string">'/user'</span>, &#123;</div><div class="line">  params: &#123;</div><div class="line">    id: ColMugX</div><div class="line">  &#125;</div><div class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)).catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</div></pre></td></tr></table></figure>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">axios.post(<span class="string">'/* url */'</span>, &#123;</div><div class="line">  <span class="comment">/* Config */</span></div><div class="line">  <span class="comment">// id: 666,</span></div><div class="line">  <span class="comment">// name: ColMugX</span></div><div class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</div></pre></td></tr></table></figure>
<p>其他的大概也跟GET相差无几。只不过关于’url’后面传入的Object，有可能是用不了的，也有可能是用的了的。因为其他人有类似情况发生。所以我一般都是按照axios api的做法，怎么做下面有！</p>
<p>因为大概用的多的就这两个…所以举例就差不多这样了，毕竟<code>vue-resource</code>有的基本都有。</p>
<h3 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h3><h4 id="1-axios是一个方法，你甚至可以整个config传进去"><a href="#1-axios是一个方法，你甚至可以整个config传进去" class="headerlink" title="1. axios是一个方法，你甚至可以整个config传进去"></a>1. axios是一个方法，你甚至可以整个config传进去</h4><p>文档有提到，关于<code>axios API</code>有一条实现方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">axios(config) <span class="comment">//config: Object</span></div></pre></td></tr></table></figure>
<p>这就意味着，我们可以直接创建一整套静态的config，然后请求的时候带进去就能实现了。比如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> *	config.js</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  method: <span class="string">'GET'</span>,</div><div class="line">  url: <span class="string">'localhost:6666'</span>,</div><div class="line">  headers: &#123;</div><div class="line">    token: <span class="string">'ftv1443qby6bdfa41t90sfvq89hg3h54u989m9imog79g4'</span> </div><div class="line">    <span class="comment">//这一看就知道是滚键盘的…</span></div><div class="line">  &#125;,</div><div class="line">  data: &#123;</div><div class="line">    id: <span class="number">666</span>,</div><div class="line">    name: <span class="string">'ColMugX'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> *	Axios.js</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'config'</span></div><div class="line"><span class="keyword">import</span> axios form <span class="string">'axios'</span></div><div class="line"></div><div class="line">axios(config)</div></pre></td></tr></table></figure>
<p>配置和运行分离可以带来很多好处，比如baseUrl，header 等等一堆需要重复调用又可以不用重复写，甚至还可以把这些静态的东西直接静态常量掉。避免自己出错或者被更改。而且这么一来的话，甚至请求的话只需要改动url和method就行了。</p>
<p>因为用的是对象的方法，那好办啊！干对象有什么难的！</p>
<p>- 今天要用什么姿势！</p>
<p>- 要不你在上面吧我趴着！</p>
<p>好那就趴着！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> conf = config</div><div class="line">conf.method = <span class="string">'PUT'</span></div><div class="line"><span class="comment">//其他该怎么传怎么传</span></div></pre></td></tr></table></figure>
<p>然后请求配置官方有一个<a href="https://github.com/mzabriskie/axios#request-config" target="_blank" rel="external">默认配置方案</a>，照着这个看一下大概也知道它支持传什么东西进去了。</p>
<p>（默认就有baseURL的配置确实是很惊讶，而且文档写的很清楚，如果没有baseURL或者url已经绝对了的话直接走url）</p>
<h4 id="2-换了个姿势也许会压到头！"><a href="#2-换了个姿势也许会压到头！" class="headerlink" title="2. 换了个姿势也许会压到头！"></a>2. 换了个姿势也许会压到头！</h4><p>并不是说上面趴着会压爆头什么的…只是顺着梗玩下来而已！</p>
<p>因为上面说了，axios是可以把整个config都传进去然后开展工作的，所以也就意味着headers和method也可以带在config对象里一起进去，那么可能会有个小问题</p>
<p><strong>当你的<code>content-tyle</code>是<code>application/x-www-form-urlencoded</code>的时候，<code>POST</code>会用不了！</strong>你请求一下会发现方法直接变成<code>OPTION</code>。</p>
<p>那是为什么反正我也不知道，我只知道怎么处理，原因是axios的post请求不支持<code>x-www-form-urlencoded</code>，确实是挺奇怪的一件事…</p>
<p>所以使用到post的时候，要不主动把头改成<code>application/json</code>，这是没问题的，如果不想用或者不能用json的话，传进去的data也就是参数必须是<code>string</code>形式的。这个时候官方建议是多加一个库叫<code>qs</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">'qs'</span></div><div class="line"></div><div class="line">axios.post(<span class="string">'foo'</span>, qs.stringify(config.data))</div></pre></td></tr></table></figure>
<p>这也是上面说的，为什么有些人在使用<code>POST</code>的时候会遇到“明明跟着官方做却又不对”的情况。</p>
<p>（稍微吐槽一下！隔壁那个什么微信小程序！他们的<code>get</code>是要求<code>json</code>的，<code>post</code>是要求要<code>form-urlencoded</code>的，逆着来对我等运动员不友好啊！）</p>
<h4 id="3-实际上错误也不是非得catch"><a href="#3-实际上错误也不是非得catch" class="headerlink" title="3. 实际上错误也不是非得catch"></a>3. 实际上错误也不是非得catch</h4><p>实际上<code>.then()</code>会跟两个参数的：<code>resolve, reject</code>，在axios的话，reject是可以用来输出错误的。而且他们也已经这么定义好了。所以</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">axios(config).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res), err =&gt; <span class="built_in">console</span>.log(err))</div></pre></td></tr></table></figure>
<p>也是没问题的</p>
<h4 id="4-请求完得到的response会得到这次请求的所有内容"><a href="#4-请求完得到的response会得到这次请求的所有内容" class="headerlink" title="4. 请求完得到的response会得到这次请求的所有内容"></a>4. 请求完得到的response会得到这次请求的所有内容</h4><p>包括<code>config ,data, headers, status, statusText</code>，请求凭证等在headers里，请求到的数据在data里。而且因为会自动转换为JSON，所以基本上请求到的所有数据都已经变成JSON了，可以直接就使用。</p>
<h4 id="5-withCredentials"><a href="#5-withCredentials" class="headerlink" title="5. withCredentials"></a>5. withCredentials</h4><p>在<code>axios</code>中这是个默认配置里面一个参数，按照我自己的理解，这是一个“是否保存跨域请求凭证”的一个开关，因为众所周知跨域请求是取不到cookie的，这是一个安全策略。但是浏览器可以获取，浏览器可以使用。<strong>人类看不到也使用不到！</strong></p>
<p>不过道理还是道理，如果你不打开，跨域的不管toekn还是cookie在浏览器里也是一个子都取不到用不到。</p>
<p>而且设置了<code>withCredentials</code>之后，axios是会保存所有来自远程域的cookie的，比如某些需要登录过后才能访问的内容，就可以直接调用访问了，只要你不清空。</p>
<p>结束！</p>
]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于JavaScript的this]]></title>
      <url>/PersonalBlog/2017/03/03/js-this/</url>
      <content type="html"><![CDATA[<blockquote>
<p>一次被this支配之后的思考</p>
</blockquote>
<h3 id="开门见山"><a href="#开门见山" class="headerlink" title="开门见山"></a>开门见山</h3><a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(obj.getName()())    <span class="comment">//undefined.</span></div></pre></td></tr></table></figure>
<p>题目这样，我第一次回答的是<code>koala</code>。现在想了一下，估计是满脑子想吃波星冰乐给冲昏了脑子。<br>如果我改下！<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">        <span class="keyword">let</span> that = <span class="keyword">this</span>    <span class="comment">//this -&gt; that</span></div><div class="line">        <span class="keyword">let</span> name = <span class="string">'koala'</span></div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> that.name <span class="comment">//this -&gt; that</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(obj.getName()()) <span class="comment">//koala</span></div><div class="line"></div><div class="line"><span class="comment">// 或者第二种，利用ES6</span></div><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">        <span class="keyword">let</span> name = <span class="string">'koala'</span></div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(obj.getName()()) <span class="comment">//koala</span></div></pre></td></tr></table></figure></p>
<h3 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h3><p>我的理解，<code>this</code>其实跟其他语言的<code>self</code>应该是差不多。就是指代自己，比如说在一个<code>function</code>里面，那么<code>this</code>指向的就是这个func。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">colmugx</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//do something.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可能我讲的不清楚，就是<strong>this其实就是括号里的东西。</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">colmugx</span>(<span class="params"><span class="regexp">/** this */</span></span>) </span>&#123;</div><div class="line">    <span class="comment">//do somethings</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然这是我的理解，我觉得应该就是这样的，所以刚刚那样取到的this并不是this。</p>
<h3 id="浅谈this"><a href="#浅谈this" class="headerlink" title="浅谈this"></a>浅谈this</h3><p>只讲两种我懂的东西。</p>
<h4 id="跟着new走"><a href="#跟着new走" class="headerlink" title="跟着new走"></a>跟着new走</h4><p>就是用new来创建对象的话，那么<code>this</code>就会跟着这个new<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    func() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">'koala'</span>)</div><div class="line"><span class="built_in">console</span>.log(a.name) <span class="comment">//koala</span></div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    func() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">'koala'</span>)</div><div class="line"><span class="built_in">console</span>.log(a.func()) <span class="comment">//Animal &#123; name: 'koala' &#125;</span></div></pre></td></tr></table></figure>
<h4 id="ES6中括号函数的this"><a href="#ES6中括号函数的this" class="headerlink" title="ES6中括号函数的this"></a>ES6中括号函数的this</h4><p>括号函数的<code>this</code>，不存在的！</p>
<p>说是不存在，实际上并不是说真的不见了，而是它会绑定到上一层函数中<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</div><div class="line">    <span class="comment">//do somethings.</span></div><div class="line">&#125;<span class="comment">/** ,this */</span>)</div></pre></td></tr></table></figure></p>
<p>而如果不是括号的话</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="regexp">/** this */</span></span>)</span>&#123;</div><div class="line">    <span class="comment">//do somethings.</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES古往今来所有for的总结]]></title>
      <url>/PersonalBlog/2017/03/02/js-for/</url>
      <content type="html"><![CDATA[<p>其实也是看到了<a href="https://zhuanlan.zhihu.com/jbangit" target="_blank" rel="external">匠邦互联网 - 知乎专栏</a>，其中一篇讲for的</p>
<p>觉得我不服！我要上！<br><a id="more"></a></p>
<h3 id="先讲for"><a href="#先讲for" class="headerlink" title="先讲for"></a>先讲for</h3><p>我觉得这应该是最古老而且实用性最强的for了，就是三段式定义。<code>for (;;)</code><br>想到当年考java编程基础的时候（一门学科），有一道手写题要用到循环，我抬手就是<code>for (var ...)</code>…<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i;i&lt;len;i++)</div></pre></td></tr></table></figure></p>
<p>其中不管怎样，常规for必须要两个;，因为就是这样，里面有三段式嘛。第一个是定义自走变量，第二个是条件，第三个是自加或自减。实际上for应该是这样的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i;<span class="keyword">let</span> len;i&lt;len;++i)</div></pre></td></tr></table></figure></p>
<h3 id="for-in"><a href="#for-in" class="headerlink" title="for..in"></a>for..in</h3><p>这个在上次总结对象遍历已经提到了，它好像也就遍历对象用得多一点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> sth) &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>不过<code>for in</code>的话，为什么说遍历对象比较多，其中一个除了好写<del>（打死吧这人）</del>，还有一点它只能用来遍历有key或者说是个index的东西，比如数组，它只能读到数组的index，那对象的话就直接读到键值咯。而且有一点的是，你读数组，<strong>读出来的index是个string不是number</strong>。这个要记得，因为js这种弱类型的东西，如果索引相加就变成字符串相加了……<strong>（我幼儿园就会20以内加减法了，1加2等于12)</strong></p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>这个方法就不是古老的方法了，JS(ES5)版本的时候的，针对数组的一个方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.forEach(<span class="function">(<span class="params">i</span>)=&gt;</span> &#123;&#125;)</div></pre></td></tr></table></figure></p>
<p>这种遍历的话，你遍历完直接能把数据处理掉最好，因为如果不是的话就麻烦了…它并不是一个开放的遍历，而是借用的闭包函数做的遍历。可以看成是<code>arr.func()</code>，它是一个数组方法，传进去一个<code>callback</code>，那就厉害了啊，闭包一个特点就是保护变量避免污染啊，变量保护是双向的啊…进得去出不来… （所以我的微信小程序openradio有用到计数器的时候不敢用这个，而且这个方法也是针对数组才能用的）</p>
<h3 id="for-of"><a href="#for-of" class="headerlink" title="for..of"></a>for..of</h3><p>这是ES6的新东西，它比<code>for in</code>遍历的更多，没有<code>for (;;)</code>复杂，对比<code>forEach</code>它是开放的不是闭包，也就是那些条件控制流什么的都可以操作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr)</div></pre></td></tr></table></figure></p>
<p>可是不止，好像还可以<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> <span class="string">'colmu'</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(i)  <span class="comment">//'c'\n 'o'\n 'l'\n 'm'\n 'u'\n</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不过它不能遍历对象！不能遍历对象！不能遍历对象！而且错误信息<code>TypeError: str[Symbol.iterator] is not a function</code>。所以这里我不行不BB了。</p>
<blockquote>
<p>所有实现了[Symbol.iterator]接口的对象都可以被遍历。</p>
</blockquote>
<h3 id="for-in-和-for-of-对比"><a href="#for-in-和-for-of-对比" class="headerlink" title="for in 和 for of 对比"></a>for in 和 for of 对比</h3><p>一个栗子就能锤到头皮发麻<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">6</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>]</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</div><div class="line">    <span class="built_in">console</span>.log(i)  <span class="comment">// 0,1,2,3,4</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">6</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>]</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</div><div class="line">    <span class="built_in">console</span>.log(i)  <span class="comment">//6,6,4,2,8</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>光说区别不行，我要讲怎么用！</p>
<p><del>万能膏药<code>while</code></del> （不对走错片场…）</p>
<p>万能膏药<code>for (;;)</code>：这是怎样都能用的，不过就是长了点，但是定义细了多。</p>
<p>数组专利<code>forEach</code>：数组的方法，只能用在数组。</p>
<p>能用在数组的：<code>for</code>, <code>forEach</code>, <code>for in</code>, <code>for of</code></p>
<p>能用在找头的：<code>for in</code></p>
<p>只要支持[Symbol.iterator]要什么找什么的：<code>for of</code></p>
]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6对象遍历]]></title>
      <url>/PersonalBlog/2017/02/28/object-traversal/</url>
      <content type="html"><![CDATA[<blockquote>
<p>花了几天时间都在探究ES6，为了实现对象遍历，一个头两个大。</p>
</blockquote>
<p>最新超想玩《尼尔：机械纪元》，被那种机械元素迷得死死的，故把最近正在写的博客主题融入机械风。另外我打算这次主题换个姿势来写，想用各种新鲜没尝试过的结构。于是……</p>
<h3 id="作死起源"><a href="#作死起源" class="headerlink" title="作死起源"></a>作死起源</h3><a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//app.js</span></div><div class="line">App(&#123;</div><div class="line">  onLaunch: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    </div><div class="line">  &#125;,</div><div class="line">  onShow: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    </div><div class="line">  &#125;,</div><div class="line">  onHide: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    </div><div class="line">  &#125;,</div><div class="line">  globalData: globalData</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>万恶之源就是微信小程序，通过执行App()传入一套<code>params</code>，然后能执行下面那些方法。这我就心底长毛了啊，我也想实现类似这样的执行方法。所以就搞。现在尝试了不知道多少种方法，成功率0%</p>
<h3 id="谈一下ES6对象扩展-–-遍历对象"><a href="#谈一下ES6对象扩展-–-遍历对象" class="headerlink" title="谈一下ES6对象扩展 – 遍历对象"></a>谈一下ES6对象扩展 – 遍历对象</h3><p>先讲目的，我想这样然后<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> test = (<span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> sliv = params</div><div class="line">    </div><div class="line">    <span class="keyword">this</span>.sliv = sliv</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">test(&#123;</div><div class="line">    first() &#123;</div><div class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'first 666'</span>)</div><div class="line">    &#125;,</div><div class="line">    second() &#123;</div><div class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'second 666'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>当然了无法执行，东西是读进去了，但是谁知道你想执行谁，就因为这个所以想到了对象遍历。好了</p>
<h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><p><code>for in</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> test = (<span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> sliv = params</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> params) &#123;</div><div class="line">        <span class="built_in">console</span>.log(i)      <span class="comment">//first, second</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.sliv = sliv</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><p><code>Object.keys()</code><br>我的处理方法是这样的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> test = (<span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> sliv = params</div><div class="line">    <span class="keyword">let</span> &#123;keys&#125; = <span class="built_in">Object</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> keys(sliv)) &#123;</div><div class="line">        <span class="built_in">console</span>.log(i)      <span class="comment">//first, second</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.sliv = sliv</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>结果跟第一种一样，下一个！</p>
<h4 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h4><p><code>Object.getOwnPropertyNames()</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> test = (<span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> sliv = params</div><div class="line">    <span class="keyword">let</span> a = <span class="built_in">Object</span>.getOwnPropertyNames(params)</div><div class="line">    <span class="built_in">console</span>.log(a)      <span class="comment">//[ 'first', 'second' ]</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;a.length;i++) &#123;</div><div class="line">        <span class="built_in">console</span>.log(a[i])    <span class="comment">//first, second</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.sliv = sliv</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>对象遍历讲完！</p>
<h3 id="目的，我想执行"><a href="#目的，我想执行" class="headerlink" title="目的，我想执行"></a>目的，我想执行</h3><p>所以我想到的执行方法是这样<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> test = (<span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> sliv = params</div><div class="line">    params.first()      <span class="comment">//first 666</span></div><div class="line">    <span class="keyword">this</span>.sliv = sliv</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>但是如果我这么执行的话<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> test = (<span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> sliv = params</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> params) &#123;</div><div class="line">        <span class="keyword">let</span> func = sliv.i   <span class="comment">//undefined</span></div><div class="line">        func()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.sliv = sliv</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>亦或者<code>sliv.i()</code>都是失败告终，所以我就看了一下<code>typeof</code>，这first这些的类型均为<code>string</code>。</p>
<p>于是挖个坑记录一下，是否有办法可以遍历完对象之后执行掉对象内函数，我甚至连<code>new Object</code>都用过了……</p>
<p>所以这篇的记录只是ES6中对象的遍历！</p>
]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[来搞一手关于Javascript对象继承]]></title>
      <url>/PersonalBlog/2017/02/22/js-extends/</url>
      <content type="html"><![CDATA[<blockquote>
<p>小爝（知乎用户）：js里面什么都是对象，所以你看单身狗学这个语言学的老快了。</p>
</blockquote>
<p>就前几天看到的答案，觉得对啊！js这种边缘OP的语言，你说它没对象它是可以有的，你说它是面向对象语言它不是。<br>所以来研究一手关于JavaScript的继承。研究过程用一下typescript（这个真有对象了）<a id="more"></a></p>
<h3 id="先看一下关于typescript的继承"><a href="#先看一下关于typescript的继承" class="headerlink" title="先看一下关于typescript的继承"></a>先看一下关于typescript的继承</h3><p>看一下ts的类<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Parent &#123;</div><div class="line">    name: <span class="built_in">string</span></div><div class="line">    age: <span class="built_in">number</span></div><div class="line">    <span class="keyword">constructor</span>(<span class="params">msg:<span class="built_in">string</span>, age:<span class="built_in">number</span></span>) &#123;</div><div class="line">        <span class="keyword">this</span>.age = age</div><div class="line">        <span class="keyword">this</span>.name = msg;</div><div class="line">    &#125;</div><div class="line">    sayHello() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">`hello <span class="subst">$&#123;this.name&#125;</span>,now is <span class="subst">$&#123;this.age&#125;</span>`</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后来一手调用，全程感觉像在用<code>java</code><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> par = <span class="keyword">new</span> Parent(<span class="string">"mike"</span>, <span class="number">16</span>)</div><div class="line">par.sayHello()      <span class="comment">//hello mike,now is 16</span></div></pre></td></tr></table></figure></p>
<p><strong>答案我在terminal验证过的没问题！！</strong></p>
<p>接下来尝试一下如果我走继承会是什么样，来一手继承<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Parent &#123;</div><div class="line">    name: <span class="built_in">string</span></div><div class="line">    age: <span class="built_in">number</span></div><div class="line">    <span class="keyword">constructor</span>(<span class="params">msg:<span class="built_in">string</span>, age:<span class="built_in">number</span></span>) &#123;</div><div class="line">        <span class="keyword">this</span>.age = age</div><div class="line">        <span class="keyword">this</span>.name = msg;</div><div class="line">    &#125;</div><div class="line">    sayHello() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">`hello <span class="subst">$&#123;this.name&#125;</span>,now is <span class="subst">$&#123;this.age&#125;</span>`</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//Now extends.</span></div><div class="line"><span class="keyword">class</span> Son <span class="keyword">extends</span> Parent &#123;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">msg, age</span>) &#123;</div><div class="line">        <span class="keyword">super</span>(msg, age);</div><div class="line">    &#125;</div><div class="line">    sayHello() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`hello I'm Son. next is my Parent's say`</span>)</div><div class="line">        <span class="keyword">super</span>.sayHello()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>来手调用验证结果<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sapi = <span class="keyword">new</span> Son(<span class="string">'peanut'</span>, <span class="number">10</span>)</div><div class="line">sapi.sayHello()  <span class="comment">//hello I'm Son. next is my Parent's say\n hello peanut,now is 10</span></div></pre></td></tr></table></figure></p>
<h3 id="该研究JavaScript的继承了"><a href="#该研究JavaScript的继承了" class="headerlink" title="该研究JavaScript的继承了"></a>该研究JavaScript的继承了</h3><p>先来看一下第一个例子翻译成ES5(JavaScript)是什么样的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Parent = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">msg, age</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">        <span class="keyword">this</span>.name = msg;</div><div class="line">    &#125;</div><div class="line">    Parent.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"hello "</span> + <span class="keyword">this</span>.name + <span class="string">",now is "</span> + <span class="keyword">this</span>.age);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> Parent;</div><div class="line">&#125;());</div><div class="line"><span class="keyword">var</span> par = <span class="keyword">new</span> Parent(<span class="string">"mike"</span>, <span class="number">16</span>);</div><div class="line">par.sayHello();</div></pre></td></tr></table></figure></p>
<p>首先是建立了个函数，函数内再嵌套一层函数，然后通过内部的<code>prototype</code>添加一个方法，最后返回整个父函数。<br>燃鹅在这个函数内部已经做了一次叫“原型链继承”的事情了。就是从父级，或者说从其他原型来指向到继承的实例来达到元素一并继承，这样我要实现后面的实例的时候就要连带前面的也一并执行了。</p>
<p>然后第二个例子，多了个继承<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> __extends = (<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.__extends) || <span class="function"><span class="keyword">function</span> (<span class="params">d, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> b) <span class="keyword">if</span> (b.hasOwnProperty(p)) d[p] = b[p];</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__</span>(<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.constructor = d; &#125;</div><div class="line">    d.prototype = b === <span class="literal">null</span> ? <span class="built_in">Object</span>.create(b) : (__.prototype = b.prototype, <span class="keyword">new</span> __());</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> Parent = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">msg, age</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">        <span class="keyword">this</span>.name = msg;</div><div class="line">    &#125;</div><div class="line">    Parent.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"hello "</span> + <span class="keyword">this</span>.name + <span class="string">",now is "</span> + <span class="keyword">this</span>.age);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> Parent;</div><div class="line">&#125;());</div><div class="line"><span class="keyword">var</span> Son = (<span class="function"><span class="keyword">function</span> (<span class="params">_super</span>) </span>&#123;</div><div class="line">    __extends(Son, _super);</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">msg, age</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> _super.call(<span class="keyword">this</span>, msg, age) || <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    Son.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"hello I'm Son. next is my Parent's say"</span>);</div><div class="line">        _super.prototype.sayHello.call(<span class="keyword">this</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> Son;</div><div class="line">&#125;(Parent));</div><div class="line"><span class="keyword">var</span> sapi = <span class="keyword">new</span> Son(<span class="string">'peanut'</span>, <span class="number">10</span>);</div><div class="line">sapi.sayHello();</div></pre></td></tr></table></figure></p>
<p>有点厉害，我先坐下来……</p>
<p>先是构造了个链子，然后（那个是闭包污染处理嘛…）…… 说不清了……</p>
<p>反正看子类，很明显在“Son类”结束前，有一个<code>(Parent)</code>，虽说ts对于类的处理都是一个大个的及时运行函数，但是”parent”运行时并没有带参数，而”Son”带了它的爹，如果我的理解的是对的的话，就是”Son”在运行的时候把”Parent”带着运行一次起到“继承”的效果。最后还是照原型链的理解。</p>
<h3 id="关于JavaScript的其他继承"><a href="#关于JavaScript的其他继承" class="headerlink" title="关于JavaScript的其他继承"></a>关于JavaScript的其他继承</h3><p>还是因为我的爬虫小记中的现世界宝可梦数量及其名字的项目中，用到了<code>.call(this)</code>这个函数句。所以在想，是否可以使用构造函数走一波继承？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'this is a'</span>)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    a.call(<span class="keyword">this</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后调用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b()     <span class="comment">//this is a</span></div></pre></td></tr></table></figure></p>
<p>所以也是可以的。结束！</p>
]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[async-await 初尝试]]></title>
      <url>/PersonalBlog/2017/02/17/async-await-first/</url>
      <content type="html"><![CDATA[<blockquote>
<p>把去年在github的处作改造了一次。方便日后react学习… 另外我想换个主题了，这次用心做然后推入hexo themes。</p>
</blockquote>
<p>想起去年第一个放在github的东西，就是获取课程然后下载课程视频的下载器。<br>然后今天，想到弄一个服务端版本。这样我可以无论作为移动端还是webapp端都能用到爬虫的数据了。所以就做了一次改造。<br><a id="more"></a><br>github地址：<a href="https://github.com/ColMugX/ImoocDownloader/tree/server" target="_blank" rel="external">ColMugX/ImoocDownloader at server</a><br>地址跟ImoodDownloader一样，放在同一个项目里。多开了一个server版本分支。归类方便吧！</p>
<h3 id="ImoocDownloaderServer-请求样本"><a href="#ImoocDownloaderServer-请求样本" class="headerlink" title="ImoocDownloaderServer 请求样本"></a>ImoocDownloaderServer 请求样本</h3><p>请求之后样本大概是这样的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"code"</span>: <span class="number">200</span>,</div><div class="line">  <span class="string">"Info"</span>: &#123;</div><div class="line">    <span class="string">"title"</span>: <span class="string">"使用Struts2+Hibernate开发学生信息管理功能"</span>,</div><div class="line">    <span class="string">"author"</span>: <span class="string">"milanlover"</span>,</div><div class="line">    <span class="string">"job"</span>: <span class="string">"JAVA开发工程师"</span>,</div><div class="line">    <span class="string">"classTime"</span>: <span class="string">"2小时35分"</span>,</div><div class="line">    <span class="string">"classValue"</span>: <span class="string">"高级"</span>,</div><div class="line">    <span class="string">"classInfo"</span>: <span class="string">"简介：本课程通过学生信息管理功能的开发，来介绍Struts2和Hibernate的整合。主要内容包括：Struts2和Hibernate整合，用户登录模块和学生信息管理模块的设计和实现。通过本课程的学习，一定会使小伙伴们的Java Web开发技能更上一层楼。"</span>,</div><div class="line">    <span class="string">"classKn"</span>: <span class="string">"各位小伙伴，学习本课程前需要对\r\nStruts2和Hibernate的基础知识有所了解。"</span>,</div><div class="line">    <span class="string">"classWh"</span>: <span class="string">"1、掌握Struts2和Hibernate的整合开发\r\n2、能够使用Struts2+Hibernate独立开发信息管理类的项目，进行数据的增删改查。"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"Video"</span>: &#123; ... &#125;</div></pre></td></tr></table></figure></p>
<p>解析完采用json格式进行输出，这是app最好的数据来源方式有木有！所以这样就更方便做APP了。而且这估计也是我第一次正式后端入门吧。<br>至于imoocdownloader这个名字，随便吧毕竟不能算是很好的作品，所以不重新起名字了。</p>
<h3 id="小谈ES6和ES7"><a href="#小谈ES6和ES7" class="headerlink" title="小谈ES6和ES7"></a>小谈ES6和ES7</h3><p>node更新到了v7.4，毋容置疑ES2016也就是顺势ES7也得到支持了，对于js或者说nodejs这种全靠异步吃饭的服务端有时候也是个很大的问题。<br>js是很经典的函数式语言，至少我这么觉得。函数式编程自然逃不过回调地狱…再加上nodejs这种非阻塞多并发的操作方式有时候确实是一种难题。（我的爬虫小记项目中的宝可梦基本数据爬虫<strong>已经是车祸现场</strong>了。）</p>
<p>按道理说，并没有ES6和ES7这种称呼，ESX最多只延续到了ES5。因为从ES1~ES5实际上都是ECMA-262的版本。根据百度百科</p>
<blockquote>
<p>ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。</p>
</blockquote>
<p>而到了ES6并不是叫ES6了，ECMA开始使用年份来命名，比如<code>ECMAScript 2015</code>，和<code>ECMAScript 2016</code>。1到5只是因为编号太长加上该编号一直在迭代。实际上该标准里面有两个语言，但渐渐的由于微软各种不给看好和JavaScript实在名声太大，所以变成了ES-262的扛把子。到了es2015我觉得已经变成一种跟JavaScript关系不大的语言了。虽然还有种<strong>“如果es6取代了js，那么就把es6改名为js”</strong>的说法。不过也不是不可行~</p>
<p>而ES6增加的内容和改变的内容实在太多了。多了类型的定义方式不再需要下划线约定俗成；简单的括号函数取代闭包函数臃肿的写法（不过括号函数不存在this，以后有机会掰扯。以前不懂事以为反正都一样，之后在微信小程序吃尽苦头）；引入了类的定义再也不需要被es5使用者各种邪魔化（在es6之前我唯一懂的es5对类的定义写法就是<code>new object()</code>）。</p>
<p>其实看到了es6之后，我就在后悔为什么当时不好好使用typescript和使用ts，这样的话到es6普及时我也可以成为扛把子了（逃。</p>
<p>所以ES6和ES7的说法，应该是因为ES5被叫顺口了，再说ES2015确实太长，那么顺位下来叫ES6也行，反正都懂就行了。</p>
<p>而ES2016不比ES2015，TMD竟然就只加入了一个能用的特性：<code>async-await</code>。</p>
<h3 id="浅谈promise-和-async-await"><a href="#浅谈promise-和-async-await" class="headerlink" title="浅谈promise 和 async-await"></a>浅谈promise 和 async-await</h3><p><code>promise</code>是es6的特性，<code>async-await</code>是es7的特性。前者在es6的学习中被我直接忽视了…觉得用不到而且不知道怎么用。但是在async出现之后，意识到promise的作用，而且我认为他们才是天造地设，缺一不可。<br>es6时代的时候据说也是邪魔写法很多，使用promise解决同步问题，再到后面有Generator函数的说法。最后都并不理想。毕竟语言这东西，如果有原生支持肯定是再好不过了。就跟Android一样，如果原生安卓在这片大陆上能正常使用的话体验肯定比现在任何XUI舒服。</p>
<p>作为异步程序同步处理，async/await也有矫情的地方，后者只能出现在有前者的上下文中，单独不可使用。而await只能用在promise的函数上面，用在其他函数上也行只不过没作用，还是瞬发还是异步。</p>
<h3 id="为什么需要P-A-，我用在哪里了"><a href="#为什么需要P-A-，我用在哪里了" class="headerlink" title="为什么需要P/A+，我用在哪里了"></a>为什么需要P/A+，我用在哪里了</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> msgGet = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">        request.get(url, <span class="function"><span class="keyword">function</span>(<span class="params">err, res, body</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err);</div><div class="line">                resolve(body);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先在查询那部分已经使用到了，因为异步的关系，文件内所有函数几乎都是在同一时间请求（高并发），所以这就导致可能有某种情况：<strong>劳资TMD等着第一个函数执行完得到个值用在第二个函数中计算，等第一的数据准备就绪的时候，第二的老人家竟然告诉我我早在1s前已经完成工作了。请问你拿什么在完成工作！</strong><br>所以就这样，在请求的数据还没到的时候，下面早早把空值传入下一步的操作中了，自然什么都没有，毕竟传值这工作比请求好完成。所以这就体现到需要同步解决的重要性了，“你必须要等你前面的人进去之后你再进去，不能插队！”</p>
<p>而且，虽然new了，这是一个Promise对象，但是它可以直接去到值，直接取出resolve。不过怎么说，看下面：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fi = <span class="keyword">await</span> msgGet(url);     <span class="comment">//得到msgGet(url)的值</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">await</span> msgGet(url)); <span class="comment">//输出Promise &#123;&lt;padding...&gt;&#125;</span></div></pre></td></tr></table></figure></p>
<p>通过变量定义之后，获取的值是可以进一步使用的，可以丢入下一个函数进行下一步工作。不需要<code>.then()</code>。但是如果要它直接打印出来就不可能了！因为上面已经说了，这是一个对象并不是一个可直接使用的数值。只有其他函数可以直接get到对象的内容，而没办法直接显示。需要像第二种的方式只能是：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fi.then(<span class="function">(<span class="params">m</span>)=&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(m);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这样操作才能得到真正里面的东西。take it off。不过这样也就依然跌入回调地狱…<br>而到了视频地址解析那部分的时候，由于需要去请求视频地址，同样又出现了相同的情况。但是调用我是在查询的位置调用，在这里<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//app.js</span></div><div class="line">    allMsg[<span class="string">'Info'</span>] = classData;</div><div class="line">    allMsg[<span class="string">'code'</span>] = <span class="number">200</span>;</div><div class="line">    allMsg[<span class="string">'vidic'</span>] = viDic;</div></pre></td></tr></table></figure></p>
<p>如果我不是把视频数据向前传，而是在里面直接调用操作的话。就第一次尝试那样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vidInfo = getVideoUrl(viDic);</div><div class="line">allMsg[<span class="string">'Info'</span>] = classData;</div><div class="line">allMsg[<span class="string">'code'</span>] = <span class="number">200</span>;</div><div class="line">allMsg[<span class="string">'video'</span>] = vidInfo;</div></pre></td></tr></table></figure></p>
<p>反正差不多吧我忘记了……到后面取值输出的时候就是这样的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"code"</span>: <span class="number">200</span>,</div><div class="line">  <span class="string">"Info"</span>: &#123; ... &#125;</div><div class="line">  <span class="string">"video"</span>: &#123;<span class="built_in">Promise</span> &#123; &lt;padding...&gt; &#125; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>什么都取不到玩腿毛？<br>所以后来就抖了个小聪明，把整理完的视频信息往回传，在前面<code>.then()</code>操作之后取出真实数据再去请求，再得到数据再<code>.then()</code>一次，获得所有真实数据再反馈出来。得到现在要的所有数据。最后一步 send到express。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">msg.then(<span class="function">(<span class="params">data</span>)=&gt;</span> &#123;</div><div class="line">    <span class="keyword">var</span> s = &#123;&#125;;</div><div class="line">    <span class="keyword">if</span> (!data[<span class="string">'err'</span>]) &#123;</div><div class="line">        <span class="keyword">var</span> vidInfo = getVideoUrl(data[<span class="string">'vidic'</span>]);</div><div class="line">        vidInfo.then(<span class="function">(<span class="params">v</span>)=&gt;</span> &#123;</div><div class="line">            <span class="keyword">let</span> s = &#123;&#125;;</div><div class="line">            s[<span class="string">'code'</span>] = data[<span class="string">'code'</span>];</div><div class="line">            s[<span class="string">'classID'</span>] = id;</div><div class="line">            s[<span class="string">'Info'</span>] = data[<span class="string">'Info'</span>];</div><div class="line">            s[<span class="string">'Video'</span>] = v;</div><div class="line">            res.send(s);</div><div class="line">            <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'request finish'</span>)</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>结束。</p>
]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自己造轮子！——Syuanpi.css]]></title>
      <url>/PersonalBlog/2017/02/13/Syuanpi-css/</url>
      <content type="html"><![CDATA[<p>本来首发知乎，再说了现在这东西又不需要怎么用了，各种前端框架各种自动化，这些东西早就带得干干净净了。<br>这是demo的页面：<a href="https://colmugx.github.io/Syuanpi.css">Syuanpi.css</a><br>这是GitHub的页面：<a href="https://github.com/ColMugX/Syuanpi.css" target="_blank" rel="external">ColMugX/Syuanpi.css: ✨A library of CSS animations.</a></p>
<p>说到CSS动画库，其实有一个很出名很好用，“就像喝水一样简单”的叫做Animate.css的开源库子。那些动画真的挺炫酷的。然后我就想起，我自己在玩Hexo主题的时候不是动画也是自己写么，那要不把用过的动画自己封装起来，然后再加点跟自己脑洞产物的动画，然后自己也做一个库试试？然后我就把Syuanpi.css弄出来了…作为练习产物，日后想到什么好玩的实现方式也是会一直加一直加~ 不过我要说实话：不排除把Animate.css出现的部分动画自己再实现一遍进自己库子！</p>
<h3 id="为什么要出这东西…"><a href="#为什么要出这东西…" class="headerlink" title="为什么要出这东西…"></a>为什么要出这东西…</h3><a id="more"></a>
<p>在知乎看了一段时间了认识了kpi这东西，觉得这东西好坑啊233，导致我现在觉得kpi的意思就是：有现有轮子不要用！不管怎样自己用的东西能做成轮子就给它做成轮子！然后再用自己的轮子！然后kpi就啪啪啪的往上走！不过这库子我的出发点还是想把我原来弄的一些基础的动画归类起来，加上自己比较会常用的操作封装起来，仅此而已。<br>在知乎学习的过程，就有一个关于没工作经验然后怎么面试的问题。就有提到关于自己开源自己的代码，不是不负责任的像托管作业一样把乱七八糟的东西放上去然后就说“噢！劳资也有开源”这样，至少要有一个给人一种便捷操作，要有头有尾，还要会写文档，不会写给个README也行。然后我也没经验，就听话这么做了…</p>
<h3 id="它是个什么东西…"><a href="#它是个什么东西…" class="headerlink" title="它是个什么东西…"></a>它是个什么东西…</h3><p>好了说回来我的东西~ Syuanpi意思很简单，我喜欢它日后可以炫得一批233。但是它并不炫，而是一些很基础很基础的动画用法。不过，一些稍微认真的网站不就要点轻转场就行了嘛。比如我觉得博客挺认真的，但是没有转场动画又觉得好干燥，所以我的大部分动画起始点都是基于在自己博客上面用。而且动画的过程速度和位置全靠目测！不会计算也是硬伤呀…用的是stylus，不知道为什么总觉得那个被那个绿色的长的 ∮ 撩到了，然后就这么用了。<br>认认真真做作业，不要搞什么大新闻。就像标题说的，针对自己脑洞的产物。不过由于是自己第一次比较成型的“自己的作业自己做”，我还是好高兴的。如果有人愿意给star就更好了，还没体验过被5个star砸死是什么感觉呢~（不贪心的好孩子~）<br>嗯！该讲说明书了！大份说明书在GitHub的头页README.md，所以就不讲了！</p>
]]></content>
      
        <categories>
            
            <category> 实践尝试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Syuanpi </tag>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[更新全局NPM的所有可更新包]]></title>
      <url>/PersonalBlog/2016/12/09/update-npm-packages/</url>
      <content type="html"><![CDATA[<p>今天在通过<code>vue-cli</code>创建一个新工程的时候，那个提示说有新版本要更新。对于一个有“工具更新强迫症”的人自然有点受不了（除开python），所以就尝试更新。<br>然后发现，项目内更新就<code>npm update &lt;name&gt;</code>就更新了，全局好像不知道怎么弄。然后就自作聪明的<code>npm update -g vue-cli</code>（当然mac宝宝们有个sudo），然后发现卡了好久之后才开始读条，这个时候我就方了，“这个命令到底能不能用？”<br>事实证明是能用的！<code>vue-cli</code>更新好了。<br>但是通过这个之后，我就想了，我电脑里还有没有其他没更新的包…然后我就想查出来一并更新了<br>于是查了一下，说不定日后还得用，做个记录。<a id="more"></a></p>
<h3 id="通过npm的cli更新"><a href="#通过npm的cli更新" class="headerlink" title="通过npm的cli更新"></a>通过npm的cli更新</h3><p>后来在某个同性交流平台sf找到了，说<code>npm</code>在<code>2.6.1</code>之后有一个代码叫<code>npm install -g</code>。可以升级全部包。<br>然后我试了一下。</p>
<blockquote>
<p>eisdir EISDIR: illegal operation on a directory, read<br>npm ERR! eisdir This is most likely not a problem with npm itself<br>npm ERR! eisdir and is related to npm not being able to find a package.json in<br>npm ERR! eisdir a package you are trying to install.</p>
</blockquote>
<p><strong>？？？</strong>我有一句MMP*******</p>
<p>先查找npm 有多少包需要更新吧，命令是<code>npm -g outdated</code>，这个就正常了。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Package</span>           Current        Wanted  Latest  Location</div><div class="line">cordova             <span class="number">5</span>.<span class="number">4</span>.<span class="number">1</span>         <span class="number">6</span>.<span class="number">4</span>.<span class="number">0</span>   <span class="number">6</span>.<span class="number">4</span>.<span class="number">0</span>  </div><div class="line">egret             MISSING         <span class="number">1</span>.<span class="number">0</span>.<span class="number">1</span>   <span class="number">1</span>.<span class="number">0</span>.<span class="number">1</span>  </div><div class="line">ionic       <span class="number">2</span>.<span class="number">0</span>.<span class="number">0</span>-beta.<span class="number">23</span>  <span class="number">2</span>.<span class="number">1</span>.<span class="number">0</span>-beta.<span class="number">3</span>  <span class="number">2</span>.<span class="number">1</span>.<span class="number">14</span>  </div><div class="line">ios-sim             <span class="number">5</span>.<span class="number">0</span>.<span class="number">6</span>        <span class="number">5</span>.<span class="number">0</span>.<span class="number">12</span>  <span class="number">5</span>.<span class="number">0</span>.<span class="number">12</span>  </div><div class="line">npm                <span class="number">3</span>.<span class="number">3</span>.<span class="number">12</span>         <span class="number">4</span>.<span class="number">0</span>.<span class="number">5</span>   <span class="number">4</span>.<span class="number">0</span>.<span class="number">3</span>  </div><div class="line">typescript          <span class="number">1</span>.<span class="number">8</span>.<span class="number">9</span>         <span class="number">2</span>.<span class="number">1</span>.<span class="number">4</span>   <span class="number">2</span>.<span class="number">1</span>.<span class="number">4</span>  </div><div class="line">typings             <span class="number">1</span>.<span class="number">3</span>.<span class="number">3</span>         <span class="number">2</span>.<span class="number">0</span>.<span class="number">0</span>   <span class="number">2</span>.<span class="number">0</span>.<span class="number">0</span>  </div><div class="line">webpack            <span class="number">1</span>.<span class="number">13</span>.<span class="number">3</span>        <span class="number">1</span>.<span class="number">14</span>.<span class="number">0</span>  <span class="number">1</span>.<span class="number">14</span>.<span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>然后我又自作聪明了一下，<code>npm update -g</code><br>然后依然是卡了一下，然后就读条……<br>然后就全部更新完成。</p>
<h3 id="通过npm-check"><a href="#通过npm-check" class="headerlink" title="通过npm-check"></a>通过npm-check</h3><p>其实还看到了一种方法，是在终端里面的GUI工具，可以直观看到哪些需要更新然后可以顺便更新掉<br>当然需要安装，<code>npm-check</code></p>
<blockquote>
<p>npm install -g npm-check （mac宝宝们别忘记sudo）</p>
</blockquote>
<p>检查npm包的状态:</p>
<blockquote>
<p>npm-check -u -g</p>
</blockquote>
<p>然后就移动光标来选择和操作。</p>
]]></content>
      
        <categories>
            
            <category> 日常吐槽 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NodeJS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[扣肉小记（五）—— 你的名字。]]></title>
      <url>/PersonalBlog/2016/12/02/Korou5/</url>
      <content type="html"><![CDATA[<blockquote>
<p>我早已不记得你的名字，但我记得我喜欢你。</p>
</blockquote>
<h3 id="这是一篇不一样的“扣肉小记”"><a href="#这是一篇不一样的“扣肉小记”" class="headerlink" title="这是一篇不一样的“扣肉小记”"></a>这是一篇不一样的“扣肉小记”</h3><p>　　<strong><em>《你的名字。》，记不起“你的名字。”</em></strong><br>　　这次的音乐是这个：</p>
<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="http://music.163.com/outchain/player?type=2&id=426881503&auto=0&height=32"></iframe><br>（一共8分钟）<br>　　今天的小记不一样，今天的小记多了副标题，因为，今天看了场电影。<br>　　今天国内放映《你的名字》第一天，我去把今天的第一场刷了。<br><span style="color:#a5a5a5">　　每次都用心写博客，甚至忘记了技术博客的本来含义。就为了以后翻看的时候不后悔。</span> <a id="more"></a></p>
<h4 id="一次未知的身体交换，换来未知的迷惑"><a href="#一次未知的身体交换，换来未知的迷惑" class="headerlink" title="一次未知的身体交换，换来未知的迷惑"></a>一次未知的身体交换，换来未知的迷惑</h4><p>　　已经不知道如何形容心情。<br>　　可能是因为三叶向往大城市，也有可能是神灵听到了三叶的呼声。他说他想变成东京的帅哥，结果在梦里真的成了。<br>　　但是那个梦又好像是真实的，就这么半梦半醒的状态下，跟东京另外一个帅哥泷交换了身体。<br>　　于是，就有了“一周有几天会交换身体，各自要过对方的生活而且不能被发现”的体验。</p>
<blockquote>
<p>- “你怎么打这么多份工啊！”<br>- “还不是因为你乱花钱！”</p>
</blockquote>
<p>　　就这么互相嫌弃，隔着两个世界小打小闹。为了不露馅，他们彼此在对方手机留下了日记。并通过笔来互相传达自己想说的话。<br>　　但是，虽说是半梦半醒，但梦毕竟是梦，而且梦一醒，就会逐渐淡忘梦里的内容。<br>　　就在一天，三叶帮泷喜欢的女孩子促成了一次约会，而泷带着三叶的身体去见了一次神明……</p>
<blockquote>
<p>- “他们现在一定在一起了吧”<br>  - “我真的是在做梦吗”</p>
</blockquote>
<p>　　就这么一次偶然的情况，梦醒了……这一醒，或许就要失去什么……<br>　　于是泷决定要去找三叶，三叶也想去找泷，就这样，一个人去了小镇，一个人去了城市。就在这个时候</p>
<p>　　<strong>三叶遇到泷的时候，泷并不认识三叶！<br>  　　而泷去找三叶的时候，才知道小镇三年前就毁了！</strong></p>
<h4 id="三年前我不认识你，三年后我遇不到你"><a href="#三年前我不认识你，三年后我遇不到你" class="headerlink" title="三年前我不认识你，三年后我遇不到你"></a>三年前我不认识你，三年后我遇不到你</h4><p>　　满脑子都是“不可能”的泷尝试翻看手机里三叶留下来的日记，才发现…</p>
<p>　　<strong>那 根本不存在</strong></p>
<p>　　翻查三年前小镇陨石事件的泷，在死亡花名册看到了“宫水三叶”的泷，不相信这一切都是真的。但是看到了自己的手绳。<br>　　这是一场“三年前三年后”的梦…<br>　　后来泷想起了自己放在神坛的“口嚼酒”，和一叶的提示“那是三叶的一半”。于是泷决定去神坛，为了挽救三叶。</p>
<blockquote>
<p>- “既然是三叶的一半，那喝一口是不是能看到更多？”</p>
</blockquote>
<p>　　之后，泷才知道，这场跨越三年的邂逅：是三年前的三叶跟自己交换了身体，并去找过自己。而不知情的自己只留下了头绳。</p>
<h4 id="你-叫什么？"><a href="#你-叫什么？" class="headerlink" title="你 叫什么？"></a>你 叫什么？</h4><p>　　泷借着三叶的身体回到了陨石坠落的那一天。从一叶得知宫水家的女性都会有这样的梦。但每一代都不信陨石会坠落。<br>　　急着挽救小镇的三叶用尽各种方法，而且总有一种奇怪的感觉在驱使着她。<br>　　三叶借着泷的身体，看到了三年后的小镇：<strong>那是一片废墟。</strong><br>　　<br>　　总有一股奇怪的感觉，驱使着他们。而且他们都想到了同一个地方：神体</p>
<blockquote>
<p>- “互相留下自己的名字吧，我不想梦醒了，忘记了。”</p>
</blockquote>
<p>　　他们在湖中心，隔着三年时空相遇了。身体换回来了，他们的对话机会时间，只有黄昏。<br>　　于是，泷在三叶手上留下了“だすき”</p>
<p>　　而三叶 <strong>只在泷手上留下了“み”（みつは）的“-”</strong></p>
<blockquote>
<p>- “只要记住你的名字，不管你在世界的哪个地方，我一定会去找你。”</p>
</blockquote>
<h4 id="我找了你五年，而你却等了我八年"><a href="#我找了你五年，而你却等了我八年" class="headerlink" title="我找了你五年，而你却等了我八年"></a>我找了你五年，而你却等了我八年</h4><blockquote>
<p>- “真的不会忘记了，真的不会了！三叶！我记住了！みつは！”<br>　“等一下！你叫什么！你叫…什么… 我 为什么在这里…”</p>
</blockquote>
<p>　　为了“不知道”的泷找了“不知道”，一直找一直找，直到大学毕业。<br>　　三叶 为了泷 救了镇上的人，顺利读完高中大学，也毕业了，来到了东京。</p>
<p>　　为了寻找自己的“不知道”的两个人，就算擦肩而过也不知道吧……</p>
<p>　　但是他们彼此有感觉，他们知道，谁是他们要找的人。</p>
<blockquote>
<p>- “我 好像在哪里见过你？”<br>- “我也是”<br>– “君の名前は？”</p>
</blockquote>
<p>—— “我找了你五年，谢谢你等了我八年”</p>
<p>终于，在同一个时空相遇了……</p>
]]></content>
      
        <categories>
            
            <category> 日常吐槽 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 扣肉小记 </tag>
            
            <tag> 看片子 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[扣肉小记（四）]]></title>
      <url>/PersonalBlog/2016/11/25/Korou4/</url>
      <content type="html"><![CDATA[<blockquote>
<p>天气转凉…基本是条冻狗了<br>另外小嘀咕一句：有点想把“Rousy”重写了…</p>
</blockquote>
<p>　　好久没有写过扣肉系列的故事了，“扣肉”系列有两个特点，第一个是有分段，每一段前面有缩进！（Markdown不支持缩进一开始我还想了各种各样的办法）第二个就是每一篇后面都有个音乐啦！（反正不想看就翻到最后听音乐啊）</p>
<h3 id="最近干了个长得像个音乐播放器的微信小程序"><a href="#最近干了个长得像个音乐播放器的微信小程序" class="headerlink" title="最近干了个长得像个音乐播放器的微信小程序"></a>最近干了个长得像个音乐播放器的微信小程序</h3><a id="more"></a>
<p>　　最近干什么，最近学的前端知识好多，每天都是百度和知乎（暂时不需要用到Google系列），然后就是写了一个微信小程序(weapp)<br>　　反正到现在来说，<code>weapp</code>还是挺好玩的，而且那个<code>wxml</code>和<code>wxss</code>就理解成<code>html</code>和<code>css</code>就好了。然后那个<code>js</code>是用的ES6，身边有个大神honn哥，有问题他还是很愿意解答的，谢谢老板罩着！<br>　　然后写了个什么，写了个音乐程序，有个不愿意透露ID的妹妹她自己有个项目，就是“据她口述的盗链音乐播放器”，不过她是用swift写的，而且长得稍微挺像网某云音乐，但链子好像不是某云的…然后我就想那我也来写一个好了<br>　　然后就去看了她的链子，发现她的链子好像不能用了，然后我就自己找了一个某度的链子，能用。反正这些东西以后都开源了！开源大法好！先上个图！<br>  <img src="https://github.com/ColMugX/GitBed/raw/master/blog/weapp-openradio.gif" alt=""><br>　　但是尴尬的是，这套链子，<strong>不支持在线播放</strong>！卧槽这tm就尴尬了。链子拿下来之后，本地播放是可以的，在线播放是播放不了的。然后我就尝试用浏览器去点，点开之后并不是一个<code>html5</code>的<code>audio</code>而是直接<code>download</code>，代码长这样。<br>  <figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"songLink"</span>: <span class="string">"http://yinyueshiting.baidu.com/data2/music/187ccc63d230408fdf39c51e37828e24/266958159/266322598252000128.mp3?xcode=814f6cb1684cf12a84b505fb6b038464"</span>,</div><div class="line">  <span class="attr">"showLink"</span>: <span class="string">"http://yinyueshiting.baidu.com/data2/music/187ccc63d230408fdf39c51e37828e24/266958159/266322598252000128.mp3?xcode=814f6cb1684cf12a84b505fb6b038464"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　而且其实我有想过先down到本地然后在调用播放，后来想了一下，既然是小程序而且是个云端程序，这么玩占用的存储会不会就大了好多…现在只能另辟蹊径了。（为什么我想到了鹅厂…）</p>
<h3 id="暂时没想到什么写的，来听音乐吧！"><a href="#暂时没想到什么写的，来听音乐吧！" class="headerlink" title="暂时没想到什么写的，来听音乐吧！"></a>暂时没想到什么写的，来听音乐吧！</h3><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="http://music.163.com/outchain/player?type=2&id=412493379&auto=0&height=32"></iframe>

<p>　　最近一直在听这首，其实去年就听过了，第一次听觉得很感触，虽说这首歌是TFBOYS的吧！但是我向来都是喜欢好音乐，至于谁唱的，只不过是借用了他的声音来表达歌曲的意义而已。<strong>（除了周杰伦！）</strong> <strong>（除了初音未来！）</strong>（为什么分开讲，因为伦哥的地位无可替代！）<br>　　而且应该是我觉得的tfboys的歌里面唯一一首能听的，歌词真的…不行了…</p>
<blockquote>
<p>我不完美的梦 　你陪着我想<br>不完美的勇气 　你说更勇敢<br>不完美的泪　 　你笑着擦干<br>不完美的歌　 　你都会唱<br>我不完美心事 　你全放在心上<br>这不完美的我 　你总当作宝贝</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 日常吐槽 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 扣肉小记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一次无聊的尝试 —— hexo-theme-blank]]></title>
      <url>/PersonalBlog/2016/11/02/xin-zhu-ti-ce-shi-wan-shan-zhong/</url>
      <content type="html"><![CDATA[<blockquote>
<p>一次Hexo主题的尝试</p>
</blockquote>
<p><strong>我先说好啊！Blank不是SKT T1的打野！</strong><br><strong><a href="/blank.html">主题演示页面点击这里</a></strong></p>
<h3 id="科技以换色为本！"><a href="#科技以换色为本！" class="headerlink" title="科技以换色为本！"></a>科技以换色为本！</h3><h4 id="紫色"><a href="#紫色" class="headerlink" title="紫色"></a>紫色</h4><p><img src="/Image/Blank-violet.jpg" alt="Blank-紫罗兰"> <a id="more"></a></p>
<h4 id="灰色"><a href="#灰色" class="headerlink" title="灰色"></a>灰色</h4><p><img src="/Image/Blank-gray.jpg" alt="Blank-深空灰"></p>
<h4 id="粉色"><a href="#粉色" class="headerlink" title="粉色"></a>粉色</h4><p><img src="/Image/Blank-pink.jpg" alt="Blank-樱语粉"></p>
<h4 id="绿色"><a href="#绿色" class="headerlink" title="绿色"></a>绿色</h4><p><img src="/Image/Blank-green.jpg" alt="Blank-璐璐绿"></p>
<h4 id="蓝色"><a href="#蓝色" class="headerlink" title="蓝色"></a>蓝色</h4><p><img src="/Image/Blank-blue.jpg" alt="Blank-编不下去的蓝色"></p>
<h4 id="红色"><a href="#红色" class="headerlink" title="红色"></a>红色</h4><p><img src="/Image/Blank-red.jpg" alt="Blank-红红火火"></p>
<h4 id="橙色"><a href="#橙色" class="headerlink" title="橙色"></a>橙色</h4><p><img src="/Image/Blank-orange.jpg" alt="Blank-橙子一样的颜色"><br>真是不好意思又开了个坑<br>“方块律动”和“空”为思想的一个主题，同样现在依然是个半成品<br>但怎么说比Rousy（海底世界）好多了吧！</p>
<h3 id="这个主题从写法上，比Rousy改善很多"><a href="#这个主题从写法上，比Rousy改善很多" class="headerlink" title="这个主题从写法上，比Rousy改善很多"></a>这个主题从写法上，比Rousy改善很多</h3><p>怎么来说，Rousy的话，是根据css然后全搬入stylus的，管理性能略差<br>但是Blank的话，我好像不知不觉用了stylus的用法，所以看起来应该…还是不简洁…<br>当然Blank只是半成品，至今只出生后第3天。（都是中午和大半夜，白天有课上）</p>
<h3 id="新主题有没有什么新东西"><a href="#新主题有没有什么新东西" class="headerlink" title="新主题有没有什么新东西"></a>新主题有没有什么新东西</h3><p>肯定有啊！目标实现的效果是，任何操作都是依赖方块来进行，而且即摸即现（标签还没弄好）<br>然后，<strong>可以切换颜色主题了！</strong><br>目前是可以切换两种颜色主题，“灰色跟粉色”，明天应该能支持4种颜色了。<br>当然，我想把颜色接口开放到<code>_config.yml</code>中，然后就可以自定义了！</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[关于微信小程序]]></title>
      <url>/PersonalBlog/2016/10/28/guan-yu-wei-xin-xiao-cheng-xu/</url>
      <content type="html"><![CDATA[<blockquote>
<p>向腾讯大佬低头！</p>
</blockquote>
<p><strong>说在前面，你们这下可不能说我这博客天天吹水不讲东西了！</strong></p>
<h3 id="说说这大佬又想干什么！"><a href="#说说这大佬又想干什么！" class="headerlink" title="说说这大佬又想干什么！"></a>说说这大佬又想干什么！</h3><p>怎么说，腾讯微信真的是野心挺大的，要把微信做成一个应用平台<br>谁还能想的起来微信当时只是定位为一个低流语音信息的即时通讯工具啊！<br>小程序怎么定义呢，就是一个在微信启动的App<br>不过归根到底还是个Web App<br>那这么说来其实也可以说是一个以微信做壳的App了，相对于隔壁那个叫Ionic的东西来说。<br>不过怎么说，这小程序应该也是依托公众号来实现的吧，我看它文档都是在公众号里面。<br>先上地址：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=1474887501214" target="_blank" rel="external">下载链接</a><br>这开发工具原来就是一个chrome开发者工具，可能是因为加了小程序这么个东西，现在也有开发功能了<br>刚刚试用了一下，效！率！贼！差！（默默打开了Atom）<a id="more"></a></p>
<h3 id="这东西大概怎么写怎么用"><a href="#这东西大概怎么写怎么用" class="headerlink" title="这东西大概怎么写怎么用"></a>这东西大概怎么写怎么用</h3><p>我粗略看了一下啊，这东西跟隔壁那些什么<code>angular</code>啊，还有<code>vue</code>啊什么都有点差不多，就是前后绑定然后做逻辑。<br>大概结构就是（不会用树形，随便看一下）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- /</div><div class="line"> - pages</div><div class="line">     - index</div><div class="line">         index.js</div><div class="line">         index.wxml</div><div class="line">         index.wxss</div><div class="line">     - logs</div><div class="line">         logs.js</div><div class="line">         logs.json</div><div class="line">         logs.wxml</div><div class="line">         logs.wxss</div><div class="line"> - utils</div><div class="line">     util.js</div><div class="line"> app.js</div><div class="line"> app.json</div><div class="line"> app.wxss</div></pre></td></tr></table></figure></p>
<p><strong>这结果tm似曾相识啊！</strong><br>好了这就是个Web App，那讲一下那些文件干嘛的呗。<br>说到底还是个老biao子，js就不用说了（哎等下这东西好像还是得依托<code>NodeJs</code>啊，顺便说下我特别不喜欢<code>PHP</code>…）</p>
<p><code>wxml</code>:是个什么，wxml其实就是xml了，只是有点特殊的xml，可以理解成就是我们做ionic那个html吧<br><code>wxss</code>:卧槽了就是这个wxss！卧槽！挑白了说就是个CSS！不过在像素定义有点不同。引用一下</p>
<blockquote>
<p>尺寸单位<br>rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。<br>设备    rpx换算px (屏幕宽度/750)    px换算rpx (750/屏幕宽度)<br>iPhone5    1rpx = 0.42px    1px = 2.34rpx<br>iPhone6    1rpx = 0.5px    1px = 2rpx<br>iPhone6 Plus    1rpx = 0.552px    1px = 1.81rpx</p>
</blockquote>
<p>所以官方说的是，<strong>“我们鼓励使用iphone 6 作为标准屏幕开发”</strong><br>原话是</p>
<blockquote>
<p>建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。 注意： 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。</p>
</blockquote>
<p>（噢…是嘛…</p>
<h4 id="另外最近在学Vue-js，估计跟玩小程序应该也会有点联系吧，就这样了剩下的日后再说。"><a href="#另外最近在学Vue-js，估计跟玩小程序应该也会有点联系吧，就这样了剩下的日后再说。" class="headerlink" title="另外最近在学Vue.js，估计跟玩小程序应该也会有点联系吧，就这样了剩下的日后再说。"></a>另外最近在学Vue.js，估计跟玩小程序应该也会有点联系吧，就这样了剩下的日后再说。</h4>]]></content>
      
        
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[扣肉小记（三）]]></title>
      <url>/PersonalBlog/2016/10/09/Korou3/</url>
      <content type="html"><![CDATA[<blockquote>
<p>怒踹马！你们的狗皇帝回来了！</p>
</blockquote>
<h3 id="今天就随便说说"><a href="#今天就随便说说" class="headerlink" title="今天就随便说说"></a>今天就随便说说</h3><p>　　其实本来想把<em>《扣肉小记》</em>当做日记来写，可是我其实并不太喜欢把自己三次元的生活放出来，所以就当做一个没事吹吹水的小吹比本好了。自从上一篇之后，我就去流浪了，看看电影吃吃饭啊。把<em>《逗鸟外传》</em>和<em>《从你的全世界路过》</em>给刷了。其实我的邪式影评还是挺不错的。（我身边的亲朋还有老婆孩子<i style="color:#ff0000">(？？)</i>）所以看心情写一点邪式影评玩一玩也挺好的。<br>　　所以这几天就什么腿儿都没写了。包括<strong>Rousy</strong><br>　　所以今天依然要写Rousy…<a id="more"></a></p>
<h3 id="所以Rousy写到哪儿了？"><a href="#所以Rousy写到哪儿了？" class="headerlink" title="所以Rousy写到哪儿了？"></a>所以Rousy写到哪儿了？</h3><p>　　这个问题好，本狗也不清楚！反正就是写到了…没个人主页，没友情链接，连微博知乎都没…（这段子手不太专业啊拉出去打死算了）<br>　　其实我是有微博推特这些，可是twitter这个不太爱玩，就是看起来太正经了。微博估计老在别人评论写段子现在上不去那个账号。。。鬼知道那account经历了什么！<br>　　好了其实不是来扯这些儿东西的，其实Rousy我觉得，作为一个博客主题的话它绝对是“妖艳贱货”，但是作为一个个人主页的话，它也是一个“妖艳贱货”，它的视觉和交互可能跟单纯不做作的博客差距很大。毕竟自己的主页嘛，自己玩嗨了就行了，要清新脱俗的推荐两个主题，一个是<a href="http://www.ahonn.me" target="_blank" rel="external">Ahonn</a> 的<a href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="external">even</a>，还有一个是<a href="http://www.yzz1995.cn" target="_blank" rel="external">Yzzting</a> 的<a href="https://github.com/yzzting/hexo-theme-MyFairLady" target="_blank" rel="external">“那名字死命长忘记了”</a> 。<br>　　一个详细介绍，或者说一个场前洗脑就再开一篇来吹吧。毕竟儿童主题…</p>
<p>　　<strong>ＭＤ要是哪天想不开非得改成海底世界不可！叫Rousy多LOW叫Ocean Park吧！</strong></p>
<h4 id="所以今天份的就先吹到这里吧"><a href="#所以今天份的就先吹到这里吧" class="headerlink" title="所以今天份的就先吹到这里吧"></a>所以今天份的就先吹到这里吧</h4><p>今天份的音乐是这个：</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=433103084&auto=1&height=32"></iframe>

<p>这是《从你全世界路过》里面最揪心那段插曲音乐，原版是羽泉的《开往春天的地铁》，片子制作方重新编曲了。<br>然后要感谢一下这曲子的作者（播放器里），网易的独立音乐人之一。因为现在那个曲还找不到原版，这大哥扒带然后重新编曲了，算remix吧大哥。<br>（小小吐槽一下：我曾经也是撸音乐的啊！QAQ）</p>
]]></content>
      
        <categories>
            
            <category> 日常吐槽 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 扣肉小记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[幕课网视频下载器NodeJS版]]></title>
      <url>/PersonalBlog/2016/10/06/Imooc_Downloader/</url>
      <content type="html"><![CDATA[<blockquote>
<p>不能让别人知道我也是会撸工具的（嘘..）</p>
</blockquote>
<p>像我们这么清真的人，一般都是<a href="https://github.com/ColMugX/ImoocDownloader" target="_blank" rel="external">先上链接！</a></p>
<p>其实这是个很早就完成的项目了（9月1日开学日…之前！）</p>
<p><strong>写出来的项目就像嫁出去的女儿，谁说要维护了！我说着玩而已！</strong> <a id="more"></a></p>
<p>好吧讲一下，这东西其实就是一个视频下载器，通过nodejs的命令行进行全部<strong>盗链操作</strong>！</p>
<p>实现过程真的完全粗暴，很粗暴的解决了幕课网（Imooc）的视频下载，输入想要下载的视频编号之后，全自动筛选出视频并下载，下载方式是列表内视频并行下载…</p>
<p><del>P.S.没图！没代码！没食谱！（主题还没有写完，所以关于代码框的东西一概没有，慢慢等吧！）</del></p>
<p>应该没问题了，写一下食谱吧。</p>
<h4 id="三种方法安装（Install）"><a href="#三种方法安装（Install）" class="headerlink" title="三种方法安装（Install）"></a>三种方法安装（Install）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/ColMugX/ImoocDownloader.git ./ImoocDownloader</div><div class="line">Download ZIP</div><div class="line">Open in Desktop</div></pre></td></tr></table></figure>
<h4 id="使用（Usage）"><a href="#使用（Usage）" class="headerlink" title="使用（Usage）"></a>使用（Usage）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd ./ImoocDownloader</div><div class="line">npm install</div><div class="line">node app</div></pre></td></tr></table></figure>
<p>然后按照提示输入各种各样的东西就行了……</p>
]]></content>
      
        <categories>
            
            <category> 后端尝试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> 小作坊 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[扣肉小记（二）]]></title>
      <url>/PersonalBlog/2016/10/04/Korou2/</url>
      <content type="html"><![CDATA[<blockquote>
<p>感觉自己跟一条热狗差不多了！</p>
</blockquote>
<h3 id="不知道为什么，今天天气特别热"><a href="#不知道为什么，今天天气特别热" class="headerlink" title="不知道为什么，今天天气特别热"></a>不知道为什么，今天天气特别热</h3><p>　　本来前几天已经闻到了秋天的气息，甚至闻到了快入冬的气息，结果今天又要开空调了！（摔！<br>　　热得精神不太好…加上自己身体的关系（只要一动脑身体会发热，头发热比较厉害）<br>　　总之就是很难过就对了（捡起来！再摔！<a id="more"></a><br>　　<strong>所以我记得我高三的时候，发烧就跟烧着玩一样。</strong></p>
<h3 id="今天依然在继续写Rousy"><a href="#今天依然在继续写Rousy" class="headerlink" title="今天依然在继续写Rousy"></a>今天依然在继续写Rousy</h3><p>　　懒癌恶性晚期，本来还以为可以悠闲的把一些过度特效给写掉，然后再用点洪荒之力把动画给写了，再加个fancybox啊balabala，然后发现</p>
<p>　　<strong>归！档！和！标！签！是！空！的！</strong></p>
<p>　　这tm就尴尬了。。。<br>　　遥遥无期啊！我现在还慢脑子都是飞来飞去的div呢！</p>
<h4 id="算了今天就写到这吧。今天的音乐听点什么好。"><a href="#算了今天就写到这吧。今天的音乐听点什么好。" class="headerlink" title="算了今天就写到这吧。今天的音乐听点什么好。"></a>算了今天就写到这吧。今天的音乐听点什么好。</h4><blockquote>
<p>什么你说什么时候放出自己的作品？ 噢这样啊！你说的话，我就当随便听一下就好了。</p>
</blockquote>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=399411850&auto=1&height=32"></iframe>

<p>　　<em>或许我以后可以讲点音乐故事？算了以后再说吧（btw，这部动漫很棒，剧场版的）</em></p>
]]></content>
      
        <categories>
            
            <category> 日常吐槽 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 扣肉小记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[扣肉小记（一）]]></title>
      <url>/PersonalBlog/2016/10/03/Korou1/</url>
      <content type="html"><![CDATA[<blockquote>
<p>一个不正经的码狗生活。</p>
</blockquote>
<h3 id="为什么这么说呢？"><a href="#为什么这么说呢？" class="headerlink" title="为什么这么说呢？"></a>为什么这么说呢？</h3><p>　　实际上我真的是个coder，但是我不是那种天天在coding的人。特别是在不是工作鬼缠身的时候。<br>　　这种东西就是心血来潮嘛，突然feel到了然后就死命写一堆出来，然后，啊爽了，然后睡觉。就这样…</p>
<p>　　每天无非就是<a href="http://www.bilibili.com/video/av4033926/" target="_blank" rel="external">吃吃饭，喝喝茶，看看电影，聊聊天，逛逛街，牵牵手，喝喝小酒，开开房</a>（啊不对..）</p>
<p>　　一有新技术，码狗肯定是要接触学习一下，不然跟不上逼格注定被淘汰..虽然我也会看吧，但是不爱做读书笔记，所以，<a id="more"></a></p>
<p>　　<strong>知！道！我！为！什！么！没！东！西！写！了！吧！</strong></p>
<h3 id="好吧，其实我是边写着主题边玩着博客的"><a href="#好吧，其实我是边写着主题边玩着博客的" class="headerlink" title="好吧，其实我是边写着主题边玩着博客的"></a>好吧，其实我是边写着主题边玩着博客的</h3><p>　　博客主题的话，hexo theme 叫rousy的东西，好像是挺女孩子的名字。好吧我坦白…就是…<br>　　就是round 和 style 随便混合起来的一个词，挺喜欢Apple那一套圆角的。<br>　　主题的话应该是做的差不多了，毕竟还想要点duangduangduang的东西。</p>
<h4 id="好了今天份的就差不多这样了…应该还是会分享一些code的东西吧，我可是码狗啊！今天的音乐是"><a href="#好了今天份的就差不多这样了…应该还是会分享一些code的东西吧，我可是码狗啊！今天的音乐是" class="headerlink" title="好了今天份的就差不多这样了…应该还是会分享一些code的东西吧，我可是码狗啊！今天的音乐是"></a>好了今天份的就差不多这样了…应该还是会分享一些code的东西吧，我可是码狗啊！今天的音乐是</h4><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=39956017&auto=1&height=32"></iframe>]]></content>
      
        <categories>
            
            <category> 日常吐槽 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 扣肉小记 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
