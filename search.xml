<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[这是一个失败者的总结]]></title>
      <url>/blog/2019/01/03/my-2018/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这个年终总结的时间是错误的，真正完成的那天远晚于当天。</p>
</blockquote>
<p>我本来还是跟去年一样已经不想写了，但坐着也无事，总结一下今年的事情。</p>
<p>这篇文章诞生于支离破碎的主题中，因为博客主题正在改造，很长时间没更新也是因为改动太大完全收拾不开..</p>
<h2 id="一事无成"><a href="#一事无成" class="headerlink" title="一事无成"></a>一事无成</h2><a id="more"></a>
<p>今年打算完成的内容可以说没有一件完成了：<code>TFD(The Fking Design)</code>，和以此为基础的<code>Nlvi-禅</code>、<code>syuanpi</code>、<code>Sona</code>。以及胡乱开坑的双兔<code>Bunny</code>、<code>Rabbit</code>。还有两个移动应用…… <code>Rabbit</code>可以说已经在公司偷偷用上了。</p>
<p><code>TFD</code> 还是有出的，按照规范出一个<code>Sketch</code>，只不过设计这东西实在太费时间了，可以想象一下，你7点打开<code>Sketch</code>，开一个新组件，调整两条线条，感觉也就过了半小时，抬头，12点了…还有大量内容停留在脑子里没实现，这东西还是要尽快，毕竟如果你没天天去回想的话是会忘记的，比如<code>syuanpi</code>的新效果…</p>
<p>前段时间把<code>syuanpi.css</code>的主页改成新风格，调整了时间栅格和一些过渡不自然，但是很多想法并没有实现。纠结于<code>WAAPI</code>的 JS 版本更是开了个头完全没实现…估计弃坑，正在尝试<code>React</code>版本的场景动画。</p>
<p>新的<code>Nlvi</code>在写了..还是会改布局改风格，逻辑代码部分也会改，现用的搜索和标签云会改掉，归档页打算用瀑布流，场景动画暂时不会去想吧，毕竟之前尝试过结合<code>pjax</code>的场景动画，拉闸了…</p>
<p>主要还是换了个新环境，还以为能跟以前一样浪，实际精力真实跟不上，白天跟孤儿斗智斗勇晚上真的抬不开眼了，连 Switch 都不是很愿意拿。</p>
<p>还是想吐槽自己，今年 GitHub 格子实在太空了…</p>
<h2 id="讲点有意思的"><a href="#讲点有意思的" class="headerlink" title="讲点有意思的"></a>讲点有意思的</h2><p>还是有高兴事的</p>
<p>今年换了新环境，所以现在半个战场转移到这边了，用爱发电（不算KPI）做了几个工具：CLI 和 VSC 插件都有，甚至改了一个超小的状态管理库。而且原本用的是<code>vue</code>技术栈，今年刚好一个机会提出转<code>react</code>，然后整个团队在年底全部转完了。这我还是挺高兴的，<code>react</code>真是一个可以依照思路从头写到尾的框架，<del>而且 vim 也能很好找到支持和补全了（装b更顺利了）。</del></p>
<p>买了个 kindle，看完了很多书很多小说，可以说充实了通勤时间，<del>多次公交坐过站，</del>看非技术和小说还是很上瘾的，但是看技术类真的很容易犯困…所以今年应该调整书籍策略，不要在路上看过于硬核的书，容易犯困又没成效。后来为了支持老罗买了一个坚果Pro2S，在此劝诫能看到这篇文章的人，别买垃圾屏幕的手机，我现在回想起我眼睛废掉的原因大概率是用锤子低背光在车上看东西…这手机挺好的，就是背光不要调低，屏闪真的很伤眼。飞行员视力从今年开始已经不存在了…</p>
<p>说是这么说，在车上还是看完了《Haskell 趣学指南》，看的时候比较兴奋，下车到电脑边实践半小时，断断续续看完。Haskell 确实对今年写代码的思路提升了很多，可以说入门就得到了效果，但还是要多玩，很多核心的思想还没掌握到。</p>
<p>很重要的一点，终于意识到<code>TypeScript</code>的优势了，其实回想起一年前或者两年前的自己，根本不能算上一个程序员，「胶水工程师」都算不上。<code>TS0.5</code>时代就接触到TS，到今天才认识，惭愧不惭愧。</p>
<h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><ul>
<li><p>好好活着，特别现实的想法</p>
</li>
<li><p>少跟孤儿争论一些有的没的</p>
</li>
<li><p>少嫌队友菜，各种意义上的队友…或许太硬核的技术是不必要的</p>
</li>
<li><p>精准打击，不要再做机器学习了！</p>
</li>
<li><p>调整看书策略，总是犯困也不是个事</p>
</li>
<li><p><code>TFD</code>好好做完，还有几个坑依次填完</p>
</li>
<li><p>一些操作还是抽象出工具吧，不要再拿手速自己骗自己了…</p>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> colmugx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一位赌狗前端的自我修养]]></title>
      <url>/blog/2018/11/19/gamble-fn/</url>
      <content type="html"><![CDATA[<p>这两个月工作巨多，直到今天才有时间写点骚东西。</p>
<p>可是要写点什么比较好呢？这时候看到了隔壁桌面上放着一张福彩，我脑子里有画面了。（所以这位赌狗不是我，我不买彩票）</p>
<p>为了方便以后支持更多的彩票，直接搞个类</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Gamble &#123;</span><br><span class="line">    <span class="keyword">static</span> dualColor(red: <span class="built_in">number</span> = <span class="number">6</span>, blue: <span class="built_in">number</span> = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> reds: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">1</span>, <span class="number">33</span>];</span><br><span class="line">        <span class="keyword">const</span> blues: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">1</span>, <span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">this</span>.randomVal(reds, red), <span class="keyword">this</span>.randomVal(blues, blue)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> randomVal(</span><br><span class="line">        fromto: <span class="built_in">number</span>[],</span><br><span class="line">        total: <span class="built_in">number</span>,</span><br><span class="line">        temp: <span class="built_in">number</span>[] = [],</span><br><span class="line">    ): <span class="built_in">number</span>[] &#123;</span><br><span class="line">        <span class="keyword">const</span> [head, ...body] = (!temp.length</span><br><span class="line">            ? [...Array(fromto[<span class="number">1</span>]).keys()]</span><br><span class="line">                  .map(<span class="function"><span class="params">item</span> =&gt;</span> item + <span class="number">1</span>)</span><br><span class="line">                  .splice(fromto[<span class="number">0</span>] - <span class="number">1</span>)</span><br><span class="line">            : fromto</span><br><span class="line">        ).sort(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">return</span> !total</span><br><span class="line">            ? temp</span><br><span class="line">            : <span class="keyword">this</span>.randomVal(body, total - <span class="number">1</span>, temp.concat(head));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 曲苑杂坛 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记在NPM抢空包名的经历]]></title>
      <url>/blog/2018/07/12/kill-parentless-on-npm/</url>
      <content type="html"><![CDATA[<blockquote>
<p>强烈谴责某些大厂，前端或者说 JavaScript 是一个极其依赖社区环境的语言，你们在招人之前能不能先调查一下准新人有没有在社区为非作歹？</p>
</blockquote>
<p>年前想搞定<code>React</code>的时候想了个骚操作：尝试用<code>React</code>的思路去做<code>Vue</code>的事情。又诞生了「Vue生态统一可以聚合」的骚想法，开始产生做<code>Ahri</code>的念头。想着那得搞个 npm 包吧，孤儿上线了。</p>
<p>嘛，在 npm 拿《英雄联盟》英雄名字抢注包名的做法都很弱智了，还“大义凛然”的在描述里写着：<code>League of Legends hero.</code></p>
<p>关于第一次遇到它的时候，我就想算了，重新找合适的名字吧，但后来因为其他原因就搁置了。现在重新回坑，依然遇到这个问题，这次我不忍了，我打算找 npm 肛他！</p>
<a id="more"></a>
<h2 id="寻找入口"><a href="#寻找入口" class="headerlink" title="寻找入口"></a>寻找入口</h2><p>首先看了<code>profile</code>页，发现没有举报入口。（从这里进了Twitter，让人感觉这是一个为了装逼而活着的人。</p>
<p>看看 npm 本身页面有没有什么入口，比如“联系我们”之类的邮箱总有吧，最后在最下面找到了<code>Reporting Abuse</code>。</p>
<p>不得不说 npm 连“因为名字打起来”的可能都想到了，那“因为孤儿操作”应该也会列入其中吧，果不其然。在骚扰举报一栏找到了控空包的情况：如果有用户注册无用空包，或者利用包进行乱七八糟的活动，可能有两种措施：ban 了这个用户；清除这些东西。</p>
<p>我一看到可以 ban 了他我就可兴奋了，于是，发邮件走起。</p>
<h2 id="采取行动"><a href="#采取行动" class="headerlink" title="采取行动"></a>采取行动</h2><p>操起我400分的4级水平英语，就开始写。</p>
<blockquote>
<p>hi,<br>here a profile page: xxxxxx.</p>
<p>this account keep a lot of empty packages which name as a role name in a game, it cause difficulty for me.</p>
<p>I NEED HELP! THANK YOU!</p>
</blockquote>
<p>过了一会收到回信：</p>
<blockquote>
<p>Our support hours are Monday through Friday, 9:00AM - 6:00PM PST, excluding US holidays.</p>
<p>Your request is being reviewed by our support staff and we’ll be responding soon.</p>
<p>To add additional comments, reply to this email.</p>
</blockquote>
<p>噢，没在工作时间还行。过了几秒又收到一封邮件：</p>
<blockquote>
<p>Hey there,</p>
<p>Thank you for reaching out. We hope you’re having a great week thus far, and are looking forward to responding to your request.</p>
<p>The npm support staff will be off on Wednesday, July 4th in observance of Independence Day. Due to this, you may experience some delay in expected reply times.</p>
<p>Thanks for your patience.</p>
</blockquote>
<p>狗屎还带放假的？美国员工真的舒服啊，不加班，节假日放满。像我们这种997节假日还放不满的简直受到了6把无尽的暴击。</p>
<p>等了几天发现不对，没理我，再按照第一封发了一次，这次过了半天多才回。这次差点就怕我气到了，大概的意思就是你上次的 ticket 还没解决，如果你没问题了我们就关了。。。美国人上班都这么摸的？</p>
<p>又过了半天收到一封邮件，这次是技术客服（邮件是有人名的大佬）发来的：</p>
<blockquote>
<p>Thanks for reaching out.</p>
<p>I was not able to find an account associated with (我发信的邮箱). Was there a specific one of these user’s package names you are interested in for a project?</p>
<p>If so, we may assist you with a transfer request or granting access to that package, depending on the package and contents.</p>
</blockquote>
<p>有点着急，看了第一句之后，下面没仔细看，就有点想搞他，我就回信了。信的内容大概是这样：谢谢你的回复。这是我的项目名字（发了<code>Ahri</code>的GitHub Repo），这是我的 npm 账号（意识到发信的账号不对）。我对<code>Ahri</code>有兴趣，但他是个空的而且被占用了，我没办法使用，对吧？还有这个 B 恶意占用了大量的空包（跟上孤儿账号），他是不是同时违反了规则，是不是应该有所动作？</p>
<p>第二天（有时差），收到了回信，说包名已经转移到我的账号上：</p>
<blockquote>
<p>Thanks for getting back to me with that information.</p>
<p>It’s all yours now, but you won’t be able to re-use any version numbers used by the previous author. In fact, I’d suggest publishing your first update as a major release, i.e., v1.0.0. Please publish an update to the package as soon as possible with your code.</p>
</blockquote>
<p>我上了我的 npm 看了一眼，惊了..这就拿到了..</p>
<p>但并没有解放其他的空包和 <strong>ban 了他</strong>，这点我有点失望。总之，要到想要的包，这才是想要的结果。</p>
]]></content>
      
        <categories>
            
            <category> 曲苑杂坛 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> colmugx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我就写个方法，这么麻烦？]]></title>
      <url>/blog/2018/07/04/different-function/</url>
      <content type="html"><![CDATA[<p>最近想到一个问题：为什么JavaScript定义一个函数有那么多种形式，是历史残留还是为了装逼？研究了一下发现还是有区别的。</p>
<p>JavaScript中定义一个方法主要可以分成两种形式：</p>
<ul>
<li>函数声明</li>
<li>函数表达式</li>
</ul>
<a id="more"></a>
<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>声明体是最普通的，其他语言也相近的一种方式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>不过，毕竟是「函数就是爸爸」的JavaScript！它有一个特性：函数提升。</p>
<blockquote>
<p>函数提升：把所有函数提升到当前作用域上，从而做到了可以“未声明先调用”。</p>
</blockquote>
<h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><p>这可能是目前用的最多的声明方式，因为可以搭配箭头函数假装自己用的是函数式编程。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数版本</span></span><br><span class="line"><span class="keyword">const</span> funcA = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>但变量受作用域影响，所以<code>const</code>和<code>let</code>并没有变量提升的能力。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">funcA(<span class="number">1</span>) <span class="comment">// ReferenceError: funcA is not defined</span></span><br><span class="line"><span class="keyword">const</span> funcA = <span class="function"><span class="params">a</span> =&gt;</span> a</span><br></pre></td></tr></table></figure></p>
<p>燃鹅，这才刚刚开始……</p>
<h3 id="匿名-amp-具名"><a href="#匿名-amp-具名" class="headerlink" title="匿名 &amp; 具名"></a>匿名 &amp; 具名</h3><p>匿名就是上面那种，具名就是给函数本体再起一个名字。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="keyword">function</span> <span class="title">funcName</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样有什么区别？后面那个名字又不能用！答案还是有区别的。</p>
<p>首先有一个函数名推断，比如上面这个函数，那么<code>func.name</code>会返回<code>funcName</code>。如果匿名函数的话<code>[fn].name</code>会返回<code>&#39;&#39;</code>。其次这个名字可以在函数内部使用。当然了指代的就是自己了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="keyword">function</span> <span class="title">funcName</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &lt; <span class="number">0</span> ? b : funcName(a+<span class="number">1</span>-b, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">431</span>, <span class="number">151</span>) <span class="comment">// 281</span></span><br><span class="line">funcName(<span class="number">431</span>, <span class="number">151</span>) <span class="comment">// ReferenceError: funcName is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(func.name) <span class="comment">// funcName</span></span><br><span class="line"><span class="keyword">typeof</span> funcName === <span class="string">'function'</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>所以这种方式最适合递归函数了。</p>
<h3 id="函数表达式依然是个常-变量"><a href="#函数表达式依然是个常-变量" class="headerlink" title="函数表达式依然是个常/变量"></a>函数表达式依然是个常/变量</h3><p>把它当做一个“方程”来看吧，关键词已经决定了这个“量”会以什么形式存在，比如<code>var</code>和<code>let</code>是变量，<code>const</code>是常量，并且<code>let</code>还有作用域范围。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> funcA = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'A'</span>)</span><br><span class="line">funcA() <span class="comment">// A</span></span><br><span class="line">funcA = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'AA'</span>) <span class="comment">// TypeError: Assignment to constant variable.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funcB = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'B'</span>)</span><br><span class="line">funcB() <span class="comment">// B</span></span><br><span class="line">funcB = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'BB'</span>)</span><br><span class="line">funcB() <span class="comment">// BB</span></span><br></pre></td></tr></table></figure></p>
<p>题外话：那么就有个老生常谈的问题了，函数表达式按道理来讲是“灵活的”，那么下面这个函数会是什么结果？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'B'</span>)</span><br><span class="line">&#125;</span><br><span class="line">funcB() <span class="comment">// BB</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'BB'</span>)</span><br><span class="line">&#125;</span><br><span class="line">funcB() <span class="comment">// BB</span></span><br></pre></td></tr></table></figure></p>
<p>为什么？还是那句话：JavaScript世界中，函数是你爹！</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>又到了大家最最喜欢的箭头函数环节，现在还有谁是不愿意写箭头函数的？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="params">a</span> =&gt;</span> b =&gt; a + b</span><br><span class="line">func(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>在这篇文章：<a href="/blog/2017/03/03/js-this/">《关于JavaScript的this》</a>已经被安排的明明白白了。</p>
<p>实际上现在看这篇文章也有点问题，年轻的时候牛批吹多了。总结箭头函数两个特点就是：</p>
<ul>
<li>不会创造上下文（自身无this）</li>
<li>必然是个匿名函数</li>
<li>没有 <code>arguments</code></li>
</ul>
<p>不是两个吗？怎么变成三个了？此时你可能会回去检查刚刚那句话，然后我现在悄悄告诉你，（第三点是送的）。</p>
<h3 id="计算属性函数名"><a href="#计算属性函数名" class="headerlink" title="计算属性函数名"></a>计算属性函数名</h3><p>这个应该是在“对象”的环境中存在，毕竟对象可以指代很多种只要是对象的情况。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;</span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'b'</span>](a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object.ab(<span class="number">1</span>, <span class="number">3</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>这就实现了“函数名可以暂时不知道是什么”的情况，通过计算来得到这个函数。</p>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="new-Function"><a href="#new-Function" class="headerlink" title="new Function"></a>new Function</h3><p>这是一个不知道哪里可以用得上但是就是可以用的方式：通过对象创建<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'return a + b'</span>)</span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<h3 id="函数参数初始值"><a href="#函数参数初始值" class="headerlink" title="函数参数初始值"></a>函数参数初始值</h3><p>可能有一定需求，但可能没有<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a = <span class="number">1</span>, b = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>可能我们更常用的有这些<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> funcA = <span class="function">(<span class="params">obj = &#123;&#125;</span>) =&gt;</span> obj</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> funcB = <span class="function">(<span class="params">arr = []</span>) =&gt;</span> arr</span><br></pre></td></tr></table></figure></p>
<p>但JavaScript毕竟是「函数是第一公民」的语言，有机会会写到很多高阶函数。所以<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function">(<span class="params">fn = (</span>) =&gt;</span> <span class="string">'💉💧🐮🍺'</span>) =&gt; fn.call(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure></p>
<p>凭什么函数作为参数就不能有初始值呢？当然是可以的呀！</p>
]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vue watch存在永动吗？]]></title>
      <url>/blog/2018/03/16/vue-watcher/</url>
      <content type="html"><![CDATA[<p>因为<code>watch</code>就是，数据只要没变化就不会触发，先后数据对比是一样的就没必要更新了。所以永动是不可能永动的，这辈子都不可能永动的。</p>
<p>但是如果会遍历一个表，每跳一次就变一个值，那就会互相传递传到表的最后一个双方拿值结束。<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  template: <span class="string">`&lt;h1&gt;&#123;&#123; watch1Data &#125;&#125;&lt;/h1&gt;`</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      watch1Data: <span class="string">'first watched.'</span>,</span><br><span class="line">      watch2Data: <span class="string">'second watched.'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.watch2Data = <span class="string">'data was be updated.'</span></span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="comment">// 反过来写方便顺向思维</span></span><br><span class="line">    watch2Data(val) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'watch2Data was be watched'</span>)</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.watch1Data = val</span><br><span class="line">      &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    watch1Data(val) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'watch1Data was be watched'</span>)</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.watch2Data = <span class="string">'watch1Data reload.'</span></span><br><span class="line">      &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以运行结果，在控制台会输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">watch2Data was be watched</span><br><span class="line">watch1Data was be watched</span><br><span class="line">watch2Data was be watched</span><br><span class="line">watch1Data was be watched</span><br></pre></td></tr></table></figure>
<p>嫌麻烦，所以代码尝试都在<code>ahri</code>上进行了（目标是新手也能使用的 flux vue 库）</p>
<p>主要还是大疆那次耿耿于怀，抽空实践了一下「如果watch了一个参加渲染的数据会发生什么？」</p>
<p>所以我还是不知道面试这个问题是要问我什么？总的就感觉就是想问我原理又感觉这是在文档能找到的答案。</p>
]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于四轴的踩坑指南]]></title>
      <url>/blog/2018/03/12/dji-interview/</url>
      <content type="html"><![CDATA[<p>怎么可能真的是四轴的踩坑指南，其实是大疆的受苦之旅。恼羞成怒下单了<code>mavic air</code>（所以dji还是赚了？）</p>
<p>怎么可能会让你回去还能等到通知，人家HR明明都告诉我面试入职一条龙了！算了本来就是自己的问题，能一路到看到四个大佬都是赚的。面试结束还送了架精灵还有一块工牌！（虽然是纸精灵和假工牌。</p>
<p>总结一下印象深刻受苦的问题和答案，不过有一点想吐槽的…就<code>vue</code>和<code>react</code>之间的关系和选择，我看到了高一文理科分班的那种影子：人家都是哪科分高选哪科，我是选分低 + 主管臆想……<br><a id="more"></a></p>
<h2 id="html5-css3"><a href="#html5-css3" class="headerlink" title="html5 css3"></a>html5 css3</h2><p>css3：圆角，变形，线性渐变，阴影。后两个没答，另外阴影我一直以为是<code>css2</code>的。</p>
<p>html5: 算了挺多的…基本上用过的都说了一遍… 下次记得背一下（真的需要用到那么多？</p>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>其实最受苦的就是这个了，问我对哪个库比较熟悉的时候，基本上就已经可以出试室了。基本上说哪个都不行的：<code>vue</code>确实用得最多但是<strong>没！看！过！源！码！</strong>，<code>react</code>倒是瞟过但是<strong>从！没！使！用！过！</strong></p>
<h3 id="created-和-mounted-区别，ajax会在哪里操作"><a href="#created-和-mounted-区别，ajax会在哪里操作" class="headerlink" title="created 和 mounted 区别，ajax会在哪里操作"></a>created 和 mounted 区别，ajax会在哪里操作</h3><blockquote>
<p>放在 created，因为 mounted 的时候还没有渲染节点。</p>
</blockquote>
<p>虽然这个问题也有一些讨论，有些会在<code>created</code>就做了，有些是在<code>mounted</code>做。</p>
<p>有问题吗？还真有。因为我想到的是：在<code>created</code>过程把数据获取之后，从虚拟dom转为真实dom的时候可以顺便把数据带进去。而不需要一整个组件都创建完整之后再去加载数据。毕竟到<code>mounted</code>的时候实例都建立完了，这个时候再刷新数据不是会引起刷新/重绘？不过这个问题不应该是我没看源码的问题，而是有些问题没了解透彻，或者说，文章看太少。</p>
<p>恰好就坑这了，要的就是在<code>mounted</code>，因为这个时候已经有组件实例了，也就是<code>this.$el</code>已经有树了，如果<code>ajax</code>过来的内容是需要依赖<code>el</code>的话，那在<code>created</code>的时候还没有东西呢。</p>
<p>但是我还是愿意保留意见，因为我觉得在<code>created</code>先请求到<code>mounted</code>的时候差不多刚好，要是<code>mounted</code>的时候没请求到数据就尴尬了。当然这个想法只是停留在<code>ajax</code>获取的是展示数据。</p>
<p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue生命周期图示"></p>
<h3 id="深度-watcher"><a href="#深度-watcher" class="headerlink" title="深度 watcher"></a>深度 watcher</h3><p>去翻了一下文档，我发现翻车的是自己吧！<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c: &#123;</span><br><span class="line">  handler: <span class="function"><span class="keyword">function</span> (<span class="params">val, oldVal</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  deep: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>只需要给对象加个<code>deep</code>就行了,而<code>a.b</code>这种情况应不属于深度watch，这只是需要监听的数据在比较深处而已…</p>
<h3 id="vue-函数式组件"><a href="#vue-函数式组件" class="headerlink" title="vue 函数式组件"></a>vue 函数式组件</h3><p>这是一个补充问题，关于 什么时候可以使用函数式组件，我觉得确实没什么可以说的啊…</p>
<p>如果只是充当渲染任务，不需要持久化不需要状态，采用函数式组件可以减少开销。</p>
<p>总的来说，比较严重的问题还是出现在：表达能力有问题 + 理解框架不够深刻（但远不及原理） + 狗娘的英语表达。还有<code>css</code>过于依赖补全导致想口头表述语句的时候，单词中间那段想不起来所以说不出口导致的丢分。所以打算CSS部分关闭补全一段时间。</p>
<p>这属于机会完全被自己毁了（还不是技术层面问题），所以烦躁和不甘又有什么用呢…</p>
]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[promise链式调用]]></title>
      <url>/blog/2018/02/28/promise-chaining/</url>
      <content type="html"><![CDATA[<p>学会了却不会活用是真的菜…</p>
<p>前几天面试，提到了回调地狱用<code>promise</code>，然后抛出个衍生问题：<code>promise</code>也会嵌套，怎么解决<code>promise</code>的回调地狱。</p>
<p>我想不到，直接问能不能用<code>ES8</code>，说行，然后我就想到了<code>const p2 = await Promise</code>这种做法。</p>
<p>可是，我记得我在若干天前才写了一篇关于「JS方法链式调用」。</p>
<blockquote>
<p>只要函数返回值是一个函数，就可以连着调用</p>
</blockquote>
<p>So,</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1.then(<span class="function">(<span class="params">&#123; p2 &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p2</span><br><span class="line">&#125;).then(&#123; p3 &#125; =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 曲苑杂坛 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue函数式组件]]></title>
      <url>/blog/2018/02/16/vue-functional/</url>
      <content type="html"><![CDATA[<p><a href="https://cn.vuejs.org/v2/guide/render-function.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener">函数式组件</a></p>
<p><code>vue</code>与<code>jsx</code>的配合一直都是后妈带儿子，所以就算文档也只是大面积讲述渲染函数的来龙去脉。但实际上真实开发的话是没有人直接<code>return CreateElement</code>来怼的（小组件暴力渲染还是会有的，但比较成型的组件肯定会想到<code>jsx</code>或者干脆<code>template</code>了）。</p>
<p>函数式组件，不多讲了这是个很常见的组件方式。不过因为<code>vue</code>的「特殊结构」，有点不太一样而已。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  functional: <span class="literal">true</span>,</span><br><span class="line">  render(h, ctx) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>作为无状态三宝<code>props</code>, <code>context</code>, <code>data</code>，当然<code>React</code>没有最后一个和第二个可选，但肯定不会少了<code>props</code>，毕竟无状态组件要求纯函数，单向数据一进一出。不过对于<code>vue</code>来说，一切内容都包入<code>context</code>，第一个参数必须传入渲染函数。</p>
<p>So，<code>context</code>一共有这么些东西：</p>
<blockquote>
<p>props：提供 props 的对象<br>children: VNode 子节点的数组<br>slots: slots 对象<br>data：传递给组件的 data 对象<br>parent：对父组件的引用<br>listeners: (2.3.0+) 一个包含了组件上所注册的 v-on 侦听器的对象。这只是一个指向 data.on 的别名。<br>injections: (2.3.0+) 如果使用了 inject 选项，则该对象包含了应当被注入的属性。</p>
</blockquote>
<p>至于<code>props</code>和<code>parent</code>已经不用解释了，主要是<code>children</code>, <code>data</code>, <code>listeners</code></p>
<p>实际上<code>data</code>问题最大，而文档说的最少的就是这个。文档只是一句”传递给组件的 data 对象“带过，这什么鬼？</p>
<p>实际上打印过一次<code>children</code>就知道了，一个节点需要tag标签，data数据，children子节点等。而<code>data</code>就是放在标签后的一系数据，比如<code>attr</code>。</p>
<p>如果还是不清楚的话，再打印一次，会发现，<code>data.attrs</code>是不是有<code>props</code>的内容？<code>data.on</code>是不是可以用在<code>listeners</code>？</p>
]]></content>
      
        <categories>
            
            <category> 实践尝试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[抛下不成熟，开始nvim]]></title>
      <url>/blog/2018/02/13/new-life-nvim/</url>
      <content type="html"><![CDATA[<p>想活得跟过去有些区别，活得更有效率该有的样子，而且我讨厌上一年的自己，不知道为什么会这么想。反正，放弃spacemacs开始使用vim了。</p>
<p>很简单，spacemacs有时候会卡一下，就像十年前的电脑，按了一长串需要等一下才会突突突突全显示出来。后来vscode + vim插件又出现了“不自觉按空格”的情况，就是写完按两下空格调插件。那既然这样的话，从零开始一个vim吧，把leader换成空格然后一些改不过来的习惯换过来就行了。</p>
<p>实际上，如果不是因为懒，早就该定制编辑器了。。不过我不会放弃vscode，因为还是有些残留。为什么不从零开始一个emacs？成本太高啊，又要vim模式又要改成leader键操作，而且逐渐能理解那个蚊香图是什么意思了。</p>
<h2 id="iterm2"><a href="#iterm2" class="headerlink" title="iterm2"></a>iterm2</h2><p>宿主用这个，原先很排斥在终端写东西（不能用鼠标），不过后来一手菜鸡操作<code>xj</code>, <code>xk</code>还有<code>wwwwwwww...</code>也能达到需求了，应该没问题了。<br><a id="more"></a><br>14px的<code>menlo nerd</code>，204x60 的<code>full-width top</code>，接近<code>40%</code>的透明度纯黑背景解决字体字符完整显示和启动时自动无边框全屏，还能看到窗后的情况。顺便把热键改成<code>cmd + return</code>（这操作懂得都懂…）</p>
<h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><p>oh-my-zsh一早就装了，用的<code>avit</code>主题，其他没动。对我来说<code>shell</code>就是<code>shell</code>。</p>
<h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p>从刚开始尝试MacVim到后面把这东西干掉，终端vim更新到vim8.0之后，vim一直充当着“顺手改改”的任务。这次因为要半主力编辑器，也不能全靠手打了…</p>
<p>对ycm印象极差，虽然deoplete支持vim8，弄了一阵子能用但是一出问题麻烦极多；找到了vim-lsp但是资源稀缺，还不会自启服务器！一气之下编译一手<code>neovim</code>，完美。毕竟我要有这脾气我就去从零开始space + emacs了（主要还可以直接抄大佬的配置）。</p>
<p>至于其他插件，因为还没有实战过还不知道缺哪些东西。先配好的是肯定会用上的，看情况再说。</p>
<p>另外求一个vim插件，vim有没有像<code>mmm-mode</code>的插件，就是同一个文件可以不同设置高亮或者补全的？用<code>mmm-mode</code>可以在同一文件同时采用<code>emmet-mode</code>和<code>js2-mode</code>，也因为这样解决我<code>vue</code>高亮补全问题…</p>
<p>然后就是看情况把在<code>spacemacs</code>的片段搬到<code>vim</code>了。</p>
<h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><p>其实<code>iterm2</code>也可以胡乱分屏，但是考虑到大佬墙裂推荐。用！</p>
<p>看到了<code>i3</code>的影子，配置窗口前后颜色，调整了状态栏左右宽度和配色。毕竟还不熟，随意的改成了和vim主题相近的低调配色并加上时钟（着手做电量）。不过我的终端毕竟不是全屏的，顶栏和dock还是会常驻屏幕，所以一堆东西也没什么用。对了，这一套有颜色的主题颜色都采用了<code>one</code>，atom家那个。</p>
<p>然后剩下的就是通过使用寻找问题了，现在第一个问题就是vim的主题怎么把背景也至少<code>30%</code>的透明，改了主题文件发现一点用都没有。</p>
]]></content>
      
        <categories>
            
            <category> 玩具制造 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vim </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vuex源码理解（二）]]></title>
      <url>/blog/2018/01/30/vuex-study-2/</url>
      <content type="html"><![CDATA[<p>继续，这次尝试逐行理解Store类的东西</p>
<p>然后关于这次，一些“工具函数”都集中在<code>util.js</code>的这种做法，已经够我学的了。这是个很受用的做法。</p>
<h2 id="一些简单的东西"><a href="#一些简单的东西" class="headerlink" title="一些简单的东西"></a>一些简单的东西</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  assert(Vue, <span class="string">`must call Vue.use(Vuex) before creating a store instance.`</span>)</span><br><span class="line">  assert(<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>, <span class="string">`vuex requires a Promise polyfill in this browser.`</span>)</span><br><span class="line">  assert(<span class="keyword">this</span> <span class="keyword">instanceof</span> Store, <span class="string">`Store must be called with the new operator.`</span>)</span><br><span class="line">&#125; <span class="comment">// 断言函数在util，如果不满足前面的情况，后面以error 排出来</span></span><br><span class="line"><span class="comment">// （实际上就是想看有没有在vue环境中和有没有正确安装）</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  plugins = [],</span><br><span class="line">  strict = <span class="literal">false</span></span><br><span class="line">&#125; = options <span class="comment">// 定义两个变量，在传入的对象中把这两个东西拿出来，字面意思</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里可能是会把整个vuex所有的内容都会规整到这些中</span></span><br><span class="line"><span class="comment">// store internal state  </span></span><br><span class="line"><span class="keyword">this</span>._committing = <span class="literal">false</span>  <span class="comment">// commit switch（ -&gt; mutations）</span></span><br><span class="line"><span class="keyword">this</span>._actions = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// actions</span></span><br><span class="line"><span class="keyword">this</span>._actionSubscribers = [] <span class="comment">// 应该像在dva中看到的订阅，没用过也没弄清楚应该怎么用</span></span><br><span class="line"><span class="keyword">this</span>._mutations = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// mutations</span></span><br><span class="line"><span class="keyword">this</span>._wrappedGetters = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// getters</span></span><br><span class="line"><span class="keyword">this</span>._modules = <span class="keyword">new</span> ModuleCollection(options) <span class="comment">// 分模块得到一个类</span></span><br><span class="line"><span class="keyword">this</span>._modulesNamespaceMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>)  <span class="comment">// 命名空间，上一次有讲到</span></span><br><span class="line"><span class="keyword">this</span>._subscribers = [] <span class="comment">// 所有订阅者</span></span><br><span class="line"><span class="keyword">this</span>._watcherVM = <span class="keyword">new</span> Vue() <span class="comment">//watcher??应该跟vue的watcher有关？</span></span><br></pre></td></tr></table></figure>
<h2 id="开始跳着理解"><a href="#开始跳着理解" class="headerlink" title="开始跳着理解"></a>开始跳着理解</h2><h3 id="store-与-操作绑定"><a href="#store-与-操作绑定" class="headerlink" title="store 与 操作绑定"></a>store 与 操作绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind commit and dispatch to self</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">this</span> <span class="comment">// 把store 是指向 this 的</span></span><br><span class="line"><span class="keyword">const</span> &#123; dispatch, commit &#125; = <span class="keyword">this</span> <span class="comment">// 所以 &#123; dispatch, commit &#125; = store ?</span></span><br><span class="line"><span class="keyword">this</span>.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">boundDispatch</span> (<span class="params">type, payload</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dispatch.call(store, type, payload)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.commit = <span class="function"><span class="keyword">function</span> <span class="title">boundCommit</span> (<span class="params">type, payload, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> commit.call(store, type, payload, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然有注释，就是把 commit, dispatch 和store绑定到<code>this</code>上，然后<code>{ dispatch, commit } = store</code>了。接着class中的<code>dispatch</code>指向刚刚对象中<code>dispatch</code>的方法，通过<code>call</code>用法改变作用域调用。我们用到的<code>this.$store.dispatch</code>应该来源这里，下面同理</p>
<h3 id="ModuleCollection"><a href="#ModuleCollection" class="headerlink" title="ModuleCollection"></a>ModuleCollection</h3><p>这里感觉很有意思，因为我这是第一次关注vuex的代码，我也不清楚命名空间等这些东西是什么时候加进去的，但我猜测应该是vue2.5之后的内容因为之前没在文档里见过这些东西。</p>
<p>字面意思，模块收集器。由于现在复杂度的关系，这部分应该先处理一下。把从vue的vuex得到的options，直接传入这个类，然后再进入<code>register</code>方法，接下来的工作就是不断的尾递归（？）得到整棵树。因为现在还有命名空间什么的，所以还有关于命名空间的判断和结合。</p>
<p>然后还有一些其他方法，比如热更什么的。</p>
<h3 id="installModule"><a href="#installModule" class="headerlink" title="installModule"></a>installModule</h3><p>使用到的位置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">installModule(<span class="keyword">this</span>, state, [], <span class="keyword">this</span>._modules.root)</span><br></pre></td></tr></table></figure></p>
<p>Store开始初始化的其中第一个方法。</p>
<p>这个方法，字面含义就是安装模块，猜测应该是把store相关的东西先配置下来。</p>
<p>这里有一个点（函数太长了不浪费篇幅了）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isRoot = !path.length</span><br></pre></td></tr></table></figure></p>
<p>判断是否是根是通过<code>path</code>的长度来做的，如果没长度就是<code>/</code>了，很有意思，对于还没什么经验的我受益匪浅。</p>
<p>这个函数，需要5个参数，<code>store</code>, <code>rootState</code>, <code>path</code>, <code>module</code>, <code>hot</code>。最后一个应该也跟更新有关系吧？</p>
<p><code>this</code>在<code>class</code>中，所以指向是<code>class Store</code>的；<code>state</code>是<code>const state = this._modules.root.state</code>得到，而<code>_modules</code>就上面提到的定义了；因为还在根所以没有<code>path</code>，最后传入刚刚各种尾递归得到的树。</p>
<p>接下来注册命名空间，也就是判断这次的store有没有用到命名空间，有就分成一张张网，摊开处理。</p>
<p>接下来会遇到一个函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNestedState</span> (<span class="params">state, path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.length</span><br><span class="line">    ? path.reduce(<span class="function">(<span class="params">state, key</span>) =&gt;</span> state[key], state)</span><br><span class="line">    : state</span><br><span class="line">&#125; <span class="comment">// 如果不是根的话会被分配到这里，看需不需要拼凑state，就“三光属性”</span></span><br></pre></td></tr></table></figure></p>
<p>非根注册应该是文档的<a href="https://vuex.vuejs.org/zh-cn/modules.html" target="_blank" rel="noopener">这里</a>吧，这里提到了模块可以只是局部注册，我们一般都直接在<code>main.js</code>完事儿了。</p>
<p>然后就是三种操作的模块遍历注册，用到的方法存在<code>module.js</code>，实则还是用到了<code>util.js</code>的遍历方法（通过回调函数返回回去，再次赞叹）</p>
<p>而注册的方法<code>registerMutation</code> &amp;&amp; <code>registerAction</code> &amp;&amp; <code>registerGetter</code> 就是我们用到的那些例如<code>store.commit(type, payload)</code>的方法。</p>
<p>然<code>registerAction</code>的方法比其他的复杂得多，它要求<code>handler</code>传入<code>dispatch</code>, <code>commit</code>, <code>getter</code>, <code>state</code>等。显然他命中注定要干一些“脏乱差”的工作。由此也可以得到为什么<code>actions</code>的方法，第一个参数(type)可以传入<code>{dispatch, commit, state}</code>…的东西了。</p>
<p>题外话：之前在某个论坛看到一个问题，问在vuex中的actions为什么可以取到state，不会造成什么乱七八糟的问题么？我也不知道，问题的答案先留着。不过因为可以得到state，所以我们可以通过现有的state来判断或者操作，这不是更方便了么？</p>
<h3 id="resetStoreVM"><a href="#resetStoreVM" class="headerlink" title="resetStoreVM"></a>resetStoreVM</h3><p>当一切都准备好了之后，怼进实例。</p>
<p>实际上前面也有提到，vuex是被vue当做专属插件进行安装的，在Vue实例环境中就可以通过<code>this.$store</code>摸到vuex。然后vuex就可以通过数据的改变来重新得到新的组件或者新的去促进生成得到新的dom。然后在上一篇有讲到那一堆辅助函数，实际上就是控制或者约束操作，但实质就是<code>Vue.$store.dispatch</code>等等等。</p>
<p>先是从store拿到vm作为旧的vm以作备份（当然如果不存在就不存在备份了），然后让<code>Vue</code>把这段操作定义为静默操作。</p>
<p>接着生成通过<code>new Vue</code>生成新的vm（假如有旧的也备份了，不会影响），恢复取消静默操作。（意思就是偷偷替换了vm）</p>
<p>至此新的视图已经更新完成，没有出意外的话，存在的刚刚备份过的旧vm就可以干掉的，执行销毁</p>
<h3 id="withCommit"><a href="#withCommit" class="headerlink" title="_withCommit()"></a>_withCommit()</h3><p>通篇是没有提到这个函数的，到这里提一下是因为，至此这个函数用了两次，最后一次是发生在刚刚<code>resetStoreVM</code>的最后，如果存在热更的情况下那里。篇幅不长，拿出来看一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_withCommit (fn) &#123;</span><br><span class="line">  <span class="keyword">const</span> committing = <span class="keyword">this</span>._committing</span><br><span class="line">  <span class="keyword">this</span>._committing = <span class="literal">true</span></span><br><span class="line">  fn()</span><br><span class="line">  <span class="keyword">this</span>._committing = committing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>毕竟状态管理，如果谁都能理这个状态，还需要管理干什么。这里的理解可以套入<code>reducer</code>协助理解，<code>state</code>有且仅有<code>reducer</code>可以修改，而vuex的<code>mutations</code>也就是做这份工作的地方。然后<code>_withCommit</code>的话，是个代理来的。</p>
<p>还是刚刚备份旧vm那个样子，先备份当前状态，然后把该状态转为<code>true</code>，据说是如果不暂时改变状态，严格<code>vuex</code>会认为这是非法操作，是禁止的。</p>
<p>封印解除之后，执行一下回调（各种需要破例更新的数据），然后再固着。</p>
<p>为什么这里需要备份状态换回去，而且这里是<code>boolean</code>，非黑即白的。实际上如果这个所谓的开关，在执行这里之前就是关闭的，那道理通过。如果在这之前，开关本来开着，这样你执行一次这里，就又把开关关回去的话，会影响到其他地方的正常工作，这不是一个“合格的秘书”。</p>
<p>刚刚最后那里的操作<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  oldVm._data.$$state = <span class="literal">null</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>就是假如这里是<code>hot</code>的话，就把旧vm的状态改成<code>null</code>，然后跟这个vm有关的watcher和计算都会被强行触发更新。通过这样让页面不刷新然后刷新dom。</p>
<p>最后一个问题：为什么明明<code>this</code>指向的是本体(Store)，初始化的时候需要<code>const store = this</code></p>
<p>回答：JavaScript那么牛逼的<code>this</code>，墙头草属性的，不找个需要固定的位置固定下来肯定会有机会被带偏的。</p>
]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
            <tag> vuex </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vuex源码理解（一）]]></title>
      <url>/blog/2018/01/25/vuex-study-1/</url>
      <content type="html"><![CDATA[<p>看个代码代价很高，我边读边转笔，然后一个失手把手挑了个滴血不止…（笔头挑掉了一层手皮）</p>
<p>vuex和dva的源码都想看，不然没办法知道相性在哪。</p>
<h2 id="由口而入"><a href="#由口而入" class="headerlink" title="由口而入"></a>由口而入</h2><p>这都暴露干净了…<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  Store,</span><br><span class="line">  install,</span><br><span class="line">  version: <span class="string">'__VERSION__'</span>,</span><br><span class="line">  mapState,</span><br><span class="line">  mapMutations,</span><br><span class="line">  mapGetters,</span><br><span class="line">  mapActions,</span><br><span class="line">  createNamespacedHelpers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>install</code>肯定是Vue老套路，想把东西当插件用肯定要暴露这个方法。这个之前写组件经常需要碰到，弃之！</p>
<p>这次就先读暴露出来的四个方法吧</p>
<a id="more"></a>
<h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><h3 id="normalizeNamespace"><a href="#normalizeNamespace" class="headerlink" title="normalizeNamespace"></a>normalizeNamespace</h3><p>这个东西可能要先讲，因为你看到<code>mapState</code>的第一眼你就会看到他，虽然不重要。</p>
<p>这应该是一个初始化或者标准化命名空间的方法，之前”尝试用dva的理解对处理数据”有遇到使用命名空间的情况。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(<span class="string">'spacename'</span>, &#123;</span><br><span class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.count </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下实现方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeNamespace</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">namespace, map</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> namespace !== <span class="string">'string'</span>) &#123;</span><br><span class="line">      map = namespace</span><br><span class="line">      namespace = <span class="string">''</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (namespace.charAt(namespace.length - <span class="number">1</span>) !== <span class="string">'/'</span>) &#123;</span><br><span class="line">      namespace += <span class="string">'/'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn(namespace, map)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>映入眼帘就是一个柯里了，大致意思就是命名空间需要处理，如果进来的函数第一个不是空间名称那么肯定直接是对象了，因为我们也不是必须使用命名空间，比如最普通的这样的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.count </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有命名空间的话，就根据层数用<code>/</code>分开，比如<code>app/save</code></p>
<h3 id="normalizeMap"><a href="#normalizeMap" class="headerlink" title="normalizeMap"></a>normalizeMap</h3><p>对不起还是不能讲到<code>mapState</code>，毕竟通用的函数理解完了之后，游戏也就结束了。（要不怎么说是辅助函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Normalize the map</span></span><br><span class="line"><span class="comment"> * normalizeMap([1, 2, 3]) =&gt; [ &#123; key: 1, val: 1 &#125;, &#123; key: 2, val: 2 &#125;, &#123; key: 3, val: 3 &#125; ]</span></span><br><span class="line"><span class="comment"> * normalizeMap(&#123;a: 1, b: 2, c: 3&#125;) =&gt; [ &#123; key: 'a', val: 1 &#125;, &#123; key: 'b', val: 2 &#125;, &#123; key: 'c', val: 3 &#125; ]</span></span><br><span class="line"><span class="comment"> * @param &#123;Array|Object&#125; map</span></span><br><span class="line"><span class="comment"> * @return &#123;Object&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeMap</span> (<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(map)</span><br><span class="line">    ? map.map(<span class="function"><span class="params">key</span> =&gt;</span> (&#123; key, <span class="attr">val</span>: key &#125;))</span><br><span class="line">    : <span class="built_in">Object</span>.keys(map).map(<span class="function"><span class="params">key</span> =&gt;</span> (&#123; key, <span class="attr">val</span>: map[key] &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释都直接告诉你了！对的实际上组件对<code>vuex</code>的访问可以有两种，对象或者数组。对象的情况上面已经有了，还有一种数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(<span class="string">'spacename'</span>, [</span><br><span class="line">    <span class="string">'count'</span></span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种是，如果组件的参数跟vuex设定一样，那么就直接传入数组匹配，相当于<code>this.count</code>指向<code>this.$store.state.count</code></p>
<h3 id="mapState-mapMutations-mapGetters-mapActions"><a href="#mapState-mapMutations-mapGetters-mapActions" class="headerlink" title="mapState, mapMutations, mapGetters, mapActions"></a>mapState, mapMutations, mapGetters, mapActions</h3><p>剩下的就真的是“拼装术”的事情了，通过暴露出去的辅助函数所接收到的数据进行转换并连接<code>vuex</code>。</p>
<p>相当于<code>redux</code>本身只提供了状态管理，便捷操作需要接触各类型插件。而<code>vuex</code>作为<code>vue</code>专属状态管理，已经提供了最适合<code>vue</code>的操作。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>由于辅助函数做的工作就是提供在组件中对<code>vuex</code>连接操作的工作，而函数中的转换结果都会是<code>this.$store</code>。在注入<code>vue</code>的环境中，<code>this</code>不出意外的话是指向<code>vue</code>原型上的，这也就意味着，<code>vuex</code>实际上也是作为插件附着在<code>vue</code>原型中。</p>
<p>不过关于这一点，在一开始就有提到，<code>vuex</code>是通过暴露自己的安装函数让<code>vue</code>可以直接<code>use()</code>。而且我们在<code>main.js</code>绑定时也默认使用<code>store</code>这个key。</p>
<p>这样的话，只要是能访问到<code>vue</code>的地方就可以访问到<code>$store</code>了，包括组件。<strong>从而可以做到不需要什么辅助函数也不需要<code>actions</code>直接对状态管理动手动脚。</strong>这不仅是react的使用者感觉到的诧异或者反感了吧。</p>
<p>不过团队是知道这种情况的存在的，所以他们是<strong>推荐在组件中使用辅助函数，请不要直接操作</strong>。</p>
<p>（不过这个注释最多也就说说而已，懂道理的人都会这么做；不懂道理的，只存留“我只要解决问题就行了”的某些人是不会这么做的。）</p>
]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
            <tag> vuex </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[通过dva得到的思考 —— “滥用”VUEX]]></title>
      <url>/blog/2018/01/22/vuex-dva/</url>
      <content type="html"><![CDATA[<p>首先这一手骚操作要感谢@ahonn，确实这几天学习dva，我自己都觉得自己有点烦了。但是老哥好耐心，真心感谢。</p>
<p>直接上正题吧不磨磨唧唧的了！</p>
<h3 id="dva是什么"><a href="#dva是什么" class="headerlink" title="dva是什么"></a>dva是什么</h3><p>这还用说吗，坦克啊！双命特性，大招是通过机甲自爆产生大范围爆炸，本体只有100血，可以反…啊！！！别打我啊！</p>
<p>好吧可能阿里的工程师也喜欢玩守望先锋，而且我清晰记得dva这个框架就是守望大火的时候诞生的，而且还有一个协同工具叫路霸吧。（看来阿里的工程师都不喜欢当C…）</p>
<a id="more"></a>
<p><code>dva</code>是针对<code>react</code>的框架，实际上就是关于<code>redux</code>的一个封装。首先是让本来很难理解和使用的redux变得相对容易理解和操作。另外一个就是因为数据集中管理，并且推荐使用无状态组件，操作者只需要关心数据的走向。</p>
<h3 id="从dva得到了启示"><a href="#从dva得到了启示" class="headerlink" title="从dva得到了启示"></a>从dva得到了启示</h3><p>毕竟阿里前端工程师，Ahonn是真的喜欢阿里的东西…最近跟他聊天也比较深入了解“为什么我们需要dva”。</p>
<p>后来我一个闪念：<code>dva</code>会不会就是一个数据库模型，实际上redux对我们来说就是一个数据库，前端没有状态，不干涉数据，实际上就是我们常说的只关心增删改查？</p>
<p>那么dva实际上还是对<code>redux</code>，<code>redux-saga</code>，<code>redux-thunk</code>的封装，但对于vue来说简直就是先天优势，因为对于vuex来说已经相当于redux + redux-saga了。从这里也直接萌生了一个想法：vuex + stateless component = 1/2 dva ？</p>
<h3 id="对启示更清晰的思考"><a href="#对启示更清晰的思考" class="headerlink" title="对启示更清晰的思考"></a>对启示更清晰的思考</h3><p>首先现在的dva，把数据都封装在<code>model</code>中，一个<code>model</code>对应一个redux，<code>state</code>, <code>reducer</code>概念得以保留，引入<code>effect</code>和<code>subscriptions</code>概念。</p>
<p>首先副作用的目的是，通过异步操作例如网络请求或者一些需要异同步配合的操作，然后去驱使<code>reducer</code>更新<code>state</code>，因为在流中，只有<code>reducer</code>有权利去动<code>state</code>。<code>subscriptions</code>就是一个订阅的概念，在我看来就是一个初始化，或者说是一个接受状态的概念。</p>
<p>那么为什么说vuex有先天优势？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dva model</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespace: <span class="string">"users"</span>,</span><br><span class="line">  state: &#123;&#125;,</span><br><span class="line">  reducers: &#123;&#125;,</span><br><span class="line">  effects: &#123;&#125;,</span><br><span class="line">  subscriptions: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vuex</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    users: &#123;</span><br><span class="line">      namespaced: <span class="literal">true</span>,</span><br><span class="line">      state: &#123;&#125;,</span><br><span class="line">      mutations: &#123;&#125;,</span><br><span class="line">      actions: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果你要无限逼近dva是什么感觉？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// users.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespaced: <span class="literal">true</span>,</span><br><span class="line">  state: &#123;&#125;,</span><br><span class="line">  mutations: &#123;&#125;,</span><br><span class="line">  actions: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//store.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    users</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>由于 vue/vuex 对于规则还是相对宽松，但理是理法是法，约定俗成<code>mutations</code>是用来做同步的工作，可以用来操作<code>state</code>；<code>actions</code>用来做异步工作，通知<code>mutations</code>去操作<code>state</code>。所以这里是不是就有一种新的概念？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">state &lt;=&gt; state</span><br><span class="line">mutation &lt;=&gt; reducer</span><br><span class="line">action &lt;=&gt; effect</span><br><span class="line"></span><br><span class="line">_ &lt;=&gt; subscription</span><br></pre></td></tr></table></figure>
<p>对没错，订阅怎么办？</p>
<p>在dva的例子中，看一下示例的订阅是做了什么工作？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">subscriptions: &#123;</span><br><span class="line">  setup(&#123; dispatch, history &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> history.listen(<span class="function">(<span class="params">&#123; pathname, query &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (pathname === <span class="string">'/users'</span>) &#123;</span><br><span class="line">        dispatch(&#123; <span class="attr">type</span>: <span class="string">'fetch'</span>, <span class="attr">payload</span>: query &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以关于这个简单订阅，我们完全可以直接用<code>vue-router</code>，而其中刚好有一个概念我们可以直接使用 —— 导航守卫</p>
<h3 id="针对vue的操作"><a href="#针对vue的操作" class="headerlink" title="针对vue的操作"></a>针对vue的操作</h3><p>老样子，我们是怎么理解dva的<code>model</code>，就怎么理解vuex的<code>store</code>。首先<code>state</code>和<code>reducer</code>跟vuex的定义是完全对等的，不需要多理解。<code>effects</code>是使用<code>generator</code>函数来解决异同步问题的，那好办啊，都2018年了，我们直接用async/await就行了。而且我们之前关于api都是使用<code>promise</code>，而且用的也是<code>axios</code>，所以这部分可以说是无缝切换。</p>
<p>那么关于订阅，直接使用<code>vue-router</code>的导航守卫对路由监控，另外在必要的时候还能使用<code>meta</code>。当然导航守卫并不是只能用在全局上，也可以注入到组件中，所以我们注入到页面组件即可。</p>
<p>接下来就是无状态组件问题了，vue默认是状态组件，而且无状态组件也没有react来的方便。</p>
<p>react想要无状态组件，无非就是一个函数就结束战斗了。vue也有一个概念叫函数式组件，也就是无状态，这种组件在使用上就已经不是很方便了。</p>
<p>vue的函数式组件就必须使用<code>render</code>函数不能用<code>template</code>模板，一直到vue2.5才可以在<code>&lt;template functional&gt;</code>使用。但我尝试了一下，手感并不好，所以还是只能用 jsx + vue 这种搭配来操作。不过vue的无状态组件也不像react那么好理解，它依然是一个Object</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  functional: <span class="literal">true</span>， <span class="comment">// 你只不过是通过这个开关来切换组件状态</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions(<span class="string">'spacename'</span>, &#123;</span><br><span class="line">      add: <span class="string">'create'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;&#123;props.msg&#125;&lt;/h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而且在实际使用中，实际上因为vue的概念，你还是没办法在所有组件完全不使用无状态组件（已经除去表单组件）。不过也无伤大雅了。</p>
<p>所以通过这个操作，也能近似的得到了dva的那种感觉。前端的工作只需要直观的反馈你的数据动向和状态，要那么复杂干什么？</p>
]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[剑指Offer —— 替换空格]]></title>
      <url>/blog/2018/01/04/replace-space/</url>
      <content type="html"><![CDATA[<p>以后博客专职曲苑杂坛算了…</p>
<p>刚刚看到一题</p>
<blockquote>
<p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
</blockquote>
<p>我想这什么腿？然后什么都没想，直接就</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> str.replace(<span class="regexp">/\ /g</span>, <span class="string">'%20'</span>)</span><br></pre></td></tr></table></figure>
<p>然后过了……虽然100多毫秒</p>
]]></content>
      
        <categories>
            
            <category> 曲苑杂坛 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的2017]]></title>
      <url>/blog/2017/12/30/my-2017/</url>
      <content type="html"><![CDATA[<p>我本来是最反感写年终总结的那一个，我最讨厌的就是形式化的东西。</p>
<p>但感觉今年还是挺有意义的，学着去接触了很多东西，所以我还是愿意记录下所有第一次。</p>
<h2 id="2017"><a href="#2017" class="headerlink" title="-2017"></a>-2017</h2><blockquote>
<p>好稚嫩；<br>所以你也算是入了前端的坑？<br>—— Ahonn</p>
</blockquote>
<p>我的新前端，从这开始的。<br><a id="more"></a></p>
<h2 id="2017-1"><a href="#2017-1" class="headerlink" title="2017"></a>2017</h2><p>所以到这里才是关于今年的事情。</p>
<h3 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h3><p>写了一个HEXO “KPA” 产物主题就是现在正在使用的 Nlvi ，第一个版本“语”。</p>
<p>Nlvi的出生并不是纯洁的，它一开始只是想用来证明自己。拿着它去找工作。所以我除了提交到 hexo theme 并没有做其他的宣传。直到过了一整天，在项目看到第一个star的时候我才知道，我错了。我开始修正我的想法，毕竟nlvi也是love类型的。所以经历了一年的迭代，有了新的版本“彩”。</p>
<p>然而“彩”的初衷是看到了issue有一条评论：迫切需要颜色。</p>
<p>所以如今 Nlvi 相比年初，它更完善了。也保留了最初的设计融合了颜色的内容，多了一种风格。让我感动的是，目前已经至少有92人对它的肯定。主题还有两个老哥一起维护，虽然从“语”切换到“彩”让他们从contributor消失了，但我还是记住他们：ruinshe, lostinlight。</p>
<p>开始逐渐适应了现在的网页，迎合现在比较清晰的设计。所以把一些常用的<code>CSS3</code>动画打包成库，加上一些自己的小想法，成为我的第一个动画库——syuanpi.css。但是它并没有什么好讲的，但它同样有意义——第一次接受了知乎用户的怜悯。</p>
<h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>开始专注学习<code>JavaScript</code>，在这之前还尝试过<code>angular</code>和<code>TypeScript</code>呢，也是不了了之。</p>
<p>不过我并没有直接去看书，而是去看别人的代码。去学现在大家都是怎么写怎么对待这门学科的。直到后面理解了虽然你是能做事了，还是少不了看书，所以开始读《红宝书》、《DOM艺术》。</p>
<p>高中水技术的时候，已经从一位我很敬仰的工程师了解到，这个世界分编程语言的话只分成两种：指令式编程，函数式编程。还有一些适应性强的语言，它们叫多范式。例如C系都是指令式，JavaScript是函数式。从这之后，“函数式编程”只是我用来装b的词汇。但从今年开始，学js同时也学函数式编程思想。真正开始“拿函数式当枪使”的时候是 @Ahonn 吹了一次<code>ClojureScript</code>，从这开始我从小打小闹直接进入疯狂沉迷状态。现在觉得<code>haskell</code>基础部分还是可以接受的，就是不知道有什么用…</p>
<p>说起来我的<code>Hyper</code>好像要凉了…每次用TS都感觉手感不太对的样子…</p>
<p>一直使用现代编辑器的我看到别人用<code>vim</code>、<code>emacs</code>都会在心里嘲讽他，没错今年轮到我当sb了，开始使用<code>vim8</code>和<code>spacemacs</code>。vim还在慢慢配置的状态，平时多数是 linux + macos，vim多数在linux那边使用的。现在mac的质量和手感越来越差，也是找个借口让自己适应windows + linux吧。有时候还是会不适应spacemacs，所以保留了vscode。结果一年下来用得最多的依然是vscode。</p>
<p>还是跟往常一样，学习没规律，只要不上班就哐哐开始搞。看到 @Ahonn 使用“番茄工作法”规划时间，我想2018年也尝试一下，取长补短嘛。</p>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>创业划水之后，好像也挺无聊的然后第一次去上班。因为起步比别人慢，所以基本上错过了所有校招，加上学历问题，最后面试了两家外包公司，去了一家交通方便的。</p>
<p>基本上就是各种不适应咯，并不是上班不适应，而是编程范式不适应。见识过各种金主爸爸的无理取闹，使得开发从完整系统到拆散系统；见识过设计稿毫无章法不给规范说明却要求严格把控细节；见识过严格要求遵守规范却没有规范文件，想到什么规范什么。</p>
<p>给了一个“前端工程师”的title，却领导着一整个前端团队。没错，这个前端团队只有我一人。所以前端团队和能用前沿技术做前沿开发成为了憧憬，可以说每天都在期待着这天。嘛，没坏处，至少比其他人多体会到更多的东西。至少我现在可以站着跟你说：我能够用微信小程序开发出7层路由的应用！我开发过20+个页面的小程序！</p>
<h3 id="游戏-读书"><a href="#游戏-读书" class="headerlink" title="游戏/读书"></a>游戏/读书</h3><p>单片机，树莓派，还有上面说的，每天都是以搞为生，一年接触一堆语言和设计模式。当然游戏依然是我的主要放松方式。</p>
<p>今年也没打通过什么游戏，年初买了<code>Nintendo Switch</code>，只打通了《超级马里奥·奥德赛》，其他的游戏基本上也不算通，毕竟有意思的内容都是网络部分。现在在玩《异度之刃2》，毕竟是这个月的游戏，一个月通关对我来说真的不可能。</p>
<p>社交元素，玩起了《王者荣耀》，但我并不喜欢玩手机游戏，为了搭上话才去玩。一天两把，有一天没一天的，三个赛季两个白金一个钻石。</p>
<p>相比去年今年的游戏时间可以说少了很多，主要都花时间在搞前端上了。</p>
<p>读书的话，除了一些新闻、报纸杂志，其他文学类的书我也不是很能读得下去，所以看了比较多的技术类。读过一两本也是题材得非常感兴趣的，翻了几页《草木缘情》，在多看读了两本东野圭吾的小说。然后大多数时间都在设计模式，数据结构。</p>
<h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><p><strong>没有计划！</strong></p>
<p>这就是真实的我，从来不会先给自己夸下海口。计划永远赶不上变化，只要时间不是浪费的就好了。哪怕玩游戏，游戏能带出来的内容也是相当多的。</p>
<p>一整年 @Ahonn 隐隐约约给的帮助还是相当大的，很感谢。</p>
]]></content>
      
        
        <tags>
            
            <tag> colmugx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[有意思的monad记录]]></title>
      <url>/blog/2017/12/27/funny-monad/</url>
      <content type="html"><![CDATA[<blockquote>
<p>看到monad我的第一反应竟然是莫纳德…</p>
</blockquote>
<p>最近学习haskell的时候（意外的觉得入门不难），接触到函数式编程一个新的思想——Monad</p>
<p>之前在知乎看到轮子哥说：学习haskell是好事，但最好就是学到monad就停下来，然后去学别的。对别的语言帮助很大。</p>
<p>然后在知乎看了一些monad的答案，找了点关于monad的博客看，没看懂。英文的话更不可能了！直接看paper的话我会脆死的。</p>
<p>后来偶然找到一篇文章：<a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="noopener">Functors, Applicatives, And Monads In Pictures - adit.io</a></p>
<p>当然有中文版：<a href="http://jiyinyiyong.github.io/monads-in-pictures/" target="_blank" rel="noopener">Functors, Applicatives, And Monads In Pictures - adit.io</a>，<br><a href="http://www.ruanyifeng.com/blog/2015/07/monad.html" target="_blank" rel="noopener">图解 Monad - 阮一峰的网络日志</a></p>
<p>全程特别轻松，我以后写博客也要按照这个节奏来写！很有意思！<br>（那个抽东西的手直接戳爆了我的笑点…特别是解构传入胶水函数的时候）</p>
<p>关于理解的话，挖个坑以后总结~</p>
<p>但有一点是：我用 Vue-jsx 的时候，几乎全是Monad</p>
]]></content>
      
        <categories>
            
            <category> 曲苑杂坛 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Functional Programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript链式方法]]></title>
      <url>/blog/2017/12/23/js-method-chaining/</url>
      <content type="html"><![CDATA[<blockquote>
<p>著名框架<code>jQuery</code>所使用的设计模式——“虾扯蛋”</p>
</blockquote>
<p>之前在知乎回答过一个问题：2018的前端应该学什么。</p>
<p>我回答了：就算前端再复杂，jQuery依然是最流行的那个。</p>
<p>这答案怎么样呢？废话！肯定没人点赞了！</p>
<p>人性就是如此！一旦接受了更<del>装逼</del>新的思路，就会觉得以前见过的东西都太弱了！</p>
<p>新项目想用什么就用什么，什么技术栈健全就用什么。可是老项目并没办法想干什么干什么，时间和精力不允许他去重构。金蝶还在卖VB呢，他们肯定也想过VB已经不行了。</p>
<p>好了题外话，我还是很有兴趣实现一个塞进<code>nlvi</code>的类jq的。</p>
<a id="more"></a>
<h2 id="怎么来的链式操作"><a href="#怎么来的链式操作" class="headerlink" title="怎么来的链式操作"></a>怎么来的链式操作</h2><blockquote>
<p>如果不用链式调用，jQuery没有性能可言 ——鲁迅</p>
</blockquote>
<p>鲁迅：我不是！我没有！别乱说啊！</p>
<p>我记得有人测试过，<code>$(&#39;#ele&#39;)</code>会比<code>document.getElementById(&#39;ele&#39;)</code>慢很多。如果是按行操作dom而不是用专属的链式调用，效率会更差。</p>
<p>但这次不是来讨论jQuery的效率的。链式方法也是一种设计模式，有必要了解一下。就算ES6常使用的<code>Promise</code>，也用到了链式调用。</p>
<p><code>JavaScript</code>能够函数式编程，还是因为它是个“函数为第一公民”的语言，但它并没有<code>pure function</code>是因为它的设计其实是多范式的。而ES6把构造函数和<code>classes</code>加进去之后更是证明了这一点。</p>
<h3 id="我用过的JavaScript"><a href="#我用过的JavaScript" class="headerlink" title="我用过的JavaScript"></a>我用过的JavaScript</h3><p>关于这部分，我觉得我想分享的东西有点超篇幅，所以移步到另外一篇分享吧：<a href="/PersonalBlog/2017/12/26/my-known-javascript/">我所认识的JavaScript</a></p>
<p>大致上就是<code>JavaScript</code>之所以能这么玩是因为它会把任何东西都看做“函数”来看待，并且以它的理解就是：我能且只能掌控函数，函数必有返回值。并且每产生一个函数就会有一个“我”的含义：<code>function</code>会自然而然的产生<code>this</code>并指向自己。而链式操作就是利用了这点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是浏览器的话，在没有对象的情况下，父级应该就是<code>window</code>了。而函数返回<code>this</code>相当于把自己返回到操作空间中，而操作空间属于父级。也就是说，只要是同一级别的函数，通过返回<code>this</code>把操作权交还到父级手中从而达到继续调用同级函数的技能。还不清楚？反正我不画图。</p>
<h3 id="简单链式操作"><a href="#简单链式操作" class="headerlink" title="简单链式操作"></a>简单链式操作</h3><p>在此我们以著名歌唱家“雷军”举个例子。雷军可以说是目前最强悍的企业家了，写得了软件造得了手机，能唱一首好歌能吹一手好B。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 雷军（人为对象，构造成立）</span></span><br><span class="line"><span class="keyword">var</span> LeiJun = &#123;</span><br><span class="line">  hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello, '</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="comment">// -&gt; LeiJun</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  thank: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'thank you, '</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="comment">// -&gt; LeiJun</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  thanks: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'thank you very much, '</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="comment">// -&gt; LeiJun</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱使对象雷军唱出《Are you ok》前三句</span></span><br><span class="line">leijun</span><br><span class="line">  .hello()</span><br><span class="line">  .thank()</span><br><span class="line">  .thanks()</span><br></pre></td></tr></table></figure>
<p>如果按字面意思可能永远都理解不来，从而产生哲学三连：我是谁？我在哪？我在干什么？所以又有一句话得以解释：从哪里来，回哪里去。</p>
<h2 id="为什么用链式操作"><a href="#为什么用链式操作" class="headerlink" title="为什么用链式操作"></a>为什么用链式操作</h2><blockquote>
<p>新手村的Monad？</p>
</blockquote>
<p>所以作用很明显了，一种工厂流水线式的操作，流的形式完成任务。所以我要把这种设计模式归入函数式编程也是因为，函数式思想本来就是让数据经过所有“函数流”最后得到产物并返回。数据不变，不额外干涉操作。</p>
<p>不同的是，常规FP中，不管是单函数单返回走流，还是柯里化，它都是一种“一进一出”的思想——出来的产物继续传入下一道“工序”进行加工，一直到最后一个加工函数为止。</p>
<p>然而链式操作并不是这种哲学，它是一种“从第一次进入就买定离手”的操作——只要一开头传入参数，流不结束不会见到半成品。数据经过一层函数之后，可能经过加工处理结束后，又会被打包/压缩/处理到‘this’中并继续接下来的工作。</p>
<p>链式操作相对于柯里化来说，起码它做到了：</p>
<ul>
<li>可阅读</li>
<li>少占用</li>
<li>减少代码重复性（都有）</li>
<li>代码简洁（都有）</li>
</ul>
<p>柯里化最明显的优点就是阅读性差（？？？），假设有个方法叫<code>leijun</code>,那么调用方法的画风就大不相同</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leijun()()()</span><br></pre></td></tr></table></figure>
<p>鬼才知道他想唱的是“Are you ok”还是“Indian Mi Fans”呢……</p>
<p>还有就是，因为流操作可以异步。JS也是患有懒癌很多年了，必须靠事件驱动才能工作，所以注定它是不能异步编程的。</p>
<p>所以jQuery还是很强大的框架，在ES5什么都没有就靠三种规范的语法，已经要实现那么多东西了。让JS支持异步编程也就两种操作吧：函数内回调函数、链式操作函数。这框架两种都用上了。而说NodeJS速度快，一方面也是因为目前两个服务器框架都是异步（一堆回调函数）得到的结果吧。</p>
<h2 id="不止JavaScript能用"><a href="#不止JavaScript能用" class="headerlink" title="不止JavaScript能用"></a>不止JavaScript能用</h2><p>实际上本质就是，把执行权交给函数之后，函数执行完自己的工作之后，还可以吧执行权重新交回父级手中，让父级自行处理接下来的工作。</p>
<p>所以强化函数式编程的语言或者说能返回自身的语言应该都可以支持该模式，在这之后我只接触过<code>Golang</code>有这种操作，不过那当时哪来的Go啊…</p>
<p>这个世界本来就先有的FP，因为概念不够清晰才出现了OOP。现在业务量复杂到OOP已经不好解决了，这个时候人们又想起了凉了的FP。2018年如果前端继续发展下去，可能又会回到一个FP的年代（然后我要放弃FP看着它火了？不！这次看到希望不会撒手了！）</p>
<p>在我在无脑吹FP的时候（懂得概念不懂得实践），我看到了swift的出现，JAVA8强化λ，go的出现，TypeScript的出现（乱入，它强调OOP）。前几天看到了<code>haskell-react</code>，以后还会有什么？</p>
]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[冒泡排序的骚思路]]></title>
      <url>/blog/2017/12/20/exchange_number/</url>
      <content type="html"><![CDATA[<p>想起以前很容易就会被问到一个问题</p>
<blockquote>
<p>如何把两个数值进行交换？</p>
</blockquote>
<p>教科书式的编程怎么做？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k = i;</span><br><span class="line"></span><br><span class="line">i = j;</span><br><span class="line">j = k;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个数值，把其中一个寄存起来，然后再两次赋值。</span></span><br></pre></td></tr></table></figure>
<p>以前去写代码的社团，当时我巨活跃，有个师兄就过来说：看你资质不错，我打算亲自培养你，先问你一个问题吧：你如何把两个数值进行交换？写不出代码没关系，我只是要听思路。</p>
<p>我：什么跟什么交换？</p>
<p>师兄：随便你。</p>
<p>于是我打开了<code>sublime text</code>写下这么些东西</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">i += j;</span><br><span class="line">j = i - j;</span><br><span class="line">i -= j;</span><br></pre></td></tr></table></figure>
<p>然后师兄就懵了，你这个B不按套路出牌？</p>
]]></content>
      
        <categories>
            
            <category> 曲苑杂坛 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用JSX的VUE应用开发体验]]></title>
      <url>/blog/2017/12/11/vue-jsx/</url>
      <content type="html"><![CDATA[<blockquote>
<p>我说我是做外包的肯定没人信，给你看看外包程序员瞎几把搞的热情！</p>
</blockquote>
<p>前排提醒：vue-jsx和react-jsx相差甚远，前者基本就是玩具生产链。很多想利用JS语言特性的骚套路基本上都不好实现，而且感觉奇奇怪怪的。所以你的生产环境，千万不要乱试vue-jsx这种搭配，够简单就无所谓了…</p>
<a id="more"></a>
<h2 id="开局搭环境"><a href="#开局搭环境" class="headerlink" title="开局搭环境"></a>开局搭环境</h2><p>要什么环境，<code>vue-cli</code>就行了，又不是什么大项目大团队需要约定<code>webpack</code>。</p>
<h2 id="装插件"><a href="#装插件" class="headerlink" title="装插件"></a>装插件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install\</span><br><span class="line">  babel-plugin-syntax-jsx\</span><br><span class="line">  babel-plugin-transform-vue-jsx\</span><br><span class="line">  babel-helper-vue-jsx-merge-props\</span><br><span class="line">  babel-preset-env\</span><br><span class="line">  --save-dev</span><br></pre></td></tr></table></figure>
<p><code>.babelrc</code>主要是这个</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"transform-vue-jsx"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为其他的东西基本上都会有，主要是要添加这个东西。至此。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>没错的这文章本来是属于实践的又不是教程。还是要讲一下自己的体验的。</p>
<h3 id="渲染元素"><a href="#渲染元素" class="headerlink" title="渲染元素"></a>渲染元素</h3><p>感想最大的就是这个，Vue在使用jsx的时候很迷，最明显的感觉怪怪的地方有两个：</p>
<ol>
<li>它并不是哪个位置的方法都会有createElement函数的。</li>
<li>classes形式的组件找不到render函数！</li>
</ol>
<p>其实关于vue与jsx，tsx我是做了很多次尝试</p>
<p>首先第一种，常规的就是一个<code>object</code>对象，然后通过<code>Vue.component()</code>方法构建。这种可以说是我现在看来最没坑的一种形式了。平常的话还是像<code>*.vue</code>里的<code>script</code>标签一样，直接<code>export</code>打头开写，<code>&lt;template /&gt;</code>渲染部分移入了<code>render()</code>函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  render(<span class="comment">/* h / createElement */</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt; Hello World &lt;/h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况的结构与单文件的代码结构是相差无几的，不过换了种渲染方式而已，而且<code>render()</code>函数可以做一些与渲染相关的子方法，比如条件渲染之类的。所以总的来说：</p>
<p>优点：</p>
<ol>
<li>顺手，完全单文件中的<code>script</code>标签</li>
<li>没了</li>
</ol>
<p>缺点：</p>
<ol>
<li>这么搞肯定容易眼花啊！</li>
<li>不好维护，不直观</li>
</ol>
<p>第二种，如果是这种结构的tsx的话，与jsx同理。</p>
<p>第三种，class形式的组件，需要<code>vue-class-component</code>插件。然后可以写出类似于这样的东西</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;Hello World&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  @Component</span><br><span class="line">  export default class MainClass extends Vue &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>乍一看你还以为这是<code>Angular</code>呢！Vue在这方面真的是取长补短的典范。对这种的话，就比传统的方式要好多了，首先全局变量或者<code>data()</code>函数返回值变得特别清晰；再者是原来<code>methods</code>存放的函数可以以<code>class</code>形式的函数来写，那<code>computeds</code>怎么办？直接用<code>get/set</code>关键词，太方便了有没有！</p>
<p>好了关键的来了…</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  get render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt; Hello World &lt;/h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// render or template not defind.</span></span><br></pre></td></tr></table></figure>
<p>这是什么鬼，可能是我操作不当，但是不加<code>get</code>的话不会注入createElement，但是这又是个<code>render()</code>函数，本来不需要加什么前缀的。但是不加有感觉会不会把<code>render()</code>函数识别成是传统写法中存在于<code>methods</code>的函数。</p>
<p>官方在自动注入这方面有一个栗子的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'jsx-example'</span>, &#123;</span><br><span class="line">  render () &#123; <span class="comment">// h will be injected</span></span><br><span class="line">    <span class="keyword">return</span> &lt;div id="foo"&gt;bar&lt;/div&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  myMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// h will not be injected</span></span><br><span class="line">    <span class="keyword">return</span> &lt;div id="foo"&gt;bar&lt;/div&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  someOtherMethod: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// h will not be injected</span></span><br><span class="line">    <span class="keyword">return</span> &lt;div id="foo"&gt;bar&lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  get computed () &#123; <span class="comment">// h will be injected</span></span><br><span class="line">    <span class="keyword">return</span> &lt;div id="foo"&gt;bar&lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>h</code>就是<code>createElement</code>的别称，而且在jsx的话一般都是不用写的。所以这个函数注入的就有点迷了，不过根据亲测，在<code>methods</code>定义的函数是有<code>h</code>的，可能最后也会在<code>render</code>函数里调用吧。</p>
<p>后来我尝试两三个星期之后，我就放弃了classes形式的jsx写法，等过几天又有经历的时候再继续尝试。目前自己在用的两套写法：例如<code>Hyper</code>那种的classes形式的vue+ts，传统方式的jsx。</p>
<p>还有就是，对于vue来说，有时候要时常关心<code>h</code>函数有没有被注入，这是一件挺不愉快的事情的。比如说你写了一个渲染函数，然后运行的时候发现惨了凉了函数刚好在渲染范围之外（比如把函数直接分离出去，并不存在于<code>render</code>函数中），这是不运行的，那怎么做？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">h, args</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>就是这样的！必须在render函数中调用而且<code>h</code>必须是第一个参数！不然不是报错就是不渲染！</p>
<h3 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h3><p>可能是解决刚刚提到的“经常找不到自动注入函数”的困扰吧。多了一个这么个东西。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  functional: <span class="literal">true</span>,</span><br><span class="line">  </span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个关键词<code>functional</code>声明这个位置是个函数式组件。函数式可以直接看做一个能主动注入<code>h</code>的函数，因为它没有状态的，甚至是个RBQ，用完就丢（死无全尸，在组件树是看不到的，依托父组件生存）。同时最大的特点也就是可复用。想想<code>react</code>一个正常语法函数就能搞定的事情…</p>
<p>有利有弊，这种组件因为没状态，用过就丢，所以它需要的数据全靠传递。也就是单向数据，从父组件 -&gt; props -&gt; 处理 -&gt; 输出 -&gt; 销毁一条龙。很简单就是把它看做是<code>render</code>里面的一个函数就行，本意也是如此。</p>
<p>所以这种组件就两个接收参数：负责渲染的<code>h</code>，负责上下文<code>context</code>。各种所需的乱七八糟都在<code>context</code>中，比如全程最重要的<code>props</code>。而且多数组件的参数都有调整：</p>
<blockquote>
<ul>
<li><code>props</code>：提供 props 的对象</li>
<li><code>children</code>: VNode 子节点的数组</li>
<li><code>slots</code>: slots 对象</li>
<li><code>data</code>：传递给组件的 data 对象</li>
<li><code>parent</code>：对父组件的引用</li>
<li><code>listeners</code>: (2.3.0+) 一个包含了组件上所注册的 <code>v-on</code> 侦听器的对象。这只是一个指向 <code>data.on</code> 的别名。</li>
<li><code>injections</code>: (2.3.0+) 如果使用了 <a href="https://cn.vuejs.org/v2/api/#provide-inject" target="_blank" rel="noopener"><code>inject</code></a> 选项，则该对象包含了应当被注入的属性。</li>
</ul>
</blockquote>
<h3 id="JSX的一些小区别"><a href="#JSX的一些小区别" class="headerlink" title="JSX的一些小区别"></a>JSX的一些小区别</h3><p>因为我还没怎么体验过<code>react</code>，所以就只有一个关于dom书写的区别。在<code>react-jsx</code>中，<code>class</code>可是会被识别成关键词的，所以做样式的<code>class</code>要写成<code>className</code>，但在<code>vue-jsx</code>是不需要的。可能一开始这么做没想过后面竟然还有<code>class-component</code>的需求吧。</p>
<p><code>vue</code>现在大多奇技淫巧都是基于社区的各种<code>babel</code>插件，并不像<code>react</code>两个官方库皇帝级别支持，也不像<code>angular</code>自从诞生时期就声明“劳资要用TypeScript作为开发语言，你不用也得用ES6形式！”</p>
<p><code>vue-jsx</code>这种写法我现在也会用，搞点小的就直接这么写，而且这么做实际上思路会清晰一点——像在写一个应用而不是写一个网页，你只需要把dom相关的字段脑里想成一个字符串或者一个子函数就行了。（只是老遇到一些乱七八糟的问题）</p>
<p>（<code>angular</code>与<code>angular.js</code>至今还是两种东西，不要乱了）</p>
]]></content>
      
        <categories>
            
            <category> 实践尝试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[扯扯柯里化]]></title>
      <url>/blog/2017/12/07/about-currying/</url>
      <content type="html"><![CDATA[<blockquote>
<p>在我的博客打开开发者工具 -&gt; console，输入 Nlvi.tools.scroll 试试？</p>
</blockquote>
<p>开个玩笑，我自己也不知道这算不算柯里化（逃</p>
<p>总之为什么这么写，我自己觉得这样容易理解，方便盲僧（理清）。</p>
<p>还有最近关于“如何治理别人爱装逼的毛病”系列中刚写的一坨，新鲜的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> menuItem = <span class="function">(<span class="params">list</span>) =&gt;</span> </span><br><span class="line">      list.map(<span class="function">(<span class="params">&#123;title, color, icon, descs&#125;</span>) =&gt;</span> </span><br><span class="line">        &lt;menu-item title=&#123;title&#125; color=&#123;color&#125; icon=&#123;icon&#125;&gt;&#123;</span><br><span class="line">          descs.map(<span class="function"><span class="params">v</span> =&gt;</span> &lt;span&gt;&#123;v&#125;&lt;<span class="regexp">/span&gt;)&#125;&lt;/m</span>enu-item&gt;)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="柯里化是什么？"><a href="#柯里化是什么？" class="headerlink" title="柯里化是什么？"></a>柯里化是什么？</h2><p>好了讲柯里化，就是<strong>接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。柯里化属于函数式编程的内容</strong>。</p>
<p>在这里有一个<a href="http://www.zhangxinxu.com/wordpress/2013/02/js-currying/" target="_blank" rel="noopener">张鑫旭博客</a>讲关于柯里化（柯南嗑药）的例子，很方便理解。当然我想讲点自己的东西，拿<code>Nlvi.tools.scroll</code>说一下吧</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tools.scroll = <span class="function"><span class="keyword">function</span> (<span class="params">win</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    $(win).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> sct = $(win).scrollTop();</span><br><span class="line">      fn &amp;&amp; fn(sct);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实际上如果不作的话，这样就结束了</span></span><br><span class="line">tools.scroll = <span class="function"><span class="keyword">function</span>(<span class="params">win, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> $(win).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sct = $(win).scrollTop();</span><br><span class="line">    fn&amp;&amp;fn(sct)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以函数柯里化看上去有一个特点，会嵌套函数。而且道理就跟柯里化的解释一样：用一些参数，剩下的函数作为返回值里的函数的参数。这样我在调用的时候怎么调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scrollTop = Nlvi.tools.scroll(<span class="built_in">window</span>);</span><br><span class="line">scrollTop(<span class="function"><span class="keyword">function</span>(<span class="params">sct</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>首先我给个变量（实际上ES6直接用<code>const</code>，毕竟固定量）引用这个方法，方法传入第一个参数。接着里面的函数返回值函数是接收一个函数变量。</p>
<p>理一下，函数 - 的返回值 - 是个函数，这个函数接收一个 - 函数 - 的 - 变量。</p>
<p>然后这个函数参数传进去之后，实际上就是传一个方法进去以便于我等下里面的逻辑走完之后可以把这个函数参数运行起来，行程一个特别做作的回调函数。（当然回调函数带的是当前滚动条的数据）</p>
<p>为什么这么做呢？一点就是我觉得这样思路就清晰多了，而且在调用区域写起来干净。第二点就是参数复用。</p>
<p>虽然这个例子看不出什么，但是难免会遇到一些情况，就是明明一个变量或者一个参数，我只要取一次然后调用一次之后，剩下的内容我只要在这个情况之上去处理就行。但是如果传统单函数的做法的话，就会使得这个局外参数也跟着在里面做一些乱七八糟的运动，比如跟着去递归，被扯着去多次判断，这样就会莫名其妙浪费了一堆性能。很简单我举个例子：4x100，明明你交接之后剩下的就接下来的人跑就行了，你非得交接之后跟着跑，边跑边喊加油？</p>
<p>第三点就是延时</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line"><span class="comment">// normal</span></span><br><span class="line"><span class="keyword">var</span> nSum = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  total += num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//currying</span></span><br><span class="line"><span class="keyword">var</span> cSum = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> nums = []</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, nums)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Array</span>.prototype.push.apply(nums, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = cSum(<span class="function">(<span class="params">x</span>) =&gt;</span> total += x)</span><br></pre></td></tr></table></figure>
<p>如果是常规的话，那么肯定会立刻计算出结果，而柯里化之后，会把计算的步骤储存起来，然后一起计算。</p>
<h2 id="柯里化误区"><a href="#柯里化误区" class="headerlink" title="柯里化误区"></a>柯里化误区</h2><p>在写这篇东西的时候，我关注到了一尊大神的博客 <a href="http://www.cnblogs.com/pengchen/p/5434705.html" target="_blank" rel="noopener">JavaScript函数柯里化的一些思考</a>，吓得我赶紧回看了自己的函数有没有“画蛇添足”的成分。嗯。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿下来继续学习一下</span></span><br><span class="line"><span class="keyword">var</span> scrollTop = Nlvi.tools.scroll(<span class="built_in">window</span>);</span><br><span class="line">scrollTop(<span class="function"><span class="keyword">function</span>(<span class="params">sct</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>这里我想到的是，我只需要把<code>window</code>传到这个函数之后引用出一个新函数，然后我就可以带着这个函数跑了，如果是不嫌麻烦版本的话我需要则么做？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tools.scroll = <span class="function"><span class="keyword">function</span>(<span class="params">win, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> $(win).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sct = $(win).scrollTop();</span><br><span class="line">    fn&amp;&amp;fn(sct)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// and so</span></span><br><span class="line">tools.scroll(<span class="built_in">window</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>这样就会造成，我每次想监听滚动的时候，每用一次这个方法，我就要把<code>window</code>传进去一次。如果包一下的话，我就可以拿后面那个函数走就行了，也就是我的<code>window</code>只要传一次就畅通无阻。这也是另一个好处：分段计算。好比我玩Switch，我在外面突然想玩马车的时候，如果我的卡带在卡包里，那我换上就可以玩了，就不需要等回到家把卡带从包装盒里拿出来装到机器上。</p>
<p>实际上到这里的话应该有所经验了，到这里还会不会觉得<code>apply(), call(), bind()</code>使用机会少之又少？这就是数学的魅力吧，可是我数学不好。</p>
<h2 id="柯里化-lt-gt-闭包函数？"><a href="#柯里化-lt-gt-闭包函数？" class="headerlink" title="柯里化 &lt; - &gt; 闭包函数？"></a>柯里化 &lt; - &gt; 闭包函数？</h2><p>又是每期一问了，柯里化跟闭包函数是否也有关系？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 经典面试题</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">             setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;,<span class="number">0</span>)</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，柯里化函数和闭包函数应该怎么区分？还是的确有联系？</p>
<p>最后感谢所有被引用的文章及其作者，感谢帮助学习。</p>
]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[你还在用Console.log()？]]></title>
      <url>/blog/2017/11/20/js-console/</url>
      <content type="html"><![CDATA[<blockquote>
<p>也许主题应该改为：你只会使用Console.log()？</p>
</blockquote>
<p>现在的前端虽说是越来越复杂，但是我怎么觉得现在前端的要求越来越低了？应该说现在的人，看个几遍vue，知道console.log()，知道var, {}, []，就敢出来找工作了。但是<code>console</code>就这么个方法？</p>
<p>搞笑，你在你的浏览器输入<code>console</code>，自己看看有多少东西！所以为了高效调试我觉得有必要全了解一遍。<br><a id="more"></a></p>
<h2 id="log-info-error-warn"><a href="#log-info-error-warn" class="headerlink" title="log(), info(), error(), warn()"></a>log(), info(), error(), warn()</h2><p>这几个放在一起讲</p>
<blockquote>
<p>log() 普通输出</p>
</blockquote>
<p>这是最普通，最常见，最没什么东西好讲的。输出的样式是普通样式。</p>
<blockquote>
<p>info() 提醒输出</p>
</blockquote>
<p>这是一个早期chrome才能看到的效果，现在的FireFox也能看到，是一个圆形中间一个叹号的标记。作提醒作用。chrome不是不会显示，是显示成普通样式。</p>
<blockquote>
<p>error() 错误输出</p>
</blockquote>
<p>这个应该跟<code>log()</code>同个使用数量级的，表示错误，大红颜色。chrome表现是一整行都是红色的，很显眼。用来显示错误信息。比如throw 错误之类的。如果一套都是<code>log()</code>的话肯定很难一眼看到错误。珍爱视力，路还长着…</p>
<blockquote>
<p>warn() 警告输出</p>
</blockquote>
<p>就是警告咯，可能用的比较少，但是工具类和一些库肯定会容易看到，原来跟<code>info()</code>平起平坐，现在应该是替代了。显示效果会显眼的黄色，chrome会有黄色背景。</p>
<blockquote>
<p>debug() 调试输出</p>
</blockquote>
<p>这个就是<code>log()</code>，用来输出调试信息的。不过现在的调试信息都在花式<code>log()</code>，也不需要用到这个了。</p>
<h2 id="exception-debug"><a href="#exception-debug" class="headerlink" title="_exception(), debug()"></a>_exception(), debug()</h2><p>这组只有两个，因为这两个没卵用…为什么…</p>
<blockquote>
<p>_exception() 例外输出</p>
</blockquote>
<p>说白了就是用来输出错误的，那错误不能用<code>error()</code>吗？！</p>
<blockquote>
<p>debug() 调试输出</p>
</blockquote>
<p>早期可能还有区别，但是这就是一个<code>log()</code>，不过现在各前端都在花式<code>log()</code>调试信息，可能也有些人<code>debug()</code>都没听说过。</p>
<h2 id="assert-…-clear-count"><a href="#assert-…-clear-count" class="headerlink" title="assert(…), clear(), count()"></a>assert(…), clear(), count()</h2><p>为什么第一个函数搞了三个点？</p>
<blockquote>
<p>assert() 断言输出：判断第一个参数是否为真，false的话抛出异常并且在控制台输出相应信息。——MDN</p>
</blockquote>
<p>从这里开始就要骚了，这是一个判断的方法，里面需要填写参数，然后得到返回值。如果值为真，就什么都不会发生，反之则以<code>error()</code>通知你。这是个多参数的，除了第一个参数之外，后面接的参数是被输出的对象也好，字符串也好，并且会拼接。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.assert(<span class="number">1</span>&gt;<span class="number">2</span>, <span class="string">"你这么骚的？"</span>)</span><br><span class="line"></span><br><span class="line">Assertion failed: 你这么骚的？ <span class="comment">// 假装这里是红字红色背景</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>clear() 清空控制台</p>
</blockquote>
<p>就是把控制台全清空，terminal里面的<code>clear</code></p>
<blockquote>
<p>count() 次数输出：以参数为标识记录调用的次数，调用时在控制台打印标识以及调用次数。——MDN</p>
</blockquote>
<p>并且MDN明确指出，这个不应该列入正常使用范围，因为这是非标准方法。这是这组里最骚的方法。用来输出本身被调用了几次…虽然如果测试循环的话，一般都直接log(i)的，直接看1234567不是更明确嘛。显示效果就是，每运行一次就会在控制台打印 n + 1。</p>
<h2 id="dir-dirxml"><a href="#dir-dirxml" class="headerlink" title="dir(), dirxml()"></a>dir(), dirxml()</h2><p>这两个一起说是因为，有相同点和不同点。</p>
<blockquote>
<p>dir() 对象结构输出</p>
<p>dirxml() 节点结构输出</p>
</blockquote>
<p>这两个都是输出一个树状结构，就是前面有个小三角。但不同点就是，<code>dir()</code>是把一个对象按照对象的形式呈现，当然用来输出节点就是把节点信息按object呈现。<code>dirxml()</code>是把节点呈现出来，就还是保留xml的样式呈现。都是非标准，偶尔用用还行？</p>
<h2 id="group-groupCollapsed-groupEnd"><a href="#group-groupCollapsed-groupEnd" class="headerlink" title="group(), groupCollapsed(), groupEnd()"></a>group(), groupCollapsed(), groupEnd()</h2><p>这是上面那组的正房版。都是打印结构。我就不一行一行解释了有点累…</p>
<p>第二跟第一都是打印树状结构，但是第一个会自动打开显示结构里面有什么结构（没问题的），第二个叫内联树状，默认不打开。</p>
<p>而且只要你不结束，你可以一直联下去的，这样一个父节点可以一直续下去…直到通过<code>groupend()</code>来结束。</p>
<h2 id="table-…"><a href="#table-…" class="headerlink" title="table(…)"></a>table(…)</h2><p>我必须强调！<strong>这是最棒的我最喜欢的console方法，没有之一！</strong></p>
<blockquote>
<p>table() 表格输出</p>
</blockquote>
<p>这个方法必须传入内容，内容的类型是array或者object，输出的样式是一个key:value的表格！如果你觉得输出成对象不方便检查的话，那就用<code>table()</code>吧！（当然在表格下方还是会return一次对象或者数组）</p>
<p>而且不仅是key:value，<strong>你甚至还能多元数组！对象套对象！甚至是JSON！</strong></p>
<h2 id="另外的技巧就是可以用占位符了"><a href="#另外的技巧就是可以用占位符了" class="headerlink" title="另外的技巧就是可以用占位符了"></a>另外的技巧就是可以用占位符了</h2><p>跟C语言的<code>printf()</code>没有区别，就是可以利用占位符然后再把参数接在后面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"%d年%d月%d日"</span>,<span class="number">2017</span>,<span class="number">11</span>,<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p>最后感谢MDN，也感谢AlphaGo！</p>
]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[引用等于指针吗？]]></title>
      <url>/blog/2017/10/17/reference-equal-pointer/</url>
      <content type="html"><![CDATA[<blockquote>
<p>一篇思考文，关于JS的reference和Go的指针。（臆想型论文？）</p>
</blockquote>
<p>最近投入大量时间接触<code>Golang</code>，了解“指针”的时候，想起了以前学习C语言时对“指针”的疑问：指针是什么。</p>
<p>以前还小不理解指针和野指针，只知道野指针会出现内存溢出或者值不正确的情况。而且网上大多讲指针的文章看起来都很难。就像现在的知乎：一句话能说清楚的东西恨不得从它的诞生还是写起。就连LOL赛评也是这副P样。</p>
<p>以至于我后面对C语言没好感，对C++厌恶，对有“指针”的语言直接没兴趣。</p>
<p>在看到Go的指针的时候，我已经想放弃了。但是想回来，毕竟上一次接触指针已经6年了，也许现在看就能理解出什么呢。（过程中接触的OC根本不能算经验，因为当时完全就是靠抄靠背来写iOS应用，最后还是嫌弃OC麻烦进阶无法理解去学习了swift）<br><a id="more"></a></p>
<h2 id="Reference-Pointer"><a href="#Reference-Pointer" class="headerlink" title="Reference == Pointer?"></a>Reference == Pointer?</h2><p>以前看到什么内存地址啊，指向啊就已经乱了，满脑子都在想内存里面是什么样的，内存地址，寄存器又是什么东西。跟着官方教程走了一遍，了解到<strong>指针就是通过一个变量去指向一个有的变量或者说是对象，从而产生一种绑定。通过修改指针变量也可以达到修改本体的效果</strong>。</p>
<p>这让我想到JS，因为每天都在操作对象，知道：如果你要建立一个新的变量，比如<code>a = 1</code>，我可以通过<code>var b = a</code>得到一个新的变量。但是如果是对象则不是。如果是<code>a = {};  var b = a</code>的话，b只是单纯指向了a，并没有复制a</p>
<p>所以我立刻去搜索<em>关于JavaScript的指针</em>。得到这么一个结果 <a href="https://www.baidu.com/link?url=2Xxo3-ptdvabLARr0p-DcoBbeysd2lvRxH-jEevvWHBJ7pNBk-mkxGqaB6h8UTWVRi-2lc56zjWVMYPUgv6tfK&amp;wd=&amp;eqid=e1820c9600002f360000000659e5b92d" target="_blank" rel="noopener">JavaScript 的<em>指针</em>是什么? - 知乎</a></p>
<blockquote>
<p>JavaScript 里头什么时候有指针的概念？倒是有 reference （引用）的说法。 —— <a href="https://www.zhihu.com/people/sansmana" target="_blank" rel="noopener">陈木野</a></p>
</blockquote>
<p>关于this的总结，不单我自己，网络上已经大量的文章了。不管是详细解析，还是总结，都已经很多了。但是如果说：指针就是一种指向变量的话，那JavaScript就很多了，遍地都是。而这样的话，就跟reference有关系了。</p>
<p>说起来也是邪门了，今天打算把《红宝书》拿出来翻一下，翻到了第四章4.1.2，看到了这么一句</p>
<blockquote>
<p>当使用 num1 的值来初始化 num2 时，num2 中也保存了值 5。但 num2<br>中的 5 与 num1 中的 5 是完全独立的，该值只是 num1 中 5 的一个副本。</p>
<p>当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到<br>为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一<br>个对象。复制操作结束后，两个变量实际上将引用同一个对象。</p>
</blockquote>
<p>于是我的想法 “引用是一种指针” 或许成立。（复习有好处的！）</p>
<h2 id="Point-Reference"><a href="#Point-Reference" class="headerlink" title="Point == Reference"></a>Point == Reference</h2><p>如果反过来，还能成立吗？我觉得不行。</p>
<p>C++，让我很崇拜很信仰的，却因不理解和学不会让我产生厌恶的语言，在这方面是两者皆有。由于根本不懂所以不参加讨论。</p>
<p>Java，他也有reference，但是在<a href="https://www.baidu.com/link?url=bI4EsfOKw8lfPjTwX3_gY7pbn2LFMOwmFPmoalBBNr7lFCv9ZltHfuravfoA7uVHrNJtSUxm0Epjk-IW5Zr2z_&amp;wd=&amp;eqid=ee91ddc5000508bd0000000659e60253" target="_blank" rel="noopener">Java的<em>Reference</em>感觉很象C++的<em>指针</em>,但是区别是本质的 - f…_博客园</a> 提到：</p>
<blockquote>
<p>Java中你无法对这个地址进行任何数学运算，并且这个地址你不知道，是Java Runtime分配给你的，它随时还要调整这个地址（After GC,Memory要Compact，这时候一个Object Reference的地址就会改变）。</p>
</blockquote>
<p>我不是很理解，所以我也不敢评论什么。我只想关于Go和JS的东西。</p>
<p>也许是心理隔阂，也许是真理。我怎么都想不出怎么让“指针是一种引用”成立。</p>
<p>老是想内存内存，不如想成一个盒子，指针就是给盒子里的东西连了一条线。这样做就不用我找这个东西的时候去盒子里找，而是直接去找这条线？</p>
<p>可是在JS中，引用也不能修改和做任何运算吗？</p>
<h2 id="Reference-Pointer-1"><a href="#Reference-Pointer-1" class="headerlink" title="Reference === Pointer?"></a>Reference === Pointer?</h2><p>我不是语言专家，我一点都不敢保证。或者说我不懂。</p>
<p>我不知道所谓的指针是什么东西，但是我知道<code>reference</code>是一个<code>object</code>，毕竟不知道哪篇文章写道：函数是JavaScript第一公民。但并不是很纯的函数式编程语言。</p>
<p>其实思考到现在，我又有新的问题了：<strong>前端语言，或者说函数式编程语言，有没有内存，指针一说？</strong></p>
<p>不过现在可以知道的是：</p>
<p>​    在指令式编程中，数值就是数值，一切工作之后无非就是想得到一个值，过程中也在围绕着值。</p>
<p>​    在函数式编程中，函数还是占主要地位，它需要以数学的方式去解决编程的问题。</p>
<p>那我现在可不可以有一种新的理解：</p>
<p>​    比如C语言这种，他定义指针是需要 <code>*</code> 这种东西，也就是<code>int *a = b</code>是用a指针指向b，我可以通过a来修改b。但是如果直接<code>int a = b</code>的话，我就相当于复制了这个变量了，没权修改b变量了。而如果<code>int a</code>是一个函数的话，那它最后也需要返回一个<code>int</code>返回值。所以它并没有“用函数搞事”的权利。</p>
<p>​    而JS语言这种，我想用一个代码框来写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 还是根据红宝书的例子</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;	<span class="comment">// 一种复制，相互独立</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = &#123;<span class="attr">a</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> y = x	<span class="comment">// 一种引用，实际上操作y的时候还是在操作x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//现在暂时借用一下以 _ 代替*</span></span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">5</span> &#125;</span><br><span class="line"><span class="keyword">var</span> _b = o.a	<span class="comment">// 达到继承的目的？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var _b = int *b   在某种意义上？</span></span><br></pre></td></tr></table></figure>
<p>在红宝书接下来有一句：</p>
<blockquote>
<p>换句话说，obj1和 obj2 都指向同一个对象。这样，当为 obj1 添加 name 属性后，可以通过 obj2 来访问这个属性，<br>因为这两个变量引用的都是同一个对象。</p>
</blockquote>
<p>按我的角度翻译一下，就是：<strong>我定义一个b出来，无非就是给a多了一个出口</strong></p>
<p>所以综上所述，我认为，对我来说，或者对C系除外的语言来说，<strong>把“指针”说成“指向”，或许让人更好理解。</strong></p>
<p>哼，计算机真是有趣。</p>
<p>（最后感谢所有被引用的文章和作者，谢谢。）</p>
]]></content>
      
        <categories>
            
            <category> 编程议论 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用桌面应用写hexo博客是什么体验？]]></title>
      <url>/blog/2017/09/19/what-the-feeling-about-hyper/</url>
      <content type="html"><![CDATA[<blockquote>
<p>稳的稳的，这次真是为了需求造轮子了。Hyper = Hexo + Typer. </p>
</blockquote>
<p>接触到hexo是因为，hexo可以是一个前端博客生成器，直接生成一个前端静态页面，做到可以上传到github“个人页面”作为博客网站。</p>
<p>不过，毕竟是基于<code>node</code>的生成器，编写过程很geek。首先创建和预览甚至发布，依赖<code>terminal</code>和<code>node</code>。你要使用一个你喜欢的<code>markdown</code>编辑器，或者直接就在代码编辑器搞例如<code>vscode</code>。原来我也是用这个写博客。因为自带了<code>terminal</code>，直接创建了搞完直接上。后来生活逐渐好点，用的 iterm2 + zsh 之后，编辑器改用了<code>Typora</code>。然而关于这段的话，我上一篇<a href="http://blog.co1mugx.tk/2017/08/22/do-markdown-hexo/" target="_blank" rel="noopener">搞electron+vue+webpack2+TypeScript什么体验</a> 已经讲得够多了，所以不赘述了。</p>
<p>但是现在，可能生活会更好了…</p>
<p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/1.png" alt=""></p>
<a id="more"></a>
<h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><p>这是个<code>electron</code> + <code>Typescript</code> + <code>vue</code>的产物。也就是首先它是桌面应用了，由于<code>electron</code>意味着它可能可以跨平台。不过我没有想过…所以现在是 MacOS 版本。</p>
<p>为什么想起写这个，原因就两点</p>
<ul>
<li>原来的方式太过于繁琐，甚至感觉不到自己是在写博客。</li>
<li>对计算机理解和操作都不是顺畅的人会带来很多麻烦。</li>
</ul>
<p>博客博客，文字记录自己的生活或者技术探讨。多少写手或者说喜欢分享的人，喜欢hexo又不会用没办法用。当分享被技术限制之后，那么写文章也就不是专注于文章了。（比如我写文章也一直很跳，跟性格有关吧）</p>
<p>所以我才想要实现这么个东西，实际上在早之前就已经打算了，当时前端太菜。也不知道<code>electron</code>是什么东西。还是个<code>swift</code>新教徒的时候。有想过用MacOS 原生的方式去做这个东西，后来放弃了，原因还是因为技术上的问题。</p>
<p>这次实现这个东西的时候，巧了，跟<a href="http://www.ahonn.me" target="_blank" rel="noopener">@Ahonn</a>几乎不约而同的想到了一起。他也说他很早就想做了，不过大神不是因为技术原因，而是开坑不填工期延后…</p>
<p>不过他的实现方式是不同的，他想使用<code>cljs</code>去实现这个东西。我为了求稳，还有还是熟悉一下<code>TypeScript</code>作为脚本使用的感觉，用了这么套技术栈。</p>
<p>Ahonn的项目地址是这个：<a href="https://github.com/ahonn/hexdit" target="_blank" rel="noopener">ahonn / hexdit</a>。利益相关的话：还是算关系挺好的校友吧…</p>
<h2 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h2><p>不搞事情，不吹牛逼，这次为了 <del>装逼</del> 测试一下软件大概“正常使用”有没有什么问题。所以这次我这篇文章完完全全使用<code>Hyper</code>创建、编写、保存、修改，甚至我等下生成发布也直接用这个。</p>
<p>确实，这才像在写博客。</p>
<p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/2.png" alt=""></p>
<p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/7.png" alt=""></p>
<p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/9.png" alt=""></p>
<p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/10.png" alt=""></p>
<p>我甚至都不怕被你看！</p>
<p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/5.png" alt=""></p>
<p>（因为编辑器的样式还有预览的样式还没上，所以现在看起来还是很丑的，不过测试功能嘛，我等下还会用其他编辑器看）</p>
<p>但不管怎么说！就是好看！<strong>简就是美！甚至还有点少女心！</strong></p>
<p>在首屏直接载入<strong>整个博客程序文件夹</strong>之后，就会到达这个界面，左边是显示你当前博客程序里面的文章（名字我都不怕给你看，这名字最后会显示到网址上！），文章列表上面三个按钮分别是 “创建”，“预览”，“生成/发布”。每一个文章名称前面一个“绿色的勾”是提醒你，当前这篇文章是可见的。没错文章可以是隐藏的，这在<code>hexo</code>的文档上有提到，<code>source</code>文件夹中不会上传文件名前带’_’的文件。所以自然可以过滤“草稿”和“不想发布”的文章。所以隐藏的文章会显示一个红色的叉。</p>
<p>点击想编辑的文章之后，其实会有动画回馈，但是不会常驻高亮。然后右边会跳出目前文章的内容以及一些编辑文章会用到的功能。实际上我应该做一个当前编辑文件高亮的！</p>
<p>右边编辑区中第一个“笔样子”的图标我是放着玩的…一些测试的工作会挂在上面当starter。然后保存和删除这个应该能看懂。右边有个开关，这个开关就是作为<strong>“选择当前文章是否隐藏”</strong>的作用。当然如果是<code>off</code>状态的话就是显示了，默认也是显示的。最右边的“X”就是关闭当前编辑区咯。</p>
<p>下面一整个编辑区，写文章可以用，不过<code>markdown</code>了，应该熟悉的是不会用到的吧，可能会用到两个功能：一个是全屏编辑，一个是分屏编辑。噢插入表格也可以有，<code>markdown</code>的表格真是蛋疼。</p>
<h3 id="另外还给对hexo不熟悉的写手准备了一个大功能。"><a href="#另外还给对hexo不熟悉的写手准备了一个大功能。" class="headerlink" title="另外还给对hexo不熟悉的写手准备了一个大功能。"></a>另外还给对hexo不熟悉的写手准备了一个大功能。</h3><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/3.png" alt=""></p>
<p>那就是简易设置了！漂不漂亮我不敢说！反正我就喜欢清静的感觉，看看<code>Nlvi</code>！是不是还有一股禅意！</p>
<p>截图的信息是我在做测试的时候，我当前导入的是当时用来测试主题功能的一个示例博客，官方提供的。毕竟不敢把自己的博客导入进去，万一弄瞎了不就真瞎了…</p>
<p>就我遇到的很多情况看，还是会有刚接触前端或者刚接触hexo的人不知道hexo的配置文件应该是怎么弄的。虽然我在<a href="https://github.com/ColMugX/hexo-theme-Nlvi" target="_blank" rel="noopener">hexo-theme-Nlvi</a>里面写到：如果主题有使用问题的话，你可以提ISSUE，或者直接到知乎上锤我！</p>
<p>但事实上，很多给我知乎发私信的同学，问的都基本不是主题使用的问题，反而是博客本身的使用问题。所以我重新整理了博客配置文件，并把一些比较重要的，必须要的功能作为一张设置界面出来，这样就方便使用了。只要这张填的满，按道理说博客的显示和发布就没问题了。</p>
<p>而且这张设置界面就这么多内容，在地址设置下面也就多了一个“文章代码是否高亮”和“部署地址”。这样而已。然后就可以保存完事。</p>
<p>由于还是在测试和进一步编写。所以一些难看的目前用不到的我都<code>display:none</code>了，所以看不到完整设置。</p>
<p>初来乍到，第一次写这种软件，还是有很多问题的。如果你看到问题了还希望你能帮我指正。我也是想服务一下社区，给喜欢但是不会用的人一点帮助。</p>
<h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>其实介绍文章按正常来说到上面就结束了。这也是为什么 “是什么 -&gt; 为什么 -&gt; 怎么做”反而是这种顺序。</p>
<p>关于是什么，应该很多人都不愿意去关心了，这里是我想记录的一些心得和学习遇到的坑。</p>
]]></content>
      
        <categories>
            
            <category> 实践尝试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> electron </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搞electron + vue + webpack2 + TypeScript什么体验]]></title>
      <url>/blog/2017/08/22/do-markdown-hexo/</url>
      <content type="html"><![CDATA[<p>本来是想放弃的，后来歪打正着，成功运行。最后搞一个ts类型的启动器，不想再懵了。</p>
<p><a href="https://github.com/ColMugX/vue-ts-electron-starter" target="_blank" rel="noopener">vue-ts-electron-starter</a></p>
<p>想看看原项目<code>electron-vue</code>有没有这个打算，没有的话自己fork个分支出来。这个将就。</p>
<p>这次搞这个项目目的就很明显了，想做一个Hexo博客的编辑器（没错就是我这个博客的核心）。Hexo的话，属于页面生成器类的博客系统。直接一套生成静态页面，然后随意访问。因为一整套静态页面故还是有人喜欢直接干一套SPA上去，体验也好。</p>
<p>其实搞这个，我去年就想搞了。可是去年的话，明显前端的技术都不扎实更别说搞了，当时的想法是写一个Mac App（我swift应该还行，随便写写问题不大。不过可能现在的话问题就大了）。不过就一直拖拖拖，导致swift3.0都有苗头了我还是没想写。而且关于如何操作terminal命令，还是个问题。</p>
<p>这次心就大了。搞了再说，搞一半不行了就让他荒了。以后想起来再搞，再搞的时候技术肯定又上涨。如果这波做成了，开源，我不管有没有人用，总有人喜欢用。<br><a id="more"></a></p>
<h2 id="讲在前面"><a href="#讲在前面" class="headerlink" title="讲在前面"></a>讲在前面</h2><p>在这之前我用的是<a href="https://github.com/CodeFalling/blog-admin" target="_blank" rel="noopener">CodeFalling / blog-admin</a>。这是一个Emacs的插件，当然spacemacs也能弄来用一下。这是一个在github很活跃的大神写的（我经常看到，同时也是hexojs成员），也是很出名的Emacs教徒。不过据说他现在用的是webstorm + vim插件了…</p>
<p>当然今天不想吹Emacs，而且工作上我也不敢用Emacs，原因不说。</p>
<p>其实就是一直想做一个方便用一点的。在emacs之前我都是开一个terminal+一个编辑器来做的。在emacs之前是用<code>typora</code>和<code>vscode</code>做的。总这样不好吧太麻烦了。而且这东西又算刚需…所以算了，还是尝试一下吧，顺便把<code>electron</code>和<code>vuex</code>给学清楚了，而且顺便练一下<code>TypeScript</code>。</p>
<p>所以这次打算的技术选型是：</p>
<ul>
<li>TypeScript</li>
<li>electron</li>
<li>vue</li>
<li>vuex</li>
</ul>
<p>electron + vue环境的话，直接使用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">SimulatedGREG/<em>electron-vue</em></a>，这样<code>electron</code>，<code>vue</code>，<code>webpack</code>就都完成了。如果针对<code>TypeScript</code>的话<code>webpack</code>应该要小改一下。</p>
<h2 id="为什么使用TypeScript"><a href="#为什么使用TypeScript" class="headerlink" title="为什么使用TypeScript"></a>为什么使用TypeScript</h2><p>TypeScript是微软开发的语言，由于师出同门所以跟<code>C#</code>的语法是极其像的，不过由于是<code>JavaScript</code>的超类，所以还会考虑到ES的语法。所以很早的时候<code>ES6</code>还没流行起来的时候，<code>TypeScript</code>已经开始使用像ES6一样的语法，并提供编译把TS的代码编译成ES5的代码，在没有<code>es6</code>和<code>babel</code>的世界，需要用JS来创造更强大的程序无疑是福音。</p>
<p>一开始看到的时候，我觉得JS也就那样了，还能怎样…到后来去接触的原因，是因为它的语法跟我先接触的<code>swift</code>很像，我觉得可能能通过TS学好swift或者说通过对swift的理解去学TS，反正都能编译成JS的嘛。</p>
<p>再后来就遇到了游戏，接触Unity3D的时候，最热门最成熟的语言是C#，而我当时是个软黑。转而让我发现了Egret，Egret竟然把TS作为开发语言，我就想要不把TS也弄清楚了，以后如果接触C#可能也不会太难。可是经过几轮跌爬滚打之后，我竟然放弃了…对这就是我小时候的不懂事…大学快毕业的时候几乎每天就在后悔，为什么当时不好好学TS，而在ES6789流行开的时代里，语法完整功能完善的TS优势也没有那么大了。现在浏览器都能直接用ES7了…</p>
<p>但是现在说没优势都是骗人的…如果你只是单纯用JS写的话，一如果出现类型错误，不好控制。二在万物都是函数的世界中，可能如果要实现一些其他功能，可能会考虑不周。即使能考虑到了，写上去。也会造成很大的工作量。但是TS编译器都替我们想好和做好了，为什么不去用？</p>
<p>所以，如果是应用开发的话，为什么不考虑应用级别的开发语言呢？我是这么想的。</p>
<p>如果是web，但是要强大的框架比如vue，reactjs，我会选择用JS。如果是需要更强大的能力和稳定、可控的app，我肯定是选择TS。</p>
<h2 id="干！填坑！"><a href="#干！填坑！" class="headerlink" title="干！填坑！"></a>干！填坑！</h2><p>两点核心</p>
<ul>
<li><code>webpack</code>需要配置对<code>TypeScript</code>的编译。</li>
<li>从入口到组件都使用<code>TypeScript</code></li>
</ul>
<p>因为我也是误打误撞突然可以正常运行，所以我是开一个新的项目进行接下来的工作。 （结果发现并不是误打误撞，而是本来就是正确的，那么为什么会错误…）</p>
<p>首先npm安装<code>typescript</code>, <code>ts-loader</code>, <code>vue-class-component</code>，这三个都很重要。<code>typescript</code>提供的是语言支持，也可以说是提供内部编译，当然如果说你本身就全局装过了，那么你直接<code>link</code>就行了</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm i -S typescript ts-loader vue-class-component</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">npm i -S ts-loader vue-class-component</span><br><span class="line">npm link typescript</span><br></pre></td></tr></table></figure>
<p>然后是<code>webpack.renderer.config.js</code>，不出意外的话在<code>25:3</code>入口，<code>26:58</code>把<code>js</code>改成<code>ts</code>，下面的rule添加对ts的支持</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">	loader: <span class="string">'ts-loader'</span>,</span><br><span class="line">	exclude: <span class="regexp">/node_modules|vue\/src/</span>,</span><br><span class="line"> 	options: &#123;</span><br><span class="line">		appendTsSuffixTo: [<span class="regexp">/\.vue$/</span>]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有需要<code>tslint</code>的话（说实话我还不会用…而且我觉得ts约束本来就很厉害了），需要安装</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S tslint tslint-loader</span><br></pre></td></tr></table></figure>
<p>老位置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	test: <span class="regexp">/\.(ts)$/</span>,</span><br><span class="line">	enforce: <span class="string">'pre'</span>,</span><br><span class="line">	exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">	use: &#123;</span><br><span class="line">		loader: <span class="string">'tslint-loader'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二，就是把关于<code>vue</code>部分的入口改成<code>main.ts</code>。这样接近完成。</p>
<p>第三，最重要的，<code>typescript</code>能不能用就靠这个了，<code>jsconfig.json</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init	<span class="comment">#通过tsc初始化得到</span></span><br></pre></td></tr></table></figure>
<p>至于怎么配置，<code>vue</code>官方也给了一个推荐配置，<code>vue-class-component</code>也给了一个。</p>
<p>但不管怎样，建议把<code>allowjs</code>打开了，可以调用<code>js</code>文件。</p>
<h3 id="开始填坑"><a href="#开始填坑" class="headerlink" title="开始填坑"></a>开始填坑</h3><ul>
<li>入口必须是<code>.ts</code></li>
</ul>
<p>这点说起来很坑，TS的话，只要有<code>allowjs</code>就可以调用JS文件，运行是没问题的。但是反过来就不行了，毕竟超类能认，但JS根本不知道TS是个什么鬼，所以无法编译</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Module build failed: Error: Could not find file: <span class="string">'...*.ts'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">Module build failed: Error: Could not find file: <span class="string">'...*.vue'</span></span><br></pre></td></tr></table></figure>
<p>所以必须是TS入口</p>
<ul>
<li>建议关于<code>script</code>部分分开写。</li>
</ul>
<p>当然是可以直接在<code>.vue</code>写你的逻辑的，不过为了防止<code>typescript</code>有小脾气，或者关于类型推断，总的来说就是为了编译少点麻烦吧，我觉得还是分开写是最保险的。当然在组件内写也不是不可以。</p>
<ul>
<li><code>vue-class-component</code>核心</li>
</ul>
<p>如果用了TS的话，那么漂亮的组件代码肯定就是<code>class</code>了，通过修饰<code>@component</code>声明该位置是一个组件，然后开始写组件代码，继承自<code>vue</code>，然后就可以像写一个程序类一样去写这部分组件。看起来是相当漂亮的。举个例子，在通过<code>electron-vue</code>创建出来的工程中，对实例组件<code>LandingPage.vue</code>进行改写</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  name: <span class="string">'landing-page'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    SystemInformation</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> LandingPage <span class="keyword">extends</span> Vue &#123;</span><br><span class="line">  open (link) &#123;</span><br><span class="line">    (<span class="keyword">this</span> <span class="keyword">as</span> <span class="built_in">any</span>).$electron.shell.openExternal(link)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>漂亮，清晰。（当然复杂一点，就复杂了！）</p>
<ul>
<li>关于对Vue进行扩展</li>
</ul>
<p>在添加<code>axios</code>的时候我遇到了问题：无法扩展<code>Vue</code>，原因好像是无法推断<code>vue</code> 的类型。这个问题的话，我还得去研究一下。</p>
]]></content>
      
        <categories>
            
            <category> 实践尝试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Vue </tag>
            
            <tag> electron </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript的call，bind，apply]]></title>
      <url>/blog/2017/08/14/js-call-apply-bind/</url>
      <content type="html"><![CDATA[<blockquote>
<p>联动水文，大约半年前记录了Javascript的this。顺水推舟理一下call()，bind()，apply()</p>
</blockquote>
<p>扩展阅读：<a href="https://colmugx.github.io/PersonalBlog/2017/03/03/js-this/">关于JavaScript的this</a></p>
<p>还是上次的代码，修改一下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'koala'</span>,</span><br><span class="line">    getName() &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test = obj.getName</span><br><span class="line">test()					<span class="comment">//undefined.</span></span><br></pre></td></tr></table></figure>
<p>（敲黑板！）复习一下！为什么就<code>undefined</code>了！原因就是，<code>this</code>指向不同了。那么直接运行是否可以</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'koala'</span>,</span><br><span class="line">    getName() &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getName()		<span class="comment">//koala</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>因为有时候并没办法这么自由的随便调用，那如果要搞个变量出来用，怎么做？</p>
<h2 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h2><blockquote>
<p><strong>call</strong></p>
<ul>
<li>vi. 呼叫；拜访；叫牌</li>
<li>vt. 呼叫；称呼；召集</li>
<li>n. 电话；呼叫；要求；访问</li>
<li>n. (Call)人名；(瑞典、罗)卡尔；(英)考尔<br>以上来自有道翻译</li>
</ul>
</blockquote>
<p>有一手有道翻译就方便了，就是call（叫）它，把要用的方法call（叫）出来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'koala'</span>,</span><br><span class="line">    getName() &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cal = obj.getName	<span class="comment">//先定义出来</span></span><br><span class="line">cal.call(obj)		<span class="comment">//koala   （指向还给他，不动其他把它叫出来</span></span><br></pre></td></tr></table></figure>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h2><blockquote>
<p><strong>apply</strong></p>
<ul>
<li>v.应用；使用；涂；敷</li>
<li>Web申请；适用；套用<br>以上来自bing词典，感谢微软爸爸</li>
</ul>
</blockquote>
<p>再来一手必应翻译简直就是，不谈了！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'koala'</span>,</span><br><span class="line">    getName() &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> apy = obj.getName	<span class="comment">//这手还是不变</span></span><br><span class="line">apy.apply(obj)		<span class="comment">//koala  （可以说不是指向还给他，这不是假装了，而是直接套用</span></span><br></pre></td></tr></table></figure>
<p>有人要问，那你这手跟<code>call()</code>不是一样的么，为什么要区分开来。这个问题<a href="/2017/08/14/js-call-apply-bind/#call-和-apply-区别">下面再讲</a></p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h2><p>是不是以为我要用百度翻译了？我偏不！</p>
<blockquote>
<p><strong>bind</strong></p>
<p><strong>n.</strong> 窘境；讨厌的事情；捆绑；植物的藤蔓<br><strong>v.</strong> 捆绑；约束；装订；（使）结合；使关系密切<br>以上来自沪江小d，我学日语就靠它</p>
</blockquote>
<p><del>顺便，请以上三家公司尽快给我打钱，谢谢合作。</del></p>
<p><code>bind()</code>有点土匪的意思，它就是想抢走你老婆借用一晚的意思。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'koala'</span>,</span><br><span class="line">    getName() &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bid = obj.getName	<span class="comment">// [Function: getName]          (这手还是不变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接着这样做，把this指向回去，变成一个可以自由操作的变量</span></span><br><span class="line">bid = bid.bind(obj)		<span class="comment">// [Function: bound getName]</span></span><br><span class="line"></span><br><span class="line">bid()					<span class="comment">// koala   （这样才会运行，因为刚刚只是抢过来了</span></span><br></pre></td></tr></table></figure>
<h2 id="call-和-apply-区别"><a href="#call-和-apply-区别" class="headerlink" title="call()和#apply()区别"></a>call()和#apply()区别</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'koala'</span>,</span><br><span class="line">    getName() &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cal = obj.getName</span><br><span class="line">cal.call(obj)		<span class="comment">//koala</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> apy = obj.getName</span><br><span class="line">apy.apply(obj)		<span class="comment">//koala</span></span><br></pre></td></tr></table></figure>
<p>说是这么说了，可是，他们并不是说就这么改变<code>this</code>方向然后就没什么用处了啊，可以借用<code>call()</code>和<code>apply()</code>传参数的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'koala'</span>,</span><br><span class="line">    getName(param1, param2) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' params: '</span> + param1 + param2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cal = obj.getName</span><br><span class="line">cal.call(obj, <span class="number">1</span>, <span class="number">2</span>)		<span class="comment">//koala params: 12</span></span><br></pre></td></tr></table></figure>
<p>那么<code>apply()</code>就有区别了？哎！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> apy = obj.getName	<span class="comment">//这手还是不变</span></span><br><span class="line">apy.apply(obj, [<span class="number">1</span>, <span class="number">2</span>])		<span class="comment">//koala params: 12</span></span><br></pre></td></tr></table></figure>
<p><code>apply</code>后面接参数，只接受数组，<code>call</code>的话按顺序怼进去就行了。就这点区别。</p>
<p>暂时先这样，以后更深入的使用再深入的理解一下。现在大概就用到这些。</p>
<p><strong>下一篇，讲Javascript的柯基化！</strong></p>
]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于Javascript的条件判断]]></title>
      <url>/blog/2017/08/09/about-conditionals/</url>
      <content type="html"><![CDATA[<blockquote>
<p>记录这个不为什么，就是遇到SB，不想争执。</p>
</blockquote>
<p>撕逼文，小标题都会比较小，方便撕逼思路的连续性！<br><a id="more"></a></p>
<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>之所以想到写这个。是因为，公司给我安排的领导一直做的J2SE，没怎么过JS。然后接触了点ES6就疯狂装逼，看谁都是错的。要代码优雅但不愿意开ESLint；不要滥用语法糖却强制让人所有函数使用Promise；代码强调简洁但是非常简单的类似于<code>() =&gt; console.log(&#39;hello world&#39;))</code>都要分成三行写。这就是这次撕逼的源头了。</p>
<h3 id="JS的条件判断需不需要花括号？"><a href="#JS的条件判断需不需要花括号？" class="headerlink" title="JS的条件判断需不需要花括号？"></a>JS的条件判断需不需要花括号？</h3><blockquote>
<p>大多数语言中，条件判断语句后不接花括号的话，默认只会取接下来的语句作为子语句。</p>
</blockquote>
<p>在这点的话，无论Java或者Javascript都是一样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以是这样的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这么说没有什么说服力，比如这样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">  	<span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test1() <span class="comment">// 01234</span></span><br><span class="line">test2() <span class="comment">// 01234</span></span><br></pre></td></tr></table></figure>
<p>那么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) <span class="built_in">console</span>.log(i)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'你真TM搞笑'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">  	<span class="built_in">console</span>.log(i)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'你真TM搞笑'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">  	<span class="built_in">console</span>.log(i); <span class="built_in">console</span>.log(<span class="string">'你真TM搞笑'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的，三个答案是不是一样的？建议看到的如果不清楚答案，可以去试一下，如果你的node是从官网下的的话，就是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">你真TM搞笑</span><br></pre></td></tr></table></figure>
<p>很失望是不是！为什么第二种不是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">你真TM搞笑</span><br><span class="line">1</span><br><span class="line">你真TM搞笑</span><br><span class="line">2</span><br><span class="line">你真TM搞笑</span><br><span class="line">3</span><br><span class="line">你真TM搞笑</span><br><span class="line">4</span><br><span class="line">你真TM搞笑</span><br></pre></td></tr></table></figure>
<p><strong>那语言设计就是这样的，我能怎么办，我也很绝望啊</strong></p>
<p>那么“大神怎么说的”</p>
<blockquote>
<p>某“ES6专家”：你忘记的时候多写一行就会出现bug</p>
</blockquote>
<p>这又是什么情况呢？原题目的话是这样的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (exist) <span class="keyword">return</span> <span class="string">'该数据存在'</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="string">'不存在数据，需要添加'</span></span><br></pre></td></tr></table></figure>
<p>这实在让我抓破了头都不知道他想表达什么。难道他的意思是这样的？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (exist) <span class="keyword">return</span> <span class="string">'该数据存在'</span>  <span class="comment">// 不存在else 报错？</span></span><br><span class="line"><span class="comment">// else return '不存在数据，需要添加'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者第二种情况</span></span><br><span class="line"><span class="keyword">if</span> (exist) <span class="keyword">return</span> <span class="string">'该数据存在'</span></span><br><span class="line"><span class="comment">// else return '不存在数据，需要添加'</span></span><br><span class="line"><span class="built_in">console</span>.log(exist) <span class="comment">// 报错？</span></span><br></pre></td></tr></table></figure>
<p>但是，根据JS “没有花括号的情况下只会把接下来的第一句作为子语句” 已经证明不存在该问题了。那么他要说明什么？</p>
<h3 id="可能声明式编程真的会出现这种错误"><a href="#可能声明式编程真的会出现这种错误" class="headerlink" title="可能声明式编程真的会出现这种错误"></a>可能声明式编程真的会出现这种错误</h3><h4 id="第一种情况，if中为Boolean类型报错。"><a href="#第一种情况，if中为Boolean类型报错。" class="headerlink" title="第一种情况，if中为Boolean类型报错。"></a>第一种情况，if中为Boolean类型报错。</h4><p>就上面问题，我去百度了（这种垃圾问题Google什么？是看不起百度还是看不起谷歌还是你想装逼展示你会把梯子竖起来？）关键词<code>java if 不写大括号 报错</code></p>
<p>在CSDN确实有一处，<a href="http://blog.csdn.net/androidiscoding/article/details/47725347" target="_blank" rel="noopener"><a href="http://blog.csdn.net/androidiscoding/article/details/47725347" target="_blank" rel="noopener">你不知道java问题if后面加不加括号的问题</a></a>。（感谢大神分享）确实明确提到了</p>
<blockquote>
<p>if (boolean) 后面不使用花括号时，里面不能出现声明语句。</p>
</blockquote>
<p>哦，那还真对不起了ES6大神。</p>
<h4 id="第二种情况，作用域错误"><a href="#第二种情况，作用域错误" class="headerlink" title="第二种情况，作用域错误"></a>第二种情况，作用域错误</h4><p>这个可能需要代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog) </span><br><span class="line">Dog d = (Dog) a;</span><br></pre></td></tr></table></figure>
<p>这里还是CSDN得内容，<a href="http://bbs.csdn.net/topics/391057013?page=1" target="_blank" rel="noopener">为什么省略if后的大括号｛｝会报错</a>，其中<a href="http://my.csdn.net/finemi" target="_blank" rel="noopener">@finemi</a>提到，可能是java虚拟机的作用域问题，会把下面那句当做大作用域的内容，并不归属于if语句了。这是因为作用域错乱导致的错误，所以用花括号括住保证if内部作用域不受污染。</p>
<p>哦~<strong>私的ES6大神是本当对不起了！</strong></p>
<p>这也说明了，声明式编程在语法上确实比较严谨，看起来比较安全。我当时学习Objective-C的时候也确实踩了不少类似于奇怪语法的坑，不过后来信仰了Swift的结构式时候会好了很多。</p>
<h3 id="最后补一手关于ES6箭头函数的换行与不换行"><a href="#最后补一手关于ES6箭头函数的换行与不换行" class="headerlink" title="最后补一手关于ES6箭头函数的换行与不换行"></a>最后补一手关于ES6箭头函数的换行与不换行</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure>
<p>其实关于这个，阮一峰老师的开源书<a href="http://es6.ruanyifeng.com/#docs/function#箭头函数" target="_blank" rel="noopener">函数的扩展 - ECMAScript 6入门</a></p>
<blockquote>
<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</p>
<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。</p>
</blockquote>
<p>代码例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也就是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test1 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> test2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有些变态喜欢这么写</span></span><br><span class="line"><span class="keyword">let</span> test3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后阮老师强调了</p>
<blockquote>
<p><strong>箭头函数使得表达更加简洁。</strong></p>
<p><strong>如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</strong></p>
</blockquote>
<h3 id="最后总结一手"><a href="#最后总结一手" class="headerlink" title="最后总结一手"></a>最后总结一手</h3><p>在知乎，轮子哥解释过函数式编程</p>
<blockquote>
<p>函数是语言都倾向于让你用函数来组成函数，而不是把函数看成是一个数据弄成另一个数据的过程。</p>
</blockquote>
<p>还有我最喜欢的<a href="https://www.zhihu.com/people/be5invis" target="_blank" rel="noopener">@Belleve</a>贴了一张图说明了“越往下面走离函数式编程越远”</p>
<p><img src="https://pic4.zhimg.com/v2-a31b50055c9b896f7e3b9bb4467204e3_b.png" alt=""></p>
<p>另外，在Javascript中，虽然被称为“玩具语言”，但是就现在被开发的情况来说，Javascript绝对是目前最灵活和最强大的语言了，虽然它运行环境苛刻而严格，还不能做到anyway。</p>
<p>不过一码归一码，我这么说是想表达，Javascript发展到现在，应该说还有一大块大陆需要去探索，可能这个语言就像我们大脑一样，虽然很厉害了，实际上才开发了一点点而已吧。我也是正在学习这个语言，我只是想说，从想成为JSer开始，就意味着要不断学习。因为这个语言只会随着时间被开发得越来越多。</p>
<p>而且，几乎每每都能看到有人一直强调：<strong>函数是JS的第一公民</strong>。</p>
<p>这是什么意思？如果是函数式编程的话，那么，它所定义的每一个语句或者每一个代码块都可以视为函数。</p>
<p>声明式编程是让你声明某些东西，把内容转化为数据，数据转化为数据。而很明显javascript并不隶属这一家族。而且，js好像连Object都是Function类型的吧！</p>
<p>而且脚本语言+函数式，这才是我热爱并追随的地方。虽然我在JS是真的菜！</p>
<p>最后</p>
<p style="font-size:24px;font-weight:500;text-align:center;">把Javascript当做指令式编程的人都是神经病！</p>



<p>（最后感谢所有被引用的文章和作者，谢谢。）</p>
]]></content>
      
        <categories>
            
            <category> 编程议论 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于JavaScript的this]]></title>
      <url>/blog/2017/03/03/js-this/</url>
      <content type="html"><![CDATA[<blockquote>
<p>一次被this支配之后的思考</p>
</blockquote>
<h3 id="开门见山"><a href="#开门见山" class="headerlink" title="开门见山"></a>开门见山</h3><a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'koala'</span>,</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.getName()())    <span class="comment">//undefined.</span></span><br></pre></td></tr></table></figure>
<p>题目这样，我第一次回答的是<code>koala</code>。现在想了一下，估计是满脑子想吃波星冰乐给冲昏了脑子。<br>如果我改下！<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'koala'</span>,</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="keyword">this</span>    <span class="comment">//this -&gt; that</span></span><br><span class="line">        <span class="keyword">let</span> name = <span class="string">'koala'</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.name <span class="comment">//this -&gt; that</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.getName()()) <span class="comment">//koala</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者第二种，利用ES6</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'koala'</span>,</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">let</span> name = <span class="string">'koala'</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.getName()()) <span class="comment">//koala</span></span><br></pre></td></tr></table></figure></p>
<h3 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h3><p>我的理解，<code>this</code>其实跟其他语言的<code>self</code>应该是差不多。就是指代自己，比如说在一个<code>function</code>里面，那么<code>this</code>指向的就是这个func。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">colmugx</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//do something.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可能我讲的不清楚，就是<strong>this其实就是括号里的东西。</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">colmugx</span>(<span class="params"><span class="regexp">/** this */</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//do somethings</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然这是我的理解，我觉得应该就是这样的，所以刚刚那样取到的this并不是this。</p>
<h3 id="浅谈this"><a href="#浅谈this" class="headerlink" title="浅谈this"></a>浅谈this</h3><p>只讲两种我懂的东西。</p>
<h4 id="跟着new走"><a href="#跟着new走" class="headerlink" title="跟着new走"></a>跟着new走</h4><p>就是用new来创建对象的话，那么<code>this</code>就会跟着这个new<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    func() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">'koala'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a.name) <span class="comment">//koala</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    func() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">'koala'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a.func()) <span class="comment">//Animal &#123; name: 'koala' &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="ES6中括号函数的this"><a href="#ES6中括号函数的this" class="headerlink" title="ES6中括号函数的this"></a>ES6中括号函数的this</h4><p>括号函数的<code>this</code>，不存在的！</p>
<p>说是不存在，实际上并不是说真的不见了，而是它会绑定到上一层函数中<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//do somethings.</span></span><br><span class="line">&#125;<span class="comment">/** ,this */</span>)</span><br></pre></td></tr></table></figure></p>
<p>而如果不是括号的话</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="regexp">/** this */</span></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//do somethings.</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript所有for]]></title>
      <url>/blog/2017/03/02/js-for/</url>
      <content type="html"><![CDATA[<h3 id="先讲for"><a href="#先讲for" class="headerlink" title="先讲for"></a>先讲for</h3><p>我觉得这应该是最古老而且实用性最强的for了，就是三段式定义。<code>for (;;)</code><br>想到当年考java编程基础的时候（一门学科），有一道手写题要用到循环，我抬手就是<code>for (var ...)</code>…<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i;i&lt;len;i++)</span><br></pre></td></tr></table></figure></p>
<p>其中不管怎样，常规for必须要两个;，因为就是这样，里面有三段式嘛。第一个是定义自走变量，第二个是条件，第三个是自加或自减。实际上for应该是这样的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i;<span class="keyword">let</span> len;i&lt;len;++i)</span><br></pre></td></tr></table></figure></p>
<h3 id="for-in"><a href="#for-in" class="headerlink" title="for..in"></a>for..in</h3><p>这个在上次总结对象遍历已经提到了，它好像也就遍历对象用得多一点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> sth) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过<code>for in</code>的话，为什么说遍历对象比较多，其中一个除了好写<del>（打死吧这人）</del>，还有一点它只能用来遍历有key或者说是个index的东西，比如数组，它只能读到数组的index，那对象的话就直接读到键值咯。而且有一点的是，你读数组，<strong>读出来的index是个string不是number</strong>。这个要记得，因为js这种弱类型的东西，如果索引相加就变成字符串相加了……<strong>（我幼儿园就会20以内加减法了，1加2等于12)</strong></p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>这个方法就不是古老的方法了，JS(ES5)版本的时候的，针对数组的一个方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(<span class="function">(<span class="params">i</span>)=&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这种遍历的话，你遍历完直接能把数据处理掉最好，因为如果不是的话就麻烦了…它并不是一个开放的遍历，而是借用的闭包函数做的遍历。可以看成是<code>arr.func()</code>，它是一个数组方法，传进去一个<code>callback</code>，那就厉害了啊，闭包一个特点就是保护变量避免污染啊，变量保护是双向的啊…进得去出不来… （所以我的微信小程序openradio有用到计数器的时候不敢用这个，而且这个方法也是针对数组才能用的）</p>
<h3 id="for-of"><a href="#for-of" class="headerlink" title="for..of"></a>for..of</h3><p>这是ES6的新东西，它比<code>for in</code>遍历的更多，没有<code>for (;;)</code>复杂，对比<code>forEach</code>它是开放的不是闭包，也就是那些条件控制流什么的都可以操作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr)</span><br></pre></td></tr></table></figure></p>
<p>可是不止，好像还可以<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> <span class="string">'colmu'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)  <span class="comment">//'c'\n 'o'\n 'l'\n 'm'\n 'u'\n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过它不能遍历对象！不能遍历对象！不能遍历对象！而且错误信息<code>TypeError: str[Symbol.iterator] is not a function</code>。所以这里我不行不BB了。</p>
<blockquote>
<p>所有实现了[Symbol.iterator]接口的对象都可以被遍历。</p>
</blockquote>
<h3 id="for-in-和-for-of-对比"><a href="#for-in-和-for-of-对比" class="headerlink" title="for in 和 for of 对比"></a>for in 和 for of 对比</h3><p>一个栗子就能锤到头皮发麻<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">6</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)  <span class="comment">// 0,1,2,3,4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">6</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)  <span class="comment">//6,6,4,2,8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>光说区别不行，我要讲怎么用！</p>
<p><del>万能膏药<code>while</code></del> （不对走错片场…）</p>
<p>万能膏药<code>for (;;)</code>：这是怎样都能用的，不过就是长了点，但是定义细了多。</p>
<p>数组专利<code>forEach</code>：数组的方法，只能用在数组。</p>
<p>能用在数组的：<code>for</code>, <code>forEach</code>, <code>for in</code>, <code>for of</code></p>
<p>能用在找头的：<code>for in</code></p>
<p>只要支持[Symbol.iterator]要什么找什么的：<code>for of</code></p>
]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[来搞一手关于Javascript对象继承]]></title>
      <url>/blog/2017/02/22/js-extends/</url>
      <content type="html"><![CDATA[<blockquote>
<p>小爝（知乎用户）：js里面什么都是对象，所以你看单身狗学这个语言学的老快了。</p>
</blockquote>
<p>就前几天看到的答案，觉得对啊！js这种边缘OP的语言，你说它没对象它是可以有的，你说它是面向对象语言它不是。<br>所以来研究一手关于JavaScript的继承。研究过程用一下typescript（这个真有对象了）<a id="more"></a></p>
<h3 id="先看一下关于typescript的继承"><a href="#先看一下关于typescript的继承" class="headerlink" title="先看一下关于typescript的继承"></a>先看一下关于typescript的继承</h3><p>看一下ts的类<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Parent &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">msg:<span class="built_in">string</span>, age:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">        <span class="keyword">this</span>.name = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    sayHello() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">`hello <span class="subst">$&#123;this.name&#125;</span>,now is <span class="subst">$&#123;this.age&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后来一手调用，全程感觉像在用<code>java</code><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> par = <span class="keyword">new</span> Parent(<span class="string">"mike"</span>, <span class="number">16</span>)</span><br><span class="line">par.sayHello()      <span class="comment">//hello mike,now is 16</span></span><br></pre></td></tr></table></figure></p>
<p><strong>答案我在terminal验证过的没问题！！</strong></p>
<p>接下来尝试一下如果我走继承会是什么样，来一手继承<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Parent &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">msg:<span class="built_in">string</span>, age:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">        <span class="keyword">this</span>.name = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    sayHello() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">`hello <span class="subst">$&#123;this.name&#125;</span>,now is <span class="subst">$&#123;this.age&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Now extends.</span></span><br><span class="line"><span class="keyword">class</span> Son <span class="keyword">extends</span> Parent &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">msg, age</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(msg, age);</span><br><span class="line">    &#125;</span><br><span class="line">    sayHello() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`hello I'm Son. next is my Parent's say`</span>)</span><br><span class="line">        <span class="keyword">super</span>.sayHello()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>来手调用验证结果<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sapi = <span class="keyword">new</span> Son(<span class="string">'peanut'</span>, <span class="number">10</span>)</span><br><span class="line">sapi.sayHello()  <span class="comment">//hello I'm Son. next is my Parent's say\n hello peanut,now is 10</span></span><br></pre></td></tr></table></figure></p>
<h3 id="该研究JavaScript的继承了"><a href="#该研究JavaScript的继承了" class="headerlink" title="该研究JavaScript的继承了"></a>该研究JavaScript的继承了</h3><p>先来看一下第一个例子翻译成ES5(JavaScript)是什么样的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Parent = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">msg, age</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    Parent.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"hello "</span> + <span class="keyword">this</span>.name + <span class="string">",now is "</span> + <span class="keyword">this</span>.age);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> Parent;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> par = <span class="keyword">new</span> Parent(<span class="string">"mike"</span>, <span class="number">16</span>);</span><br><span class="line">par.sayHello();</span><br></pre></td></tr></table></figure></p>
<p>首先是建立了个函数，函数内再嵌套一层函数，然后通过内部的<code>prototype</code>添加一个方法，最后返回整个父函数。<br>燃鹅在这个函数内部已经做了一次叫“原型链继承”的事情了。就是从父级，或者说从其他原型来指向到继承的实例来达到元素一并继承，这样我要实现后面的实例的时候就要连带前面的也一并执行了。</p>
<p>然后第二个例子，多了个继承<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> __extends = (<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.__extends) || <span class="function"><span class="keyword">function</span> (<span class="params">d, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> b) <span class="keyword">if</span> (b.hasOwnProperty(p)) d[p] = b[p];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__</span>(<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.constructor = d; &#125;</span><br><span class="line">    d.prototype = b === <span class="literal">null</span> ? <span class="built_in">Object</span>.create(b) : (__.prototype = b.prototype, <span class="keyword">new</span> __());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Parent = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">msg, age</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    Parent.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"hello "</span> + <span class="keyword">this</span>.name + <span class="string">",now is "</span> + <span class="keyword">this</span>.age);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> Parent;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> Son = (<span class="function"><span class="keyword">function</span> (<span class="params">_super</span>) </span>&#123;</span><br><span class="line">    __extends(Son, _super);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">msg, age</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _super.call(<span class="keyword">this</span>, msg, age) || <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Son.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hello I'm Son. next is my Parent's say"</span>);</span><br><span class="line">        _super.prototype.sayHello.call(<span class="keyword">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> Son;</span><br><span class="line">&#125;(Parent));</span><br><span class="line"><span class="keyword">var</span> sapi = <span class="keyword">new</span> Son(<span class="string">'peanut'</span>, <span class="number">10</span>);</span><br><span class="line">sapi.sayHello();</span><br></pre></td></tr></table></figure></p>
<p>有点厉害，我先坐下来……</p>
<p>先是构造了个链子，然后（那个是闭包污染处理嘛…）…… 说不清了……</p>
<p>反正看子类，很明显在“Son类”结束前，有一个<code>(Parent)</code>，虽说ts对于类的处理都是一个大个的及时运行函数，但是”parent”运行时并没有带参数，而”Son”带了它的爹，如果我的理解的是对的的话，就是”Son”在运行的时候把”Parent”带着运行一次起到“继承”的效果。最后还是照原型链的理解。</p>
<h3 id="关于JavaScript的其他继承"><a href="#关于JavaScript的其他继承" class="headerlink" title="关于JavaScript的其他继承"></a>关于JavaScript的其他继承</h3><p>还是因为我的爬虫小记中的现世界宝可梦数量及其名字的项目中，用到了<code>.call(this)</code>这个函数句。所以在想，是否可以使用构造函数走一波继承？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'this is a'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后调用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b()     <span class="comment">//this is a</span></span><br></pre></td></tr></table></figure></p>
<p>所以也是可以的。结束！</p>
]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[async-await 初尝试]]></title>
      <url>/blog/2017/02/17/async-await-first/</url>
      <content type="html"><![CDATA[<blockquote>
<p>把去年在github的处作改造了一次。方便日后react学习… 另外我想换个主题了，这次用心做然后推入hexo themes。</p>
</blockquote>
<p>想起去年第一个放在github的东西，就是获取课程然后下载课程视频的下载器。<br>然后今天，想到弄一个服务端版本。这样我可以无论作为移动端还是webapp端都能用到爬虫的数据了。所以就做了一次改造。<br><a id="more"></a><br>github地址：<a href="https://github.com/ColMugX/ImoocDownloader/tree/server" target="_blank" rel="noopener">ColMugX/ImoocDownloader at server</a><br>地址跟ImoodDownloader一样，放在同一个项目里。多开了一个server版本分支。归类方便吧！</p>
<h3 id="ImoocDownloaderServer-请求样本"><a href="#ImoocDownloaderServer-请求样本" class="headerlink" title="ImoocDownloaderServer 请求样本"></a>ImoocDownloaderServer 请求样本</h3><p>请求之后样本大概是这样的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"code"</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="string">"Info"</span>: &#123;</span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"使用Struts2+Hibernate开发学生信息管理功能"</span>,</span><br><span class="line">    <span class="string">"author"</span>: <span class="string">"milanlover"</span>,</span><br><span class="line">    <span class="string">"job"</span>: <span class="string">"JAVA开发工程师"</span>,</span><br><span class="line">    <span class="string">"classTime"</span>: <span class="string">"2小时35分"</span>,</span><br><span class="line">    <span class="string">"classValue"</span>: <span class="string">"高级"</span>,</span><br><span class="line">    <span class="string">"classInfo"</span>: <span class="string">"简介：本课程通过学生信息管理功能的开发，来介绍Struts2和Hibernate的整合。主要内容包括：Struts2和Hibernate整合，用户登录模块和学生信息管理模块的设计和实现。通过本课程的学习，一定会使小伙伴们的Java Web开发技能更上一层楼。"</span>,</span><br><span class="line">    <span class="string">"classKn"</span>: <span class="string">"各位小伙伴，学习本课程前需要对\r\nStruts2和Hibernate的基础知识有所了解。"</span>,</span><br><span class="line">    <span class="string">"classWh"</span>: <span class="string">"1、掌握Struts2和Hibernate的整合开发\r\n2、能够使用Struts2+Hibernate独立开发信息管理类的项目，进行数据的增删改查。"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"Video"</span>: &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>解析完采用json格式进行输出，这是app最好的数据来源方式有木有！所以这样就更方便做APP了。而且这估计也是我第一次正式后端入门吧。<br>至于imoocdownloader这个名字，随便吧毕竟不能算是很好的作品，所以不重新起名字了。</p>
<h3 id="小谈ES6和ES7"><a href="#小谈ES6和ES7" class="headerlink" title="小谈ES6和ES7"></a>小谈ES6和ES7</h3><p>node更新到了v7.4，毋容置疑ES2016也就是顺势ES7也得到支持了，对于js或者说nodejs这种全靠异步吃饭的服务端有时候也是个很大的问题。<br>js是很经典的函数式语言，至少我这么觉得。函数式编程自然逃不过回调地狱…再加上nodejs这种非阻塞多并发的操作方式有时候确实是一种难题。（我的爬虫小记项目中的宝可梦基本数据爬虫<strong>已经是车祸现场</strong>了。）</p>
<p>按道理说，并没有ES6和ES7这种称呼，ESX最多只延续到了ES5。因为从ES1~ES5实际上都是ECMA-262的版本。根据百度百科</p>
<blockquote>
<p>ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。</p>
</blockquote>
<p>而到了ES6并不是叫ES6了，ECMA开始使用年份来命名，比如<code>ECMAScript 2015</code>，和<code>ECMAScript 2016</code>。1到5只是因为编号太长加上该编号一直在迭代。实际上该标准里面有两个语言，但渐渐的由于微软各种不给看好和JavaScript实在名声太大，所以变成了ES-262的扛把子。到了es2015我觉得已经变成一种跟JavaScript关系不大的语言了。虽然还有种<strong>“如果es6取代了js，那么就把es6改名为js”</strong>的说法。不过也不是不可行~</p>
<p>而ES6增加的内容和改变的内容实在太多了。多了类型的定义方式不再需要下划线约定俗成；简单的括号函数取代闭包函数臃肿的写法（不过括号函数不存在this，以后有机会掰扯。以前不懂事以为反正都一样，之后在微信小程序吃尽苦头）；引入了类的定义再也不需要被es5使用者各种邪魔化（在es6之前我唯一懂的es5对类的定义写法就是<code>new object()</code>）。</p>
<p>其实看到了es6之后，我就在后悔为什么当时不好好使用typescript和使用ts，这样的话到es6普及时我也可以成为扛把子了（逃。</p>
<p>所以ES6和ES7的说法，应该是因为ES5被叫顺口了，再说ES2015确实太长，那么顺位下来叫ES6也行，反正都懂就行了。</p>
<p>而ES2016不比ES2015，TMD竟然就只加入了一个能用的特性：<code>async-await</code>。</p>
<h3 id="浅谈promise-和-async-await"><a href="#浅谈promise-和-async-await" class="headerlink" title="浅谈promise 和 async-await"></a>浅谈promise 和 async-await</h3><p><code>promise</code>是es6的特性，<code>async-await</code>是es7的特性。前者在es6的学习中被我直接忽视了…觉得用不到而且不知道怎么用。但是在async出现之后，意识到promise的作用，而且我认为他们才是天造地设，缺一不可。<br>es6时代的时候据说也是邪魔写法很多，使用promise解决同步问题，再到后面有Generator函数的说法。最后都并不理想。毕竟语言这东西，如果有原生支持肯定是再好不过了。就跟Android一样，如果原生安卓在这片大陆上能正常使用的话体验肯定比现在任何XUI舒服。</p>
<p>作为异步程序同步处理，async/await也有矫情的地方，后者只能出现在有前者的上下文中，单独不可使用。而await只能用在promise的函数上面，用在其他函数上也行只不过没作用，还是瞬发还是异步。</p>
<h3 id="为什么需要P-A-，我用在哪里了"><a href="#为什么需要P-A-，我用在哪里了" class="headerlink" title="为什么需要P/A+，我用在哪里了"></a>为什么需要P/A+，我用在哪里了</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msgGet = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        request.get(url, <span class="function"><span class="keyword">function</span>(<span class="params">err, res, body</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err);</span><br><span class="line">                resolve(body);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先在查询那部分已经使用到了，因为异步的关系，文件内所有函数几乎都是在同一时间请求（高并发），所以这就导致可能有某种情况：<strong>劳资TMD等着第一个函数执行完得到个值用在第二个函数中计算，等第一的数据准备就绪的时候，第二的老人家竟然告诉我我早在1s前已经完成工作了。请问你拿什么在完成工作！</strong><br>所以就这样，在请求的数据还没到的时候，下面早早把空值传入下一步的操作中了，自然什么都没有，毕竟传值这工作比请求好完成。所以这就体现到需要同步解决的重要性了，“你必须要等你前面的人进去之后你再进去，不能插队！”</p>
<p>而且，虽然new了，这是一个Promise对象，但是它可以直接去到值，直接取出resolve。不过怎么说，看下面：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fi = <span class="keyword">await</span> msgGet(url);     <span class="comment">//得到msgGet(url)的值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">await</span> msgGet(url)); <span class="comment">//输出Promise &#123;&lt;padding...&gt;&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>通过变量定义之后，获取的值是可以进一步使用的，可以丢入下一个函数进行下一步工作。不需要<code>.then()</code>。但是如果要它直接打印出来就不可能了！因为上面已经说了，这是一个对象并不是一个可直接使用的数值。只有其他函数可以直接get到对象的内容，而没办法直接显示。需要像第二种的方式只能是：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fi.then(<span class="function">(<span class="params">m</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(m);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这样操作才能得到真正里面的东西。take it off。不过这样也就依然跌入回调地狱…<br>而到了视频地址解析那部分的时候，由于需要去请求视频地址，同样又出现了相同的情况。但是调用我是在查询的位置调用，在这里<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line">    allMsg[<span class="string">'Info'</span>] = classData;</span><br><span class="line">    allMsg[<span class="string">'code'</span>] = <span class="number">200</span>;</span><br><span class="line">    allMsg[<span class="string">'vidic'</span>] = viDic;</span><br></pre></td></tr></table></figure></p>
<p>如果我不是把视频数据向前传，而是在里面直接调用操作的话。就第一次尝试那样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vidInfo = getVideoUrl(viDic);</span><br><span class="line">allMsg[<span class="string">'Info'</span>] = classData;</span><br><span class="line">allMsg[<span class="string">'code'</span>] = <span class="number">200</span>;</span><br><span class="line">allMsg[<span class="string">'video'</span>] = vidInfo;</span><br></pre></td></tr></table></figure></p>
<p>反正差不多吧我忘记了……到后面取值输出的时候就是这样的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"code"</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="string">"Info"</span>: &#123; ... &#125;</span><br><span class="line">  <span class="string">"video"</span>: &#123;<span class="built_in">Promise</span> &#123; &lt;padding...&gt; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>什么都取不到玩腿毛？<br>所以后来就抖了个小聪明，把整理完的视频信息往回传，在前面<code>.then()</code>操作之后取出真实数据再去请求，再得到数据再<code>.then()</code>一次，获得所有真实数据再反馈出来。得到现在要的所有数据。最后一步 send到express。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">msg.then(<span class="function">(<span class="params">data</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!data[<span class="string">'err'</span>]) &#123;</span><br><span class="line">        <span class="keyword">var</span> vidInfo = getVideoUrl(data[<span class="string">'vidic'</span>]);</span><br><span class="line">        vidInfo.then(<span class="function">(<span class="params">v</span>)=&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> s = &#123;&#125;;</span><br><span class="line">            s[<span class="string">'code'</span>] = data[<span class="string">'code'</span>];</span><br><span class="line">            s[<span class="string">'classID'</span>] = id;</span><br><span class="line">            s[<span class="string">'Info'</span>] = data[<span class="string">'Info'</span>];</span><br><span class="line">            s[<span class="string">'Video'</span>] = v;</span><br><span class="line">            res.send(s);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'request finish'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>结束。</p>
]]></content>
      
        <categories>
            
            <category> 前端思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自己造轮子！——Syuanpi.css]]></title>
      <url>/blog/2017/02/13/Syuanpi-css/</url>
      <content type="html"><![CDATA[<p>本来首发知乎，再说了现在这东西又不需要怎么用了，各种前端框架各种自动化，这些东西早就带得干干净净了。<br>这是demo的页面：<a href="https://colmugx.github.io/Syuanpi.css">Syuanpi.css</a><br>这是GitHub的页面：<a href="https://github.com/ColMugX/Syuanpi.css" target="_blank" rel="noopener">ColMugX/Syuanpi.css: ✨A library of CSS animations.</a></p>
<p>说到CSS动画库，其实有一个很出名很好用，“就像喝水一样简单”的叫做Animate.css的开源库子。那些动画真的挺炫酷的。然后我就想起，我自己在玩Hexo主题的时候不是动画也是自己写么，那要不把用过的动画自己封装起来，然后再加点跟自己脑洞产物的动画，然后自己也做一个库试试？然后我就把Syuanpi.css弄出来了…作为练习产物，日后想到什么好玩的实现方式也是会一直加一直加~ 不过我要说实话：不排除把Animate.css出现的部分动画自己再实现一遍进自己库子！</p>
<h3 id="为什么要出这东西…"><a href="#为什么要出这东西…" class="headerlink" title="为什么要出这东西…"></a>为什么要出这东西…</h3><a id="more"></a>
<p>在知乎看了一段时间了认识了kpi这东西，觉得这东西好坑啊233，导致我现在觉得kpi的意思就是：有现有轮子不要用！不管怎样自己用的东西能做成轮子就给它做成轮子！然后再用自己的轮子！然后kpi就啪啪啪的往上走！不过这库子我的出发点还是想把我原来弄的一些基础的动画归类起来，加上自己比较会常用的操作封装起来，仅此而已。<br>在知乎学习的过程，就有一个关于没工作经验然后怎么面试的问题。就有提到关于自己开源自己的代码，不是不负责任的像托管作业一样把乱七八糟的东西放上去然后就说“噢！劳资也有开源”这样，至少要有一个给人一种便捷操作，要有头有尾，还要会写文档，不会写给个README也行。然后我也没经验，就听话这么做了…</p>
<h3 id="它是个什么东西…"><a href="#它是个什么东西…" class="headerlink" title="它是个什么东西…"></a>它是个什么东西…</h3><p>好了说回来我的东西~ Syuanpi意思很简单，我喜欢它日后可以炫得一批233。但是它并不炫，而是一些很基础很基础的动画用法。不过，一些稍微认真的网站不就要点轻转场就行了嘛。比如我觉得博客挺认真的，但是没有转场动画又觉得好干燥，所以我的大部分动画起始点都是基于在自己博客上面用。而且动画的过程速度和位置全靠目测！不会计算也是硬伤呀…用的是stylus，不知道为什么总觉得那个被那个绿色的长的 ∮ 撩到了，然后就这么用了。<br>认认真真做作业，不要搞什么大新闻。就像标题说的，针对自己脑洞的产物。不过由于是自己第一次比较成型的“自己的作业自己做”，我还是好高兴的。如果有人愿意给star就更好了，还没体验过被5个star砸死是什么感觉呢~（不贪心的好孩子~）<br>嗯！该讲说明书了！大份说明书在GitHub的头页README.md，所以就不讲了！</p>
]]></content>
      
        <categories>
            
            <category> 实践尝试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Syuanpi </tag>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[更新全局NPM的所有可更新包]]></title>
      <url>/blog/2016/12/09/update-npm-packages/</url>
      <content type="html"><![CDATA[<p>今天在通过<code>vue-cli</code>创建一个新工程的时候，那个提示说有新版本要更新。对于一个有“工具更新强迫症”的人自然有点受不了（除开python），所以就尝试更新。<br>然后发现，项目内更新就<code>npm update &lt;name&gt;</code>就更新了，全局好像不知道怎么弄。然后就自作聪明的<code>npm update -g vue-cli</code>（当然mac宝宝们有个sudo），然后发现卡了好久之后才开始读条，这个时候我就方了，“这个命令到底能不能用？”<br>事实证明是能用的！<code>vue-cli</code>更新好了。<br>但是通过这个之后，我就想了，我电脑里还有没有其他没更新的包…然后我就想查出来一并更新了<br>于是查了一下，说不定日后还得用，做个记录。<a id="more"></a></p>
<h3 id="通过npm的cli更新"><a href="#通过npm的cli更新" class="headerlink" title="通过npm的cli更新"></a>通过npm的cli更新</h3><p>后来在某个同性交流平台sf找到了，说<code>npm</code>在<code>2.6.1</code>之后有一个代码叫<code>npm install -g</code>。可以升级全部包。<br>然后我试了一下。</p>
<blockquote>
<p>eisdir EISDIR: illegal operation on a directory, read<br>npm ERR! eisdir This is most likely not a problem with npm itself<br>npm ERR! eisdir and is related to npm not being able to find a package.json in<br>npm ERR! eisdir a package you are trying to install.</p>
</blockquote>
<p><strong>？？？</strong>我有一句MMP*******</p>
<p>先查找npm 有多少包需要更新吧，命令是<code>npm -g outdated</code>，这个就正常了。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Package</span>           Current        Wanted  Latest  Location</span><br><span class="line">cordova             <span class="number">5</span>.<span class="number">4</span>.<span class="number">1</span>         <span class="number">6</span>.<span class="number">4</span>.<span class="number">0</span>   <span class="number">6</span>.<span class="number">4</span>.<span class="number">0</span>  </span><br><span class="line">egret             MISSING         <span class="number">1</span>.<span class="number">0</span>.<span class="number">1</span>   <span class="number">1</span>.<span class="number">0</span>.<span class="number">1</span>  </span><br><span class="line">ionic       <span class="number">2</span>.<span class="number">0</span>.<span class="number">0</span>-beta.<span class="number">23</span>  <span class="number">2</span>.<span class="number">1</span>.<span class="number">0</span>-beta.<span class="number">3</span>  <span class="number">2</span>.<span class="number">1</span>.<span class="number">14</span>  </span><br><span class="line">ios-sim             <span class="number">5</span>.<span class="number">0</span>.<span class="number">6</span>        <span class="number">5</span>.<span class="number">0</span>.<span class="number">12</span>  <span class="number">5</span>.<span class="number">0</span>.<span class="number">12</span>  </span><br><span class="line">npm                <span class="number">3</span>.<span class="number">3</span>.<span class="number">12</span>         <span class="number">4</span>.<span class="number">0</span>.<span class="number">5</span>   <span class="number">4</span>.<span class="number">0</span>.<span class="number">3</span>  </span><br><span class="line">typescript          <span class="number">1</span>.<span class="number">8</span>.<span class="number">9</span>         <span class="number">2</span>.<span class="number">1</span>.<span class="number">4</span>   <span class="number">2</span>.<span class="number">1</span>.<span class="number">4</span>  </span><br><span class="line">typings             <span class="number">1</span>.<span class="number">3</span>.<span class="number">3</span>         <span class="number">2</span>.<span class="number">0</span>.<span class="number">0</span>   <span class="number">2</span>.<span class="number">0</span>.<span class="number">0</span>  </span><br><span class="line">webpack            <span class="number">1</span>.<span class="number">13</span>.<span class="number">3</span>        <span class="number">1</span>.<span class="number">14</span>.<span class="number">0</span>  <span class="number">1</span>.<span class="number">14</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>然后我又自作聪明了一下，<code>npm update -g</code><br>然后依然是卡了一下，然后就读条……<br>然后就全部更新完成。</p>
<h3 id="通过npm-check"><a href="#通过npm-check" class="headerlink" title="通过npm-check"></a>通过npm-check</h3><p>其实还看到了一种方法，是在终端里面的GUI工具，可以直观看到哪些需要更新然后可以顺便更新掉<br>当然需要安装，<code>npm-check</code></p>
<blockquote>
<p>npm install -g npm-check （mac宝宝们别忘记sudo）</p>
</blockquote>
<p>检查npm包的状态:</p>
<blockquote>
<p>npm-check -u -g</p>
</blockquote>
<p>然后就移动光标来选择和操作。</p>
]]></content>
      
        <categories>
            
            <category> 日常吐槽 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NodeJS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一次无聊的尝试 —— hexo-theme-blank]]></title>
      <url>/blog/2016/11/02/xin-zhu-ti-ce-shi-wan-shan-zhong/</url>
      <content type="html"><![CDATA[<blockquote>
<p>一次Hexo主题的尝试</p>
</blockquote>
<p><strong>我先说好啊！Blank不是SKT T1的打野！</strong><br><strong><a href="/blank.html">主题演示页面点击这里</a></strong></p>
<h3 id="科技以换色为本！"><a href="#科技以换色为本！" class="headerlink" title="科技以换色为本！"></a>科技以换色为本！</h3><h4 id="紫色"><a href="#紫色" class="headerlink" title="紫色"></a>紫色</h4><p><img src="/Image/Blank-violet.jpg" alt="Blank-紫罗兰"> <a id="more"></a></p>
<h4 id="灰色"><a href="#灰色" class="headerlink" title="灰色"></a>灰色</h4><p><img src="/Image/Blank-gray.jpg" alt="Blank-深空灰"></p>
<h4 id="粉色"><a href="#粉色" class="headerlink" title="粉色"></a>粉色</h4><p><img src="/Image/Blank-pink.jpg" alt="Blank-樱语粉"></p>
<h4 id="绿色"><a href="#绿色" class="headerlink" title="绿色"></a>绿色</h4><p><img src="/Image/Blank-green.jpg" alt="Blank-璐璐绿"></p>
<h4 id="蓝色"><a href="#蓝色" class="headerlink" title="蓝色"></a>蓝色</h4><p><img src="/Image/Blank-blue.jpg" alt="Blank-编不下去的蓝色"></p>
<h4 id="红色"><a href="#红色" class="headerlink" title="红色"></a>红色</h4><p><img src="/Image/Blank-red.jpg" alt="Blank-红红火火"></p>
<h4 id="橙色"><a href="#橙色" class="headerlink" title="橙色"></a>橙色</h4><p><img src="/Image/Blank-orange.jpg" alt="Blank-橙子一样的颜色"><br>真是不好意思又开了个坑<br>“方块律动”和“空”为思想的一个主题，同样现在依然是个半成品<br>但怎么说比Rousy（海底世界）好多了吧！</p>
<h3 id="这个主题从写法上，比Rousy改善很多"><a href="#这个主题从写法上，比Rousy改善很多" class="headerlink" title="这个主题从写法上，比Rousy改善很多"></a>这个主题从写法上，比Rousy改善很多</h3><p>怎么来说，Rousy的话，是根据css然后全搬入stylus的，管理性能略差<br>但是Blank的话，我好像不知不觉用了stylus的用法，所以看起来应该…还是不简洁…<br>当然Blank只是半成品，至今只出生后第3天。（都是中午和大半夜，白天有课上）</p>
<h3 id="新主题有没有什么新东西"><a href="#新主题有没有什么新东西" class="headerlink" title="新主题有没有什么新东西"></a>新主题有没有什么新东西</h3><p>肯定有啊！目标实现的效果是，任何操作都是依赖方块来进行，而且即摸即现（标签还没弄好）<br>然后，<strong>可以切换颜色主题了！</strong><br>目前是可以切换两种颜色主题，“灰色跟粉色”，明天应该能支持4种颜色了。<br>当然，我想把颜色接口开放到<code>_config.yml</code>中，然后就可以自定义了！</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[关于微信小程序]]></title>
      <url>/blog/2016/10/28/guan-yu-wei-xin-xiao-cheng-xu/</url>
      <content type="html"><![CDATA[<blockquote>
<p>向腾讯大佬低头！</p>
</blockquote>
<p><strong>说在前面，你们这下可不能说我这博客天天吹水不讲东西了！</strong></p>
<h3 id="说说这大佬又想干什么！"><a href="#说说这大佬又想干什么！" class="headerlink" title="说说这大佬又想干什么！"></a>说说这大佬又想干什么！</h3><p>怎么说，腾讯微信真的是野心挺大的，要把微信做成一个应用平台<br>谁还能想的起来微信当时只是定位为一个低流语音信息的即时通讯工具啊！<br>小程序怎么定义呢，就是一个在微信启动的App<br>不过归根到底还是个Web App<br>那这么说来其实也可以说是一个以微信做壳的App了，相对于隔壁那个叫Ionic的东西来说。<br>不过怎么说，这小程序应该也是依托公众号来实现的吧，我看它文档都是在公众号里面。<br>先上地址：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=1474887501214" target="_blank" rel="noopener">下载链接</a><br>这开发工具原来就是一个chrome开发者工具，可能是因为加了小程序这么个东西，现在也有开发功能了<br>刚刚试用了一下，效！率！贼！差！（默默打开了Atom）<a id="more"></a></p>
<h3 id="这东西大概怎么写怎么用"><a href="#这东西大概怎么写怎么用" class="headerlink" title="这东西大概怎么写怎么用"></a>这东西大概怎么写怎么用</h3><p>我粗略看了一下啊，这东西跟隔壁那些什么<code>angular</code>啊，还有<code>vue</code>啊什么都有点差不多，就是前后绑定然后做逻辑。<br>大概结构就是（不会用树形，随便看一下）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- /</span><br><span class="line"> - pages</span><br><span class="line">     - index</span><br><span class="line">         index.js</span><br><span class="line">         index.wxml</span><br><span class="line">         index.wxss</span><br><span class="line">     - logs</span><br><span class="line">         logs.js</span><br><span class="line">         logs.json</span><br><span class="line">         logs.wxml</span><br><span class="line">         logs.wxss</span><br><span class="line"> - utils</span><br><span class="line">     util.js</span><br><span class="line"> app.js</span><br><span class="line"> app.json</span><br><span class="line"> app.wxss</span><br></pre></td></tr></table></figure></p>
<p><strong>这结果tm似曾相识啊！</strong><br>好了这就是个Web App，那讲一下那些文件干嘛的呗。<br>说到底还是个老biao子，js就不用说了（哎等下这东西好像还是得依托<code>NodeJs</code>啊，顺便说下我特别不喜欢<code>PHP</code>…）</p>
<p><code>wxml</code>:是个什么，wxml其实就是xml了，只是有点特殊的xml，可以理解成就是我们做ionic那个html吧<br><code>wxss</code>:卧槽了就是这个wxss！卧槽！挑白了说就是个CSS！不过在像素定义有点不同。引用一下</p>
<blockquote>
<p>尺寸单位<br>rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。<br>设备    rpx换算px (屏幕宽度/750)    px换算rpx (750/屏幕宽度)<br>iPhone5    1rpx = 0.42px    1px = 2.34rpx<br>iPhone6    1rpx = 0.5px    1px = 2rpx<br>iPhone6 Plus    1rpx = 0.552px    1px = 1.81rpx</p>
</blockquote>
<p>所以官方说的是，<strong>“我们鼓励使用iphone 6 作为标准屏幕开发”</strong><br>原话是</p>
<blockquote>
<p>建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。 注意： 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。</p>
</blockquote>
<p>（噢…是嘛…</p>
<h4 id="另外最近在学Vue-js，估计跟玩小程序应该也会有点联系吧，就这样了剩下的日后再说。"><a href="#另外最近在学Vue-js，估计跟玩小程序应该也会有点联系吧，就这样了剩下的日后再说。" class="headerlink" title="另外最近在学Vue.js，估计跟玩小程序应该也会有点联系吧，就这样了剩下的日后再说。"></a>另外最近在学Vue.js，估计跟玩小程序应该也会有点联系吧，就这样了剩下的日后再说。</h4>]]></content>
      
        
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
