<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ColMugX</title>
  
  <subtitle>SHOW YOUR FUNCTION NO BB.</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://colmugx.github.io/blog/"/>
  <updated>2018-02-28T02:23:29.595Z</updated>
  <id>https://colmugx.github.io/blog/</id>
  
  <author>
    <name>Co1MugX</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>promise链式调用</title>
    <link href="https://colmugx.github.io/blog/2018/02/28/promise-chaining/"/>
    <id>https://colmugx.github.io/blog/2018/02/28/promise-chaining/</id>
    <published>2018-02-28T02:16:22.000Z</published>
    <updated>2018-02-28T02:23:29.595Z</updated>
    
    <content type="html"><![CDATA[<p>学会了却不会活用是真的菜…</p><p>前几天面试，提到了回调地狱用<code>promise</code>，然后抛出个衍生问题：<code>promise</code>也会嵌套，怎么解决<code>promise</code>的回调地狱。</p><p>我想不到，直接问能不能用<code>ES8</code>，说行，然后我就想到了<code>const p2 = await Promise</code>这种做法。</p><p>可是，我记得我在若干天前才写了一篇关于「JS方法链式调用」。</p><blockquote><p>只要函数返回值是一个对象，就可以连着调用</p></blockquote><p>So,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p1.then(<span class="function">(<span class="params">&#123; p2 &#125;</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> p2</div><div class="line">&#125;).then(&#123; p3 &#125; =&gt; &#123;&#125;)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学会了却不会活用是真的菜…&lt;/p&gt;
&lt;p&gt;前几天面试，提到了回调地狱用&lt;code&gt;promise&lt;/code&gt;，然后抛出个衍生问题：&lt;code&gt;promise&lt;/code&gt;也会嵌套，怎么解决&lt;code&gt;promise&lt;/code&gt;的回调地狱。&lt;/p&gt;
&lt;p&gt;我想不到，直接问
      
    
    </summary>
    
      <category term="曲苑杂坛" scheme="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://colmugx.github.io/blog/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Vue函数式组件</title>
    <link href="https://colmugx.github.io/blog/2018/02/16/vue-functional/"/>
    <id>https://colmugx.github.io/blog/2018/02/16/vue-functional/</id>
    <published>2018-02-16T08:19:20.000Z</published>
    <updated>2018-02-18T07:54:22.234Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cn.vuejs.org/v2/guide/render-function.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6" target="_blank" rel="external">函数式组件</a></p><p><code>vue</code>与<code>jsx</code>的配合一直都是后妈带儿子，所以就算文档也只是大面积讲述渲染函数的来龙去脉。但实际上真实开发的话是没有人直接<code>return CreateElement</code>来怼的（小组件暴力渲染还是会有的，但比较成型的组件肯定会想到<code>jsx</code>或者干脆<code>template</code>了）。</p><p>函数式组件，不多讲了这是个很常见的组件方式。不过因为<code>vue</code>的「特殊结构」，有点不太一样而已。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  functional: <span class="literal">true</span>,</div><div class="line">  render(h, ctx) &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><a id="more"></a><p>作为无状态三宝<code>props</code>, <code>context</code>, <code>data</code>，当然<code>React</code>没有最后一个和第二个可选，但肯定不会少了<code>props</code>，毕竟无状态组件要求纯函数，单向数据一进一出。不过对于<code>vue</code>来说，一切内容都包入<code>context</code>，第一个参数必须传入渲染函数。</p><p>So，<code>context</code>一共有这么些东西：</p><blockquote><p>props：提供 props 的对象<br>children: VNode 子节点的数组<br>slots: slots 对象<br>data：传递给组件的 data 对象<br>parent：对父组件的引用<br>listeners: (2.3.0+) 一个包含了组件上所注册的 v-on 侦听器的对象。这只是一个指向 data.on 的别名。<br>injections: (2.3.0+) 如果使用了 inject 选项，则该对象包含了应当被注入的属性。</p></blockquote><p>至于<code>props</code>和<code>parent</code>已经不用解释了，主要是<code>children</code>, <code>data</code>, <code>listeners</code></p><p>实际上<code>data</code>问题最大，而文档说的最少的就是这个。文档只是一句”传递给组件的 data 对象“带过，这什么鬼？</p><p>实际上打印过一次<code>children</code>就知道了，一个节点需要tag标签，data数据，children子节点等。而<code>data</code>就是放在标签后的一系数据，比如<code>attr</code>。</p><p>如果还是不清楚的话，再打印一次，会发现，<code>data.attrs</code>是不是有<code>props</code>的内容？<code>data.on</code>是不是可以用在<code>listeners</code>？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://cn.vuejs.org/v2/guide/render-function.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;函数式组件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vue&lt;/code&gt;与&lt;code&gt;jsx&lt;/code&gt;的配合一直都是后妈带儿子，所以就算文档也只是大面积讲述渲染函数的来龙去脉。但实际上真实开发的话是没有人直接&lt;code&gt;return CreateElement&lt;/code&gt;来怼的（小组件暴力渲染还是会有的，但比较成型的组件肯定会想到&lt;code&gt;jsx&lt;/code&gt;或者干脆&lt;code&gt;template&lt;/code&gt;了）。&lt;/p&gt;
&lt;p&gt;函数式组件，不多讲了这是个很常见的组件方式。不过因为&lt;code&gt;vue&lt;/code&gt;的「特殊结构」，有点不太一样而已。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  functional: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  render(h, ctx) &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="实践尝试" scheme="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="Vue" scheme="https://colmugx.github.io/blog/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>抛下不成熟，开始nvim</title>
    <link href="https://colmugx.github.io/blog/2018/02/13/new-life-nvim/"/>
    <id>https://colmugx.github.io/blog/2018/02/13/new-life-nvim/</id>
    <published>2018-02-13T03:02:00.000Z</published>
    <updated>2018-02-13T03:41:58.627Z</updated>
    
    <content type="html"><![CDATA[<p>想活得跟过去有些区别，活得更有效率该有的样子，而且我讨厌上一年的自己，不知道为什么会这么想。反正，放弃spacemacs开始使用vim了。</p><p>很简单，spacemacs有时候会卡一下，就像十年前的电脑，按了一长串需要等一下才会突突突突全显示出来。后来vscode + vim插件又出现了“不自觉按空格”的情况，就是写完按两下空格调插件。那既然这样的话，从零开始一个vim吧，把leader换成空格然后一些改不过来的习惯换过来就行了。</p><p>实际上，如果不是因为懒，早就该定制编辑器了。。不过我不会放弃vscode，因为还是有些残留。为什么不从零开始一个emacs？成本太高啊，又要vim模式又要改成leader键操作，而且逐渐能理解那个蚊香图是什么意思了。</p><h2 id="iterm2"><a href="#iterm2" class="headerlink" title="iterm2"></a>iterm2</h2><p>宿主用这个，原先很排斥在终端写东西（不能用鼠标），不过后来一手菜鸡操作<code>xj</code>, <code>xk</code>还有<code>wwwwwwww...</code>也能达到需求了，应该没问题了。<br><a id="more"></a><br>14px的<code>menlo nerd</code>，204x60 的<code>full-width top</code>，接近<code>40%</code>的透明度纯黑背景解决字体字符完整显示和启动时自动无边框全屏，还能看到窗后的情况。顺便把热键改成<code>cmd + return</code>（这操作懂得都懂…）</p><h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><p>oh-my-zsh一早就装了，用的<code>avit</code>主题，其他没动。对我来说<code>shell</code>就是<code>shell</code>。</p><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p>从刚开始尝试MacVim到后面把这东西干掉，终端vim更新到vim8.0之后，vim一直充当着“顺手改改”的任务。这次因为要半主力编辑器，也不能全靠手打了…</p><p>对ycm印象极差，虽然deoplete支持vim8，弄了一阵子能用但是一出问题麻烦极多；找到了vim-lsp但是资源稀缺，还不会自启服务器！一气之下编译一手<code>neovim</code>，完美。毕竟我要有这脾气我就去从零开始space + emacs了（主要还可以直接抄大佬的配置）。</p><p>至于其他插件，因为还没有实战过还不知道缺哪些东西。先配好的是肯定会用上的，看情况再说。</p><p>另外求一个vim插件，vim有没有像<code>mmm-mode</code>的插件，就是同一个文件可以不同设置高亮或者补全的？用<code>mmm-mode</code>可以在同一文件同时采用<code>emmet-mode</code>和<code>js2-mode</code>，也因为这样解决我<code>vue</code>高亮补全问题…</p><p>然后就是看情况把在<code>spacemacs</code>的片段搬到<code>vim</code>了。</p><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><p>其实<code>iterm2</code>也可以胡乱分屏，但是考虑到大佬墙裂推荐。用！</p><p>看到了<code>i3</code>的影子，配置窗口前后颜色，调整了状态栏左右宽度和配色。毕竟还不熟，随意的改成了和vim主题相近的低调配色并加上时钟（着手做电量）。不过我的终端毕竟不是全屏的，顶栏和dock还是会常驻屏幕，所以一堆东西也没什么用。对了，这一套有颜色的主题颜色都采用了<code>one</code>，atom家那个。</p><p>然后剩下的就是通过使用寻找问题了，现在第一个问题就是vim的主题怎么把背景也至少<code>30%</code>的透明，改了主题文件发现一点用都没有。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想活得跟过去有些区别，活得更有效率该有的样子，而且我讨厌上一年的自己，不知道为什么会这么想。反正，放弃spacemacs开始使用vim了。&lt;/p&gt;
&lt;p&gt;很简单，spacemacs有时候会卡一下，就像十年前的电脑，按了一长串需要等一下才会突突突突全显示出来。后来vscode + vim插件又出现了“不自觉按空格”的情况，就是写完按两下空格调插件。那既然这样的话，从零开始一个vim吧，把leader换成空格然后一些改不过来的习惯换过来就行了。&lt;/p&gt;
&lt;p&gt;实际上，如果不是因为懒，早就该定制编辑器了。。不过我不会放弃vscode，因为还是有些残留。为什么不从零开始一个emacs？成本太高啊，又要vim模式又要改成leader键操作，而且逐渐能理解那个蚊香图是什么意思了。&lt;/p&gt;
&lt;h2 id=&quot;iterm2&quot;&gt;&lt;a href=&quot;#iterm2&quot; class=&quot;headerlink&quot; title=&quot;iterm2&quot;&gt;&lt;/a&gt;iterm2&lt;/h2&gt;&lt;p&gt;宿主用这个，原先很排斥在终端写东西（不能用鼠标），不过后来一手菜鸡操作&lt;code&gt;xj&lt;/code&gt;, &lt;code&gt;xk&lt;/code&gt;还有&lt;code&gt;wwwwwwww...&lt;/code&gt;也能达到需求了，应该没问题了。&lt;br&gt;
    
    </summary>
    
      <category term="玩具制造" scheme="https://colmugx.github.io/blog/categories/%E7%8E%A9%E5%85%B7%E5%88%B6%E9%80%A0/"/>
    
    
      <category term="vim" scheme="https://colmugx.github.io/blog/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>vuex源码理解（二）</title>
    <link href="https://colmugx.github.io/blog/2018/01/30/vuex-study-2/"/>
    <id>https://colmugx.github.io/blog/2018/01/30/vuex-study-2/</id>
    <published>2018-01-30T02:34:11.000Z</published>
    <updated>2018-01-30T10:23:37.953Z</updated>
    
    <content type="html"><![CDATA[<p>继续，这次尝试逐行理解Store类的东西</p><p>然后关于这次，一些“工具函数”都集中在<code>util.js</code>的这种做法，已经够我学的了。这是个很受用的做法。</p><h2 id="一些简单的东西"><a href="#一些简单的东西" class="headerlink" title="一些简单的东西"></a>一些简单的东西</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">  assert(Vue, <span class="string">`must call Vue.use(Vuex) before creating a store instance.`</span>)</div><div class="line">  assert(<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>, <span class="string">`vuex requires a Promise polyfill in this browser.`</span>)</div><div class="line">  assert(<span class="keyword">this</span> <span class="keyword">instanceof</span> Store, <span class="string">`Store must be called with the new operator.`</span>)</div><div class="line">&#125; <span class="comment">// 断言函数在util，如果不满足前面的情况，后面以error 排出来</span></div><div class="line"><span class="comment">// （实际上就是想看有没有在vue环境中和有没有正确安装）</span></div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> &#123;</div><div class="line">  plugins = [],</div><div class="line">  strict = <span class="literal">false</span></div><div class="line">&#125; = options <span class="comment">// 定义两个变量，在传入的对象中把这两个东西拿出来，字面意思</span></div></pre></td></tr></table></figure><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这里可能是会把整个vuex所有的内容都会规整到这些中</span></div><div class="line"><span class="comment">// store internal state  </span></div><div class="line"><span class="keyword">this</span>._committing = <span class="literal">false</span>  <span class="comment">// commit switch（ -&gt; mutations）</span></div><div class="line"><span class="keyword">this</span>._actions = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// actions</span></div><div class="line"><span class="keyword">this</span>._actionSubscribers = [] <span class="comment">// 应该像在dva中看到的订阅，没用过也没弄清楚应该怎么用</span></div><div class="line"><span class="keyword">this</span>._mutations = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// mutations</span></div><div class="line"><span class="keyword">this</span>._wrappedGetters = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// getters</span></div><div class="line"><span class="keyword">this</span>._modules = <span class="keyword">new</span> ModuleCollection(options) <span class="comment">// 分模块得到一个类</span></div><div class="line"><span class="keyword">this</span>._modulesNamespaceMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>)  <span class="comment">// 命名空间，上一次有讲到</span></div><div class="line"><span class="keyword">this</span>._subscribers = [] <span class="comment">// 所有订阅者</span></div><div class="line"><span class="keyword">this</span>._watcherVM = <span class="keyword">new</span> Vue() <span class="comment">//watcher??应该跟vue的watcher有关？</span></div></pre></td></tr></table></figure><h2 id="开始跳着理解"><a href="#开始跳着理解" class="headerlink" title="开始跳着理解"></a>开始跳着理解</h2><h3 id="store-与-操作绑定"><a href="#store-与-操作绑定" class="headerlink" title="store 与 操作绑定"></a>store 与 操作绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bind commit and dispatch to self</span></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">this</span> <span class="comment">// 把store 是指向 this 的</span></div><div class="line"><span class="keyword">const</span> &#123; dispatch, commit &#125; = <span class="keyword">this</span> <span class="comment">// 所以 &#123; dispatch, commit &#125; = store ?</span></div><div class="line"><span class="keyword">this</span>.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">boundDispatch</span> (<span class="params">type, payload</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> dispatch.call(store, type, payload)</div><div class="line">&#125;</div><div class="line"><span class="keyword">this</span>.commit = <span class="function"><span class="keyword">function</span> <span class="title">boundCommit</span> (<span class="params">type, payload, options</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> commit.call(store, type, payload, options)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>虽然有注释，就是把 commit, dispatch 和store绑定到<code>this</code>上，然后<code>{ dispatch, commit } = store</code>了。接着class中的<code>dispatch</code>指向刚刚对象中<code>dispatch</code>的方法，通过<code>call</code>用法改变作用域调用。我们用到的<code>this.$store.dispatch</code>应该来源这里，下面同理</p><h3 id="ModuleCollection"><a href="#ModuleCollection" class="headerlink" title="ModuleCollection"></a>ModuleCollection</h3><p>这里感觉很有意思，因为我这是第一次关注vuex的代码，我也不清楚命名空间等这些东西是什么时候加进去的，但我猜测应该是vue2.5之后的内容因为之前没在文档里见过这些东西。</p><p>字面意思，模块收集器。由于现在复杂度的关系，这部分应该先处理一下。把从vue的vuex得到的options，直接传入这个类，然后再进入<code>register</code>方法，接下来的工作就是不断的尾递归（？）得到整棵树。因为现在还有命名空间什么的，所以还有关于命名空间的判断和结合。</p><p>然后还有一些其他方法，比如热更什么的。</p><h3 id="installModule"><a href="#installModule" class="headerlink" title="installModule"></a>installModule</h3><p>使用到的位置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">installModule(<span class="keyword">this</span>, state, [], <span class="keyword">this</span>._modules.root)</div></pre></td></tr></table></figure></p><p>Store开始初始化的其中第一个方法。</p><p>这个方法，字面含义就是安装模块，猜测应该是把store相关的东西先配置下来。</p><p>这里有一个点（函数太长了不浪费篇幅了）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> isRoot = !path.length</div></pre></td></tr></table></figure></p><p>判断是否是根是通过<code>path</code>的长度来做的，如果没长度就是<code>/</code>了，很有意思，对于还没什么经验的我受益匪浅。</p><p>这个函数，需要5个参数，<code>store</code>, <code>rootState</code>, <code>path</code>, <code>module</code>, <code>hot</code>。最后一个应该也跟更新有关系吧？</p><p><code>this</code>在<code>class</code>中，所以指向是<code>class Store</code>的；<code>state</code>是<code>const state = this._modules.root.state</code>得到，而<code>_modules</code>就上面提到的定义了；因为还在根所以没有<code>path</code>，最后传入刚刚各种尾递归得到的树。</p><p>接下来注册命名空间，也就是判断这次的store有没有用到命名空间，有就分成一张张网，摊开处理。</p><p>接下来会遇到一个函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNestedState</span> (<span class="params">state, path</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> path.length</div><div class="line">    ? path.reduce(<span class="function">(<span class="params">state, key</span>) =&gt;</span> state[key], state)</div><div class="line">    : state</div><div class="line">&#125; <span class="comment">// 如果不是根的话会被分配到这里，看需不需要拼凑state，就“三光属性”</span></div></pre></td></tr></table></figure></p><p>非根注册应该是文档的<a href="https://vuex.vuejs.org/zh-cn/modules.html" target="_blank" rel="external">这里</a>吧，这里提到了模块可以只是局部注册，我们一般都直接在<code>main.js</code>完事儿了。</p><p>然后就是三种操作的模块遍历注册，用到的方法存在<code>module.js</code>，实则还是用到了<code>util.js</code>的遍历方法（通过回调函数返回回去，再次赞叹）</p><p>而注册的方法<code>registerMutation</code> &amp;&amp; <code>registerAction</code> &amp;&amp; <code>registerGetter</code> 就是我们用到的那些例如<code>store.commit(type, payload)</code>的方法。</p><p>然<code>registerAction</code>的方法比其他的复杂得多，它要求<code>handler</code>传入<code>dispatch</code>, <code>commit</code>, <code>getter</code>, <code>state</code>等。显然他命中注定要干一些“脏乱差”的工作。由此也可以得到为什么<code>actions</code>的方法，第一个参数(type)可以传入<code>{dispatch, commit, state}</code>…的东西了。</p><p>题外话：之前在某个论坛看到一个问题，问在vuex中的actions为什么可以取到state，不会造成什么乱七八糟的问题么？我也不知道，问题的答案先留着。不过因为可以得到state，所以我们可以通过现有的state来判断或者操作，这不是更方便了么？</p><h3 id="resetStoreVM"><a href="#resetStoreVM" class="headerlink" title="resetStoreVM"></a>resetStoreVM</h3><p>当一切都准备好了之后，怼进实例。</p><p>实际上前面也有提到，vuex是被vue当做专属插件进行安装的，在Vue实例环境中就可以通过<code>this.$store</code>摸到vuex。然后vuex就可以通过数据的改变来重新得到新的组件或者新的去促进生成得到新的dom。然后在上一篇有讲到那一堆辅助函数，实际上就是控制或者约束操作，但实质就是<code>Vue.$store.dispatch</code>等等等。</p><p>先是从store拿到vm作为旧的vm以作备份（当然如果不存在就不存在备份了），然后让<code>Vue</code>把这段操作定义为静默操作。</p><p>接着生成通过<code>new Vue</code>生成新的vm（假如有旧的也备份了，不会影响），恢复取消静默操作。（意思就是偷偷替换了vm）</p><p>至此新的视图已经更新完成，没有出意外的话，存在的刚刚备份过的旧vm就可以干掉的，执行销毁</p><h3 id="withCommit"><a href="#withCommit" class="headerlink" title="_withCommit()"></a>_withCommit()</h3><p>通篇是没有提到这个函数的，到这里提一下是因为，至此这个函数用了两次，最后一次是发生在刚刚<code>resetStoreVM</code>的最后，如果存在热更的情况下那里。篇幅不长，拿出来看一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">_withCommit (fn) &#123;</div><div class="line">  <span class="keyword">const</span> committing = <span class="keyword">this</span>._committing</div><div class="line">  <span class="keyword">this</span>._committing = <span class="literal">true</span></div><div class="line">  fn()</div><div class="line">  <span class="keyword">this</span>._committing = committing</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>毕竟状态管理，如果谁都能理这个状态，还需要管理干什么。这里的理解可以套入<code>reducer</code>协助理解，<code>state</code>有且仅有<code>reducer</code>可以修改，而vuex的<code>mutations</code>也就是做这份工作的地方。然后<code>_withCommit</code>的话，是个代理来的。</p><p>还是刚刚备份旧vm那个样子，先备份当前状态，然后把该状态转为<code>true</code>，据说是如果不暂时改变状态，严格<code>vuex</code>会认为这是非法操作，是禁止的。</p><p>封印解除之后，执行一下回调（各种需要破例更新的数据），然后再固着。</p><p>为什么这里需要备份状态换回去，而且这里是<code>boolean</code>，非黑即白的。实际上如果这个所谓的开关，在执行这里之前就是关闭的，那道理通过。如果在这之前，开关本来开着，这样你执行一次这里，就又把开关关回去的话，会影响到其他地方的正常工作，这不是一个“合格的秘书”。</p><p>刚刚最后那里的操作<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">store._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  oldVm._data.$$state = <span class="literal">null</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>就是假如这里是<code>hot</code>的话，就把旧vm的状态改成<code>null</code>，然后跟这个vm有关的watcher和计算都会被强行触发更新。通过这样让页面不刷新然后刷新dom。</p><p>最后一个问题：为什么明明<code>this</code>指向的是本体(Store)，初始化的时候需要<code>const store = this</code></p><p>回答：JavaScript那么牛逼的<code>this</code>，墙头草属性的，不找个需要固定的位置固定下来肯定会有机会被带偏的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续，这次尝试逐行理解Store类的东西&lt;/p&gt;
&lt;p&gt;然后关于这次，一些“工具函数”都集中在&lt;code&gt;util.js&lt;/code&gt;的这种做法，已经够我学的了。这是个很受用的做法。&lt;/p&gt;
&lt;h2 id=&quot;一些简单的东西&quot;&gt;&lt;a href=&quot;#一些简单的东西&quot; class=&quot;headerlink&quot; title=&quot;一些简单的东西&quot;&gt;&lt;/a&gt;一些简单的东西&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (process.env.NODE_ENV !== &lt;span class=&quot;string&quot;&gt;&#39;production&#39;&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  assert(Vue, &lt;span class=&quot;string&quot;&gt;`must call Vue.use(Vuex) before creating a store instance.`&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  assert(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt; !== &lt;span class=&quot;string&quot;&gt;&#39;undefined&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;`vuex requires a Promise polyfill in this browser.`&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  assert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; Store, &lt;span class=&quot;string&quot;&gt;`Store must be called with the new operator.`&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;comment&quot;&gt;// 断言函数在util，如果不满足前面的情况，后面以error 排出来&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// （实际上就是想看有没有在vue环境中和有没有正确安装）&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  plugins = [],&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  strict = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; = options &lt;span class=&quot;comment&quot;&gt;// 定义两个变量，在传入的对象中把这两个东西拿出来，字面意思&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="vue" scheme="https://colmugx.github.io/blog/tags/vue/"/>
    
      <category term="vuex" scheme="https://colmugx.github.io/blog/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>vuex源码理解（一）</title>
    <link href="https://colmugx.github.io/blog/2018/01/25/vuex-study-1/"/>
    <id>https://colmugx.github.io/blog/2018/01/25/vuex-study-1/</id>
    <published>2018-01-25T15:39:58.000Z</published>
    <updated>2018-01-26T02:38:08.360Z</updated>
    
    <content type="html"><![CDATA[<p>看个代码代价很高，我边读边转笔，然后一个失手把手挑了个滴血不止…（笔头挑掉了一层手皮）</p><p>vuex和dva的源码都想看，不然没办法知道相性在哪。</p><h2 id="由口而入"><a href="#由口而入" class="headerlink" title="由口而入"></a>由口而入</h2><p>这都暴露干净了…<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  Store,</div><div class="line">  install,</div><div class="line">  version: <span class="string">'__VERSION__'</span>,</div><div class="line">  mapState,</div><div class="line">  mapMutations,</div><div class="line">  mapGetters,</div><div class="line">  mapActions,</div><div class="line">  createNamespacedHelpers</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>install</code>肯定是Vue老套路，想把东西当插件用肯定要暴露这个方法。这个之前写组件经常需要碰到，弃之！</p><p>这次就先读暴露出来的四个方法吧</p><a id="more"></a><h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><h3 id="normalizeNamespace"><a href="#normalizeNamespace" class="headerlink" title="normalizeNamespace"></a>normalizeNamespace</h3><p>这个东西可能要先讲，因为你看到<code>mapState</code>的第一眼你就会看到他，虽然不重要。</p><p>这应该是一个初始化或者标准化命名空间的方法，之前”尝试用dva的理解对处理数据”有遇到使用命名空间的情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">  ...mapState(<span class="string">'spacename'</span>, &#123;</div><div class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.count </div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>看一下实现方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeNamespace</span> (<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">namespace, map</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> namespace !== <span class="string">'string'</span>) &#123;</div><div class="line">      map = namespace</div><div class="line">      namespace = <span class="string">''</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (namespace.charAt(namespace.length - <span class="number">1</span>) !== <span class="string">'/'</span>) &#123;</div><div class="line">      namespace += <span class="string">'/'</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> fn(namespace, map)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>映入眼帘就是一个柯里了，大致意思就是命名空间需要处理，如果进来的函数第一个不是空间名称那么肯定直接是对象了，因为我们也不是必须使用命名空间，比如最普通的这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">  ...mapState(&#123;</div><div class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.count </div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果有命名空间的话，就根据层数用<code>/</code>分开，比如<code>app/save</code></p><h3 id="normalizeMap"><a href="#normalizeMap" class="headerlink" title="normalizeMap"></a>normalizeMap</h3><p>对不起还是不能讲到<code>mapState</code>，毕竟通用的函数理解完了之后，游戏也就结束了。（要不怎么说是辅助函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Normalize the map</span></div><div class="line"><span class="comment"> * normalizeMap([1, 2, 3]) =&gt; [ &#123; key: 1, val: 1 &#125;, &#123; key: 2, val: 2 &#125;, &#123; key: 3, val: 3 &#125; ]</span></div><div class="line"><span class="comment"> * normalizeMap(&#123;a: 1, b: 2, c: 3&#125;) =&gt; [ &#123; key: 'a', val: 1 &#125;, &#123; key: 'b', val: 2 &#125;, &#123; key: 'c', val: 3 &#125; ]</span></div><div class="line"><span class="comment"> * @param &#123;Array|Object&#125; map</span></div><div class="line"><span class="comment"> * @return &#123;Object&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeMap</span> (<span class="params">map</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(map)</div><div class="line">    ? map.map(<span class="function"><span class="params">key</span> =&gt;</span> (&#123; key, <span class="attr">val</span>: key &#125;))</div><div class="line">    : <span class="built_in">Object</span>.keys(map).map(<span class="function"><span class="params">key</span> =&gt;</span> (&#123; key, <span class="attr">val</span>: map[key] &#125;))</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注释都直接告诉你了！对的实际上组件对<code>vuex</code>的访问可以有两种，对象或者数组。对象的情况上面已经有了，还有一种数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">  ...mapState(<span class="string">'spacename'</span>, [</div><div class="line">    <span class="string">'count'</span></div><div class="line">  ])</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种是，如果组件的参数跟vuex设定一样，那么就直接传入数组匹配，相当于<code>this.count</code>指向<code>this.$store.state.count</code></p><h3 id="mapState-mapMutations-mapGetters-mapActions"><a href="#mapState-mapMutations-mapGetters-mapActions" class="headerlink" title="mapState, mapMutations, mapGetters, mapActions"></a>mapState, mapMutations, mapGetters, mapActions</h3><p>剩下的就真的是“拼装术”的事情了，通过暴露出去的辅助函数所接收到的数据进行转换并连接<code>vuex</code>。</p><p>相当于<code>redux</code>本身只提供了状态管理，便捷操作需要接触各类型插件。而<code>vuex</code>作为<code>vue</code>专属状态管理，已经提供了最适合<code>vue</code>的操作。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>由于辅助函数做的工作就是提供在组件中对<code>vuex</code>连接操作的工作，而函数中的转换结果都会是<code>this.$store</code>。在注入<code>vue</code>的环境中，<code>this</code>不出意外的话是指向<code>vue</code>原型上的，这也就意味着，<code>vuex</code>实际上也是作为插件附着在<code>vue</code>原型中。</p><p>不过关于这一点，在一开始就有提到，<code>vuex</code>是通过暴露自己的安装函数让<code>vue</code>可以直接<code>use()</code>。而且我们在<code>main.js</code>绑定时也默认使用<code>store</code>这个key。</p><p>这样的话，只要是能访问到<code>vue</code>的地方就可以访问到<code>$store</code>了，包括组件。<strong>从而可以做到不需要什么辅助函数也不需要<code>actions</code>直接对状态管理动手动脚。</strong>这不仅是react的使用者感觉到的诧异或者反感了吧。</p><p>不过团队是知道这种情况的存在的，所以他们是<strong>推荐在组件中使用辅助函数，请不要直接操作</strong>。</p><p>（不过这个注释最多也就说说而已，懂道理的人都会这么做；不懂道理的，只存留“我只要解决问题就行了”的某些人是不会这么做的。）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看个代码代价很高，我边读边转笔，然后一个失手把手挑了个滴血不止…（笔头挑掉了一层手皮）&lt;/p&gt;
&lt;p&gt;vuex和dva的源码都想看，不然没办法知道相性在哪。&lt;/p&gt;
&lt;h2 id=&quot;由口而入&quot;&gt;&lt;a href=&quot;#由口而入&quot; class=&quot;headerlink&quot; title=&quot;由口而入&quot;&gt;&lt;/a&gt;由口而入&lt;/h2&gt;&lt;p&gt;这都暴露干净了…&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Store,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  install,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  version: &lt;span class=&quot;string&quot;&gt;&#39;__VERSION__&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  mapState,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  mapMutations,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  mapGetters,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  mapActions,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  createNamespacedHelpers&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;install&lt;/code&gt;肯定是Vue老套路，想把东西当插件用肯定要暴露这个方法。这个之前写组件经常需要碰到，弃之！&lt;/p&gt;
&lt;p&gt;这次就先读暴露出来的四个方法吧&lt;/p&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="vue" scheme="https://colmugx.github.io/blog/tags/vue/"/>
    
      <category term="vuex" scheme="https://colmugx.github.io/blog/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>通过dva得到的思考 —— “滥用”VUEX</title>
    <link href="https://colmugx.github.io/blog/2018/01/22/vuex-dva/"/>
    <id>https://colmugx.github.io/blog/2018/01/22/vuex-dva/</id>
    <published>2018-01-22T15:35:15.000Z</published>
    <updated>2018-01-23T01:58:09.785Z</updated>
    
    <content type="html"><![CDATA[<p>首先这一手骚操作要感谢@ahonn，确实这几天学习dva，我自己都觉得自己有点烦了。但是老哥好耐心，真心感谢。</p><p>直接上正题吧不磨磨唧唧的了！</p><h3 id="dva是什么"><a href="#dva是什么" class="headerlink" title="dva是什么"></a>dva是什么</h3><p>这还用说吗，坦克啊！双命特性，大招是通过机甲自爆产生大范围爆炸，本体只有100血，可以反…啊！！！别打我啊！</p><p>好吧可能阿里的工程师也喜欢玩守望先锋，而且我清晰记得dva这个框架就是守望大火的时候诞生的，而且还有一个协同工具叫路霸吧。（看来阿里的工程师都不喜欢当C…）</p><a id="more"></a><p><code>dva</code>是针对<code>react</code>的框架，实际上就是关于<code>redux</code>的一个封装。首先是让本来很难理解和使用的redux变得相对容易理解和操作。另外一个就是因为数据集中管理，并且推荐使用无状态组件，操作者只需要关心数据的走向。</p><h3 id="从dva得到了启示"><a href="#从dva得到了启示" class="headerlink" title="从dva得到了启示"></a>从dva得到了启示</h3><p>毕竟阿里前端工程师，Ahonn是真的喜欢阿里的东西…最近跟他聊天也比较深入了解“为什么我们需要dva”。</p><p>后来我一个闪念：<code>dva</code>会不会就是一个数据库模型，实际上redux对我们来说就是一个数据库，前端没有状态，不干涉数据，实际上就是我们常说的只关心增删改查？</p><p>那么dva实际上还是对<code>redux</code>，<code>redux-saga</code>，<code>redux-thunk</code>的封装，但对于vue来说简直就是先天优势，因为对于vuex来说已经相当于redux + redux-saga了。从这里也直接萌生了一个想法：vuex + stateless component = 1/2 dva ？</p><h3 id="对启示更清晰的思考"><a href="#对启示更清晰的思考" class="headerlink" title="对启示更清晰的思考"></a>对启示更清晰的思考</h3><p>首先现在的dva，把数据都封装在<code>model</code>中，一个<code>model</code>对应一个redux，<code>state</code>, <code>reducer</code>概念得以保留，引入<code>effect</code>和<code>subscriptions</code>概念。</p><p>首先副作用的目的是，通过异步操作例如网络请求或者一些需要异同步配合的操作，然后去驱使<code>reducer</code>更新<code>state</code>，因为在流中，只有<code>reducer</code>有权利去动<code>state</code>。<code>subscriptions</code>就是一个订阅的概念，在我看来就是一个初始化，或者说是一个接受状态的概念。</p><p>那么为什么说vuex有先天优势？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// dva model</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  namespace: <span class="string">"users"</span>,</div><div class="line">  state: &#123;&#125;,</div><div class="line">  reducers: &#123;&#125;,</div><div class="line">  effects: &#123;&#125;,</div><div class="line">  subscriptions: &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// vuex</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  modules: &#123;</div><div class="line">    users: &#123;</div><div class="line">      namespaced: <span class="literal">true</span>,</div><div class="line">      state: &#123;&#125;,</div><div class="line">      mutations: &#123;&#125;,</div><div class="line">      actions: &#123;&#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>如果你要无限逼近dva是什么感觉？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// users.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  namespaced: <span class="literal">true</span>,</div><div class="line">  state: &#123;&#125;,</div><div class="line">  mutations: &#123;&#125;,</div><div class="line">  actions: &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//store.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  modules: &#123;</div><div class="line">    users</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>由于 vue/vuex 对于规则还是相对宽松，但理是理法是法，约定俗成<code>mutations</code>是用来做同步的工作，可以用来操作<code>state</code>；<code>actions</code>用来做异步工作，通知<code>mutations</code>去操作<code>state</code>。所以这里是不是就有一种新的概念？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">state &lt;=&gt; state</div><div class="line">mutation &lt;=&gt; reducer</div><div class="line">action &lt;=&gt; effect</div><div class="line"></div><div class="line">_ &lt;=&gt; subscription</div></pre></td></tr></table></figure><p>对没错，订阅怎么办？</p><p>在dva的例子中，看一下示例的订阅是做了什么工作？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">subscriptions: &#123;</div><div class="line">  setup(&#123; dispatch, history &#125;) &#123;</div><div class="line">    <span class="keyword">return</span> history.listen(<span class="function">(<span class="params">&#123; pathname, query &#125;</span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">if</span> (pathname === <span class="string">'/users'</span>) &#123;</div><div class="line">        dispatch(&#123; <span class="attr">type</span>: <span class="string">'fetch'</span>, <span class="attr">payload</span>: query &#125;)</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>所以关于这个简单订阅，我们完全可以直接用<code>vue-router</code>，而其中刚好有一个概念我们可以直接使用 —— 导航守卫</p><h3 id="针对vue的操作"><a href="#针对vue的操作" class="headerlink" title="针对vue的操作"></a>针对vue的操作</h3><p>老样子，我们是怎么理解dva的<code>model</code>，就怎么理解vuex的<code>store</code>。首先<code>state</code>和<code>reducer</code>跟vuex的定义是完全对等的，不需要多理解。<code>effects</code>是使用<code>generator</code>函数来解决异同步问题的，那好办啊，都2018年了，我们直接用async/await就行了。而且我们之前关于api都是使用<code>promise</code>，而且用的也是<code>axios</code>，所以这部分可以说是无缝切换。</p><p>那么关于订阅，直接使用<code>vue-router</code>的导航守卫对路由监控，另外在必要的时候还能使用<code>meta</code>。当然导航守卫并不是只能用在全局上，也可以注入到组件中，所以我们注入到页面组件即可。</p><p>接下来就是无状态组件问题了，vue默认是状态组件，而且无状态组件也没有react来的方便。</p><p>react想要无状态组件，无非就是一个函数就结束战斗了。vue也有一个概念叫函数式组件，也就是无状态，这种组件在使用上就已经不是很方便了。</p><p>vue的函数式组件就必须使用<code>render</code>函数不能用<code>template</code>模板，一直到vue2.5才可以在<code>&lt;template functional&gt;</code>使用。但我尝试了一下，手感并不好，所以还是只能用 jsx + vue 这种搭配来操作。不过vue的无状态组件也不像react那么好理解，它依然是一个Object</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  functional: <span class="literal">true</span>， <span class="comment">// 你只不过是通过这个开关来切换组件状态</span></div><div class="line">  methods: &#123;</div><div class="line">    ...mapActions(<span class="string">'spacename'</span>, &#123;</div><div class="line">      add: <span class="string">'create'</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> &lt;h1&gt;&#123;props.msg&#125;&lt;/h1&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>而且在实际使用中，实际上因为vue的概念，你还是没办法在所有组件完全不使用无状态组件（已经除去表单组件）。不过也无伤大雅了。</p><p>所以通过这个操作，也能近似的得到了dva的那种感觉。前端的工作只需要直观的反馈你的数据动向和状态，要那么复杂干什么？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先这一手骚操作要感谢@ahonn，确实这几天学习dva，我自己都觉得自己有点烦了。但是老哥好耐心，真心感谢。&lt;/p&gt;
&lt;p&gt;直接上正题吧不磨磨唧唧的了！&lt;/p&gt;
&lt;h3 id=&quot;dva是什么&quot;&gt;&lt;a href=&quot;#dva是什么&quot; class=&quot;headerlink&quot; title=&quot;dva是什么&quot;&gt;&lt;/a&gt;dva是什么&lt;/h3&gt;&lt;p&gt;这还用说吗，坦克啊！双命特性，大招是通过机甲自爆产生大范围爆炸，本体只有100血，可以反…啊！！！别打我啊！&lt;/p&gt;
&lt;p&gt;好吧可能阿里的工程师也喜欢玩守望先锋，而且我清晰记得dva这个框架就是守望大火的时候诞生的，而且还有一个协同工具叫路霸吧。（看来阿里的工程师都不喜欢当C…）&lt;/p&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="vue" scheme="https://colmugx.github.io/blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer —— 替换空格</title>
    <link href="https://colmugx.github.io/blog/2018/01/04/replace-space/"/>
    <id>https://colmugx.github.io/blog/2018/01/04/replace-space/</id>
    <published>2018-01-03T16:03:46.000Z</published>
    <updated>2018-01-03T16:06:42.821Z</updated>
    
    <content type="html"><![CDATA[<p>以后博客专职曲苑杂坛算了…</p><p>刚刚看到一题</p><blockquote><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></blockquote><p>我想这什么腿？然后什么都没想，直接就</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> str.replace(<span class="regexp">/\ /g</span>, <span class="string">'%20'</span>)</div></pre></td></tr></table></figure><p>然后过了……虽然100多毫秒</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以后博客专职曲苑杂坛算了…&lt;/p&gt;
&lt;p&gt;刚刚看到一题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
      <category term="曲苑杂坛" scheme="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>我的2017</title>
    <link href="https://colmugx.github.io/blog/2017/12/30/my-2017/"/>
    <id>https://colmugx.github.io/blog/2017/12/30/my-2017/</id>
    <published>2017-12-30T04:53:15.000Z</published>
    <updated>2018-02-22T08:56:30.020Z</updated>
    
    <content type="html"><![CDATA[<p>我本来是最反感写年终总结的那一个，我最讨厌的就是形式化的东西。</p><p>但感觉今年还是挺有意义的，学着去接触了很多东西，所以我还是愿意记录下所有第一次。</p><h2 id="2017"><a href="#2017" class="headerlink" title="-2017"></a>-2017</h2><blockquote><p>好稚嫩；<br>所以你也算是入了前端的坑？<br>—— Ahonn</p></blockquote><p>我的新前端，从这开始的。<br><a id="more"></a></p><h2 id="2017-1"><a href="#2017-1" class="headerlink" title="2017"></a>2017</h2><p>所以到这里才是关于今年的事情。</p><h3 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h3><p>写了一个HEXO “KPA” 产物主题就是现在正在使用的 Nlvi ，第一个版本“语”。</p><p>Nlvi的出生并不是纯洁的，它一开始只是想用来证明自己。拿着它去找工作。所以我除了提交到 hexo theme 并没有做其他的宣传。直到过了一整天，在项目看到第一个star的时候我才知道，我错了。我开始修正我的想法，毕竟nlvi也是love类型的。所以经历了一年的迭代，有了新的版本“彩”。</p><p>然而“彩”的初衷是看到了issue有一条评论：迫切需要颜色。</p><p>所以如今 Nlvi 相比年初，它更完善了。也保留了最初的设计融合了颜色的内容，多了一种风格。让我感动的是，目前已经至少有92人对它的肯定。主题还有两个老哥一起维护，虽然从“语”切换到“彩”让他们从contributor消失了，但我还是记住他们：ruinshe, lostinlight。</p><p>开始逐渐适应了现在的网页，迎合现在比较清晰的设计。所以把一些常用的<code>CSS3</code>动画打包成库，加上一些自己的小想法，成为我的第一个动画库——syuanpi.css。但是它并没有什么好讲的，但它同样有意义——第一次接受了知乎用户的怜悯。</p><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>开始专注学习<code>JavaScript</code>，在这之前还尝试过<code>angular</code>和<code>TypeScript</code>呢，也是不了了之。</p><p>不过我并没有直接去看书，而是去看别人的代码。去学现在大家都是怎么写怎么对待这门学科的。直到后面理解了虽然你是能做事了，还是少不了看书，所以开始读《红宝书》、《DOM艺术》。</p><p>高中水技术的时候，已经从一位我很敬仰的工程师了解到，这个世界分编程语言的话只分成两种：指令式编程，函数式编程。还有一些适应性强的语言，它们叫多范式。例如C系都是指令式，JavaScript是函数式。从这之后，“函数式编程”只是我用来装b的词汇。但从今年开始，学js同时也学函数式编程思想。真正开始“拿函数式当枪使”的时候是 @Ahonn 吹了一次<code>ClojureScript</code>，从这开始我从小打小闹直接进入疯狂沉迷状态。现在觉得<code>haskell</code>基础部分还是可以接受的，就是不知道有什么用…</p><p>说起来我的<code>Hyper</code>好像要凉了…每次用TS都感觉手感不太对的样子…</p><p>一直使用现代编辑器的我看到别人用<code>vim</code>、<code>emacs</code>都会在心里嘲讽他，没错今年轮到我当sb了，开始使用<code>vim8</code>和<code>spacemacs</code>。vim还在慢慢配置的状态，平时多数是 linux + macos，vim多数在linux那边使用的。现在mac的质量和手感越来越差，也是找个借口让自己适应windows + linux吧。有时候还是会不适应spacemacs，所以保留了vscode。结果一年下来用得最多的依然是vscode。</p><p>还是跟往常一样，学习没规律，只要不上班就哐哐开始搞。看到 @Ahonn 使用“番茄工作法”规划时间，我想2018年也尝试一下，取长补短嘛。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>创业划水之后，好像也挺无聊的然后第一次去上班。因为起步比别人慢，所以基本上错过了所有校招，加上学历问题，最后面试了两家外包公司，去了一家交通方便的。</p><p>基本上就是各种不适应咯，并不是上班不适应，而是编程范式不适应。见识过各种金主爸爸的无理取闹，使得开发从完整系统到拆散系统；见识过设计稿毫无章法不给规范说明却要求严格把控细节；见识过严格要求遵守规范却没有规范文件，想到什么规范什么。</p><p>给了一个“前端工程师”的title，却领导着一整个前端团队。没错，这个前端团队只有我一人。所以前端团队和能用前沿技术做前沿开发成为了憧憬，可以说每天都在期待着这天。嘛，没坏处，至少比其他人多体会到更多的东西。至少我现在可以站着跟你说：我能够用微信小程序开发出7层路由的应用！我开发过20+个页面的小程序！</p><h3 id="游戏-读书"><a href="#游戏-读书" class="headerlink" title="游戏/读书"></a>游戏/读书</h3><p>单片机，树莓派，还有上面说的，每天都是以搞为生，一年接触一堆语言和设计模式。当然游戏依然是我的主要放松方式。</p><p>今年也没打通过什么游戏，年初买了<code>Nintendo Switch</code>，只打通了《超级马里奥·奥德赛》，其他的游戏基本上也不算通，毕竟有意思的内容都是网络部分。现在在玩《异度之刃2》，毕竟是这个月的游戏，一个月通关对我来说真的不可能。</p><p>社交元素，玩起了《王者荣耀》，但我并不喜欢玩手机游戏，为了搭上话才去玩。一天两把，有一天没一天的，三个赛季两个白金一个钻石。</p><p>相比去年今年的游戏时间可以说少了很多，主要都花时间在搞前端上了。</p><p>读书的话，除了一些新闻、报纸杂志，其他文学类的书我也不是很能读得下去，所以看了比较多的技术类。读过一两本也是题材得非常感兴趣的，翻了几页《草木缘情》，在多看读了两本东野圭吾的小说。然后大多数时间都在设计模式，数据结构。</p><h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><p><strong>没有计划！</strong></p><p>这就是真实的我，从来不会先给自己夸下海口。计划永远赶不上变化，只要时间不是浪费的就好了。哪怕玩游戏，游戏能带出来的内容也是相当多的。</p><p>一整年 @Ahonn 隐隐约约给的帮助还是相当大的，很感谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我本来是最反感写年终总结的那一个，我最讨厌的就是形式化的东西。&lt;/p&gt;
&lt;p&gt;但感觉今年还是挺有意义的，学着去接触了很多东西，所以我还是愿意记录下所有第一次。&lt;/p&gt;
&lt;h2 id=&quot;2017&quot;&gt;&lt;a href=&quot;#2017&quot; class=&quot;headerlink&quot; title=&quot;-2017&quot;&gt;&lt;/a&gt;-2017&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;好稚嫩；&lt;br&gt;所以你也算是入了前端的坑？&lt;br&gt;—— Ahonn&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的新前端，从这开始的。&lt;br&gt;
    
    </summary>
    
    
      <category term="扣肉小记" scheme="https://colmugx.github.io/blog/tags/%E6%89%A3%E8%82%89%E5%B0%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>有意思的monad记录</title>
    <link href="https://colmugx.github.io/blog/2017/12/27/funny-monad/"/>
    <id>https://colmugx.github.io/blog/2017/12/27/funny-monad/</id>
    <published>2017-12-27T15:24:58.000Z</published>
    <updated>2018-01-01T14:11:05.380Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看到monad我的第一反应竟然是莫纳德…</p></blockquote><p>最近学习haskell的时候（意外的觉得入门不难），接触到函数式编程一个新的思想——Monad</p><p>之前在知乎看到轮子哥说：学习haskell是好事，但最好就是学到monad就停下来，然后去学别的。对别的语言帮助很大。</p><p>然后在知乎看了一些monad的答案，找了点关于monad的博客看，没看懂。英文的话更不可能了！直接看paper的话我会脆死的。</p><p>后来偶然找到一篇文章：<a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="external">Functors, Applicatives, And Monads In Pictures - adit.io</a></p><p>当然有中文版：<a href="http://jiyinyiyong.github.io/monads-in-pictures/" target="_blank" rel="external">Functors, Applicatives, And Monads In Pictures - adit.io</a>，<br><a href="http://www.ruanyifeng.com/blog/2015/07/monad.html" target="_blank" rel="external">图解 Monad - 阮一峰的网络日志</a></p><p>全程特别轻松，我以后写博客也要按照这个节奏来写！很有意思！<br>（那个抽东西的手直接戳爆了我的笑点…特别是解构传入胶水函数的时候）</p><p>关于理解的话，挖个坑以后总结~</p><p>但有一点是：我用 Vue-jsx 的时候，几乎全是Monad</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;看到monad我的第一反应竟然是莫纳德…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近学习haskell的时候（意外的觉得入门不难），接触到函数式编程一个新的思想——Monad&lt;/p&gt;
&lt;p&gt;之前在知乎看到轮子哥说：学习haskell是好事，但最
      
    
    </summary>
    
      <category term="曲苑杂坛" scheme="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/"/>
    
    
      <category term="Functional Programming" scheme="https://colmugx.github.io/blog/tags/Functional-Programming/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript链式方法</title>
    <link href="https://colmugx.github.io/blog/2017/12/23/js-method-chaining/"/>
    <id>https://colmugx.github.io/blog/2017/12/23/js-method-chaining/</id>
    <published>2017-12-23T10:05:54.000Z</published>
    <updated>2017-12-27T08:56:56.889Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>著名框架<code>jQuery</code>所使用的设计模式——“虾扯蛋”</p></blockquote><p>之前在知乎回答过一个问题：2018的前端应该学什么。</p><p>我回答了：就算前端再复杂，jQuery依然是最流行的那个。</p><p>这答案怎么样呢？废话！肯定没人点赞了！</p><p>人性就是如此！一旦接受了更<del>装逼</del>新的思路，就会觉得以前见过的东西都太弱了！</p><p>新项目想用什么就用什么，什么技术栈健全就用什么。可是老项目并没办法想干什么干什么，时间和精力不允许他去重构。金蝶还在卖VB呢，他们肯定也想过VB已经不行了。</p><p>好了题外话，我还是很有兴趣实现一个塞进<code>nlvi</code>的类jq的。</p><a id="more"></a><h2 id="怎么来的链式操作"><a href="#怎么来的链式操作" class="headerlink" title="怎么来的链式操作"></a>怎么来的链式操作</h2><blockquote><p>如果不用链式调用，jQuery没有性能可言 ——鲁迅</p></blockquote><p>鲁迅：我不是！我没有！别乱说啊！</p><p>我记得有人测试过，<code>$(&#39;#ele&#39;)</code>会比<code>document.getElementById(&#39;ele&#39;)</code>慢很多。如果是按行操作dom而不是用专属的链式调用，效率会更差。</p><p>但这次不是来讨论jQuery的效率的。链式方法也是一种设计模式，有必要了解一下。就算ES6常使用的<code>Promise</code>，也用到了链式调用。</p><p><code>JavaScript</code>能够函数式编程，还是因为它是个“函数为第一公民”的语言，但它并没有<code>pure function</code>是因为它的设计其实是多范式的。而ES6把构造函数和<code>classes</code>加进去之后更是证明了这一点。</p><h3 id="我用过的JavaScript"><a href="#我用过的JavaScript" class="headerlink" title="我用过的JavaScript"></a>我用过的JavaScript</h3><p>关于这部分，我觉得我想分享的东西有点超篇幅，所以移步到另外一篇分享吧：<a href="/PersonalBlog/2017/12/26/my-known-javascript/">我所认识的JavaScript</a></p><p>大致上就是<code>JavaScript</code>之所以能这么玩是因为它会把任何东西都看做“函数”来看待，并且以它的理解就是：我能且只能掌控函数，函数必有返回值。并且每产生一个函数就会有一个“我”的含义：<code>function</code>会自然而然的产生<code>this</code>并指向自己。而链式操作就是利用了这点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果是浏览器的话，在没有对象的情况下，父级应该就是<code>window</code>了。而函数返回<code>this</code>相当于把自己返回到操作空间中，而操作空间属于父级。也就是说，只要是同一级别的函数，通过返回<code>this</code>把操作权交还到父级手中从而达到继续调用同级函数的技能。还不清楚？反正我不画图。</p><h3 id="简单链式操作"><a href="#简单链式操作" class="headerlink" title="简单链式操作"></a>简单链式操作</h3><p>在此我们以著名歌唱家“雷军”举个例子。雷军可以说是目前最强悍的企业家了，写得了软件造得了手机，能唱一首好歌能吹一手好B。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 雷军（人为对象，构造成立）</span></div><div class="line"><span class="keyword">var</span> LeiJun = &#123;</div><div class="line">  hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'hello, '</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="comment">// -&gt; LeiJun</span></div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  thank: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'thank you, '</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="comment">// -&gt; LeiJun</span></div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  thanks: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'thank you very much, '</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="comment">// -&gt; LeiJun</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 驱使对象雷军唱出《Are you ok》前三句</span></div><div class="line">leijun</div><div class="line">  .hello()</div><div class="line">  .thank()</div><div class="line">  .thanks()</div></pre></td></tr></table></figure><p>如果按字面意思可能永远都理解不来，从而产生哲学三连：我是谁？我在哪？我在干什么？所以又有一句话得以解释：从哪里来，回哪里去。</p><h2 id="为什么用链式操作"><a href="#为什么用链式操作" class="headerlink" title="为什么用链式操作"></a>为什么用链式操作</h2><blockquote><p>新手村的Monad？</p></blockquote><p>所以作用很明显了，一种工厂流水线式的操作，流的形式完成任务。所以我要把这种设计模式归入函数式编程也是因为，函数式思想本来就是让数据经过所有“函数流”最后得到产物并返回。数据不变，不额外干涉操作。</p><p>不同的是，常规FP中，不管是单函数单返回走流，还是柯里化，它都是一种“一进一出”的思想——出来的产物继续传入下一道“工序”进行加工，一直到最后一个加工函数为止。</p><p>然而链式操作并不是这种哲学，它是一种“从第一次进入就买定离手”的操作——只要一开头传入参数，流不结束不会见到半成品。数据经过一层函数之后，可能经过加工处理结束后，又会被打包/压缩/处理到‘this’中并继续接下来的工作。</p><p>链式操作相对于柯里化来说，起码它做到了：</p><ul><li>可阅读</li><li>少占用</li><li>减少代码重复性（都有）</li><li>代码简洁（都有）</li></ul><p>柯里化最明显的优点就是阅读性差（？？？），假设有个方法叫<code>leijun</code>,那么调用方法的画风就大不相同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">leijun()()()</div></pre></td></tr></table></figure><p>鬼才知道他想唱的是“Are you ok”还是“Indian Mi Fans”呢……</p><p>还有就是，因为流操作可以异步。JS也是患有懒癌很多年了，必须靠事件驱动才能工作，所以注定它是不能异步编程的。</p><p>所以jQuery还是很强大的框架，在ES5什么都没有就靠三种规范的语法，已经要实现那么多东西了。让JS支持异步编程也就两种操作吧：函数内回调函数、链式操作函数。这框架两种都用上了。而说NodeJS速度快，一方面也是因为目前两个服务器框架都是异步（一堆回调函数）得到的结果吧。</p><h2 id="不止JavaScript能用"><a href="#不止JavaScript能用" class="headerlink" title="不止JavaScript能用"></a>不止JavaScript能用</h2><p>实际上本质就是，把执行权交给函数之后，函数执行完自己的工作之后，还可以吧执行权重新交回父级手中，让父级自行处理接下来的工作。</p><p>所以强化函数式编程的语言或者说能返回自身的语言应该都可以支持该模式，在这之后我只接触过<code>Golang</code>有这种操作，不过那当时哪来的Go啊…</p><p>这个世界本来就先有的FP，因为概念不够清晰才出现了OOP。现在业务量复杂到OOP已经不好解决了，这个时候人们又想起了凉了的FP。2018年如果前端继续发展下去，可能又会回到一个FP的年代（然后我要放弃FP看着它火了？不！这次看到希望不会撒手了！）</p><p>在我在无脑吹FP的时候（懂得概念不懂得实践），我看到了swift的出现，JAVA8强化λ，go的出现，TypeScript的出现（乱入，它强调OOP）。前几天看到了<code>haskell-react</code>，以后还会有什么？</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;著名框架&lt;code&gt;jQuery&lt;/code&gt;所使用的设计模式——“虾扯蛋”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前在知乎回答过一个问题：2018的前端应该学什么。&lt;/p&gt;
&lt;p&gt;我回答了：就算前端再复杂，jQuery依然是最流行的那个。&lt;/p&gt;
&lt;p&gt;这答案怎么样呢？废话！肯定没人点赞了！&lt;/p&gt;
&lt;p&gt;人性就是如此！一旦接受了更&lt;del&gt;装逼&lt;/del&gt;新的思路，就会觉得以前见过的东西都太弱了！&lt;/p&gt;
&lt;p&gt;新项目想用什么就用什么，什么技术栈健全就用什么。可是老项目并没办法想干什么干什么，时间和精力不允许他去重构。金蝶还在卖VB呢，他们肯定也想过VB已经不行了。&lt;/p&gt;
&lt;p&gt;好了题外话，我还是很有兴趣实现一个塞进&lt;code&gt;nlvi&lt;/code&gt;的类jq的。&lt;/p&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序的骚思路</title>
    <link href="https://colmugx.github.io/blog/2017/12/20/exchange_number/"/>
    <id>https://colmugx.github.io/blog/2017/12/20/exchange_number/</id>
    <published>2017-12-20T06:46:41.000Z</published>
    <updated>2017-12-22T02:59:02.058Z</updated>
    
    <content type="html"><![CDATA[<p>想起以前很容易就会被问到一个问题</p><blockquote><p>如何把两个数值进行交换？</p></blockquote><p>教科书式的编程怎么做？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> k = i;</div><div class="line"></div><div class="line">i = j;</div><div class="line">j = k;</div><div class="line"></div><div class="line"><span class="comment">// 两个数值，把其中一个寄存起来，然后再两次赋值。</span></div></pre></td></tr></table></figure><p>以前去写代码的社团，当时我巨活跃，有个师兄就过来说：看你资质不错，我打算亲自培养你，先问你一个问题吧：你如何把两个数值进行交换？写不出代码没关系，我只是要听思路。</p><p>我：什么跟什么交换？</p><p>师兄：随便你。</p><p>于是我打开了<code>sublime text</code>写下这么些东西</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> j = <span class="number">2</span>;</div><div class="line"></div><div class="line">i += j;</div><div class="line">j = i - j;</div><div class="line">i -= j;</div></pre></td></tr></table></figure><p>然后师兄就懵了，你这个B不按套路出牌？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想起以前很容易就会被问到一个问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何把两个数值进行交换？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;教科书式的编程怎么做？&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="曲苑杂坛" scheme="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>使用JSX的VUE应用开发体验</title>
    <link href="https://colmugx.github.io/blog/2017/12/11/vue-jsx/"/>
    <id>https://colmugx.github.io/blog/2017/12/11/vue-jsx/</id>
    <published>2017-12-11T14:34:10.000Z</published>
    <updated>2017-12-13T02:16:42.951Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我说我是做外包的肯定没人信，给你看看外包程序员瞎几把搞的热情！</p></blockquote><p>前排提醒：vue-jsx和react-jsx相差甚远，前者基本就是玩具生产链。很多想利用JS语言特性的骚套路基本上都不好实现，而且感觉奇奇怪怪的。所以你的生产环境，千万不要乱试vue-jsx这种搭配，够简单就无所谓了…</p><a id="more"></a><h2 id="开局搭环境"><a href="#开局搭环境" class="headerlink" title="开局搭环境"></a>开局搭环境</h2><p>要什么环境，<code>vue-cli</code>就行了，又不是什么大项目大团队需要约定<code>webpack</code>。</p><h2 id="装插件"><a href="#装插件" class="headerlink" title="装插件"></a>装插件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">npm install\</div><div class="line">  babel-plugin-syntax-jsx\</div><div class="line">  babel-plugin-transform-vue-jsx\</div><div class="line">  babel-helper-vue-jsx-merge-props\</div><div class="line">  babel-preset-env\</div><div class="line">  --save-dev</div></pre></td></tr></table></figure><p><code>.babelrc</code>主要是这个</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"plugins"</span>: [<span class="string">"transform-vue-jsx"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为其他的东西基本上都会有，主要是要添加这个东西。至此。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>没错的这文章本来是属于实践的又不是教程。还是要讲一下自己的体验的。</p><h3 id="渲染元素"><a href="#渲染元素" class="headerlink" title="渲染元素"></a>渲染元素</h3><p>感想最大的就是这个，Vue在使用jsx的时候很迷，最明显的感觉怪怪的地方有两个：</p><ol><li>它并不是哪个位置的方法都会有createElement函数的。</li><li>classes形式的组件找不到render函数！</li></ol><p>其实关于vue与jsx，tsx我是做了很多次尝试</p><p>首先第一种，常规的就是一个<code>object</code>对象，然后通过<code>Vue.component()</code>方法构建。这种可以说是我现在看来最没坑的一种形式了。平常的话还是像<code>*.vue</code>里的<code>script</code>标签一样，直接<code>export</code>打头开写，<code>&lt;template /&gt;</code>渲染部分移入了<code>render()</code>函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  render(<span class="comment">/* h / createElement */</span>) &#123;</div><div class="line">    <span class="keyword">return</span> &lt;h1&gt; Hello World &lt;/h1&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种情况的结构与单文件的代码结构是相差无几的，不过换了种渲染方式而已，而且<code>render()</code>函数可以做一些与渲染相关的子方法，比如条件渲染之类的。所以总的来说：</p><p>优点：</p><ol><li>顺手，完全单文件中的<code>script</code>标签</li><li>没了</li></ol><p>缺点：</p><ol><li>这么搞肯定容易眼花啊！</li><li>不好维护，不直观</li></ol><p>第二种，如果是这种结构的tsx的话，与jsx同理。</p><p>第三种，class形式的组件，需要<code>vue-class-component</code>插件。然后可以写出类似于这样的东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">    &lt;h1&gt;Hello World&lt;/h1&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">  @Component</div><div class="line">  export default class MainClass extends Vue &#123;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>乍一看你还以为这是<code>Angular</code>呢！Vue在这方面真的是取长补短的典范。对这种的话，就比传统的方式要好多了，首先全局变量或者<code>data()</code>函数返回值变得特别清晰；再者是原来<code>methods</code>存放的函数可以以<code>class</code>形式的函数来写，那<code>computeds</code>怎么办？直接用<code>get/set</code>关键词，太方便了有没有！</p><p>好了关键的来了…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</div><div class="line">  </div><div class="line">  get render() &#123;</div><div class="line">    <span class="keyword">return</span> &lt;h1&gt; Hello World &lt;/h1&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// render or template not defind.</span></div></pre></td></tr></table></figure><p>这是什么鬼，可能是我操作不当，但是不加<code>get</code>的话不会注入createElement，但是这又是个<code>render()</code>函数，本来不需要加什么前缀的。但是不加有感觉会不会把<code>render()</code>函数识别成是传统写法中存在于<code>methods</code>的函数。</p><p>官方在自动注入这方面有一个栗子的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'jsx-example'</span>, &#123;</div><div class="line">  render () &#123; <span class="comment">// h will be injected</span></div><div class="line">    <span class="keyword">return</span> &lt;div id="foo"&gt;bar&lt;/div&gt;</div><div class="line">  &#125;,</div><div class="line">  myMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// h will not be injected</span></div><div class="line">    <span class="keyword">return</span> &lt;div id="foo"&gt;bar&lt;/div&gt;</div><div class="line">  &#125;,</div><div class="line">  someOtherMethod: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// h will not be injected</span></div><div class="line">    <span class="keyword">return</span> &lt;div id="foo"&gt;bar&lt;/div&gt;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">@Component</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</div><div class="line">  get computed () &#123; <span class="comment">// h will be injected</span></div><div class="line">    <span class="keyword">return</span> &lt;div id="foo"&gt;bar&lt;/div&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中<code>h</code>就是<code>createElement</code>的别称，而且在jsx的话一般都是不用写的。所以这个函数注入的就有点迷了，不过根据亲测，在<code>methods</code>定义的函数是有<code>h</code>的，可能最后也会在<code>render</code>函数里调用吧。</p><p>后来我尝试两三个星期之后，我就放弃了classes形式的jsx写法，等过几天又有经历的时候再继续尝试。目前自己在用的两套写法：例如<code>Hyper</code>那种的classes形式的vue+ts，传统方式的jsx。</p><p>还有就是，对于vue来说，有时候要时常关心<code>h</code>函数有没有被注入，这是一件挺不愉快的事情的。比如说你写了一个渲染函数，然后运行的时候发现惨了凉了函数刚好在渲染范围之外（比如把函数直接分离出去，并不存在于<code>render</code>函数中），这是不运行的，那怎么做？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">h, args</span>) </span>&#123;&#125;</div></pre></td></tr></table></figure><p>就是这样的！必须在render函数中调用而且<code>h</code>必须是第一个参数！不然不是报错就是不渲染！</p><h3 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h3><p>可能是解决刚刚提到的“经常找不到自动注入函数”的困扰吧。多了一个这么个东西。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  functional: <span class="literal">true</span>,</div><div class="line">  </div><div class="line">  render() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一个关键词<code>functional</code>声明这个位置是个函数式组件。函数式可以直接看做一个能主动注入<code>h</code>的函数，因为它没有状态的，甚至是个RBQ，用完就丢（死无全尸，在组件树是看不到的，依托父组件生存）。同时最大的特点也就是可复用。想想<code>react</code>一个正常语法函数就能搞定的事情…</p><p>有利有弊，这种组件因为没状态，用过就丢，所以它需要的数据全靠传递。也就是单向数据，从父组件 -&gt; props -&gt; 处理 -&gt; 输出 -&gt; 销毁一条龙。很简单就是把它看做是<code>render</code>里面的一个函数就行，本意也是如此。</p><p>所以这种组件就两个接收参数：负责渲染的<code>h</code>，负责上下文<code>context</code>。各种所需的乱七八糟都在<code>context</code>中，比如全程最重要的<code>props</code>。而且多数组件的参数都有调整：</p><blockquote><ul><li><code>props</code>：提供 props 的对象</li><li><code>children</code>: VNode 子节点的数组</li><li><code>slots</code>: slots 对象</li><li><code>data</code>：传递给组件的 data 对象</li><li><code>parent</code>：对父组件的引用</li><li><code>listeners</code>: (2.3.0+) 一个包含了组件上所注册的 <code>v-on</code> 侦听器的对象。这只是一个指向 <code>data.on</code> 的别名。</li><li><code>injections</code>: (2.3.0+) 如果使用了 <a href="https://cn.vuejs.org/v2/api/#provide-inject" target="_blank" rel="external"><code>inject</code></a> 选项，则该对象包含了应当被注入的属性。</li></ul></blockquote><h3 id="JSX的一些小区别"><a href="#JSX的一些小区别" class="headerlink" title="JSX的一些小区别"></a>JSX的一些小区别</h3><p>因为我还没怎么体验过<code>react</code>，所以就只有一个关于dom书写的区别。在<code>react-jsx</code>中，<code>class</code>可是会被识别成关键词的，所以做样式的<code>class</code>要写成<code>className</code>，但在<code>vue-jsx</code>是不需要的。可能一开始这么做没想过后面竟然还有<code>class-component</code>的需求吧。</p><p><code>vue</code>现在大多奇技淫巧都是基于社区的各种<code>babel</code>插件，并不像<code>react</code>两个官方库皇帝级别支持，也不像<code>angular</code>自从诞生时期就声明“劳资要用TypeScript作为开发语言，你不用也得用ES6形式！”</p><p><code>vue-jsx</code>这种写法我现在也会用，搞点小的就直接这么写，而且这么做实际上思路会清晰一点——像在写一个应用而不是写一个网页，你只需要把dom相关的字段脑里想成一个字符串或者一个子函数就行了。（只是老遇到一些乱七八糟的问题）</p><p>（<code>angular</code>与<code>angular.js</code>至今还是两种东西，不要乱了）</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我说我是做外包的肯定没人信，给你看看外包程序员瞎几把搞的热情！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前排提醒：vue-jsx和react-jsx相差甚远，前者基本就是玩具生产链。很多想利用JS语言特性的骚套路基本上都不好实现，而且感觉奇奇怪怪的。所以你的生产环境，千万不要乱试vue-jsx这种搭配，够简单就无所谓了…&lt;/p&gt;
    
    </summary>
    
      <category term="实践尝试" scheme="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
      <category term="vue" scheme="https://colmugx.github.io/blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>扯扯柯里化</title>
    <link href="https://colmugx.github.io/blog/2017/12/07/about-currying/"/>
    <id>https://colmugx.github.io/blog/2017/12/07/about-currying/</id>
    <published>2017-12-07T13:17:31.000Z</published>
    <updated>2017-12-29T06:39:53.874Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在我的博客打开开发者工具 -&gt; console，输入 Nlvi.tools.scroll 试试？</p></blockquote><p>开个玩笑，我自己也不知道这算不算柯里化（逃</p><p>总之为什么这么写，我自己觉得这样容易理解，方便盲僧（理清）。</p><p>还有最近关于“如何治理别人爱装逼的毛病”系列中刚写的一坨，新鲜的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> menuItem = <span class="function">(<span class="params">list</span>) =&gt;</span> </div><div class="line">      list.map(<span class="function">(<span class="params">&#123;title, color, icon, descs&#125;</span>) =&gt;</span> </div><div class="line">        &lt;menu-item title=&#123;title&#125; color=&#123;color&#125; icon=&#123;icon&#125;&gt;&#123;</div><div class="line">          descs.map(<span class="function"><span class="params">v</span> =&gt;</span> &lt;span&gt;&#123;v&#125;&lt;<span class="regexp">/span&gt;)&#125;&lt;/m</span>enu-item&gt;)</div></pre></td></tr></table></figure><a id="more"></a><h2 id="柯里化是什么？"><a href="#柯里化是什么？" class="headerlink" title="柯里化是什么？"></a>柯里化是什么？</h2><p>好了讲柯里化，就是<strong>接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。柯里化属于函数式编程的内容</strong>。</p><p>在这里有一个<a href="http://www.zhangxinxu.com/wordpress/2013/02/js-currying/" target="_blank" rel="external">张鑫旭博客</a>讲关于柯里化（柯南嗑药）的例子，很方便理解。当然我想讲点自己的东西，拿<code>Nlvi.tools.scroll</code>说一下吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">tools.scroll = <span class="function"><span class="keyword">function</span> (<span class="params">win</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">    $(win).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> sct = $(win).scrollTop();</div><div class="line">      fn &amp;&amp; fn(sct);</div><div class="line">    &#125;);</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 实际上如果不作的话，这样就结束了</span></div><div class="line">tools.scroll = <span class="function"><span class="keyword">function</span>(<span class="params">win, fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> $(win).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sct = $(win).scrollTop();</div><div class="line">    fn&amp;&amp;fn(sct)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>所以函数柯里化看上去有一个特点，会嵌套函数。而且道理就跟柯里化的解释一样：用一些参数，剩下的函数作为返回值里的函数的参数。这样我在调用的时候怎么调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scrollTop = Nlvi.tools.scroll(<span class="built_in">window</span>);</div><div class="line">scrollTop(<span class="function"><span class="keyword">function</span>(<span class="params">sct</span>) </span>&#123;&#125;);</div></pre></td></tr></table></figure><p>首先我给个变量（实际上ES6直接用<code>const</code>，毕竟固定量）引用这个方法，方法传入第一个参数。接着里面的函数返回值函数是接收一个函数变量。</p><p>理一下，函数 - 的返回值 - 是个函数，这个函数接收一个 - 函数 - 的 - 变量。</p><p>然后这个函数参数传进去之后，实际上就是传一个方法进去以便于我等下里面的逻辑走完之后可以把这个函数参数运行起来，行程一个特别做作的回调函数。（当然回调函数带的是当前滚动条的数据）</p><p>为什么这么做呢？一点就是我觉得这样思路就清晰多了，而且在调用区域写起来干净。第二点就是参数复用。</p><p>虽然这个例子看不出什么，但是难免会遇到一些情况，就是明明一个变量或者一个参数，我只要取一次然后调用一次之后，剩下的内容我只要在这个情况之上去处理就行。但是如果传统单函数的做法的话，就会使得这个局外参数也跟着在里面做一些乱七八糟的运动，比如跟着去递归，被扯着去多次判断，这样就会莫名其妙浪费了一堆性能。很简单我举个例子：4x100，明明你交接之后剩下的就接下来的人跑就行了，你非得交接之后跟着跑，边跑边喊加油？</p><p>第三点就是延时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> total = <span class="number">0</span></div><div class="line"><span class="comment">// normal</span></div><div class="line"><span class="keyword">var</span> nSum = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</div><div class="line">  total += num</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//currying</span></div><div class="line"><span class="keyword">var</span> cSum = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">var</span> nums = []</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</div><div class="line">      <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, nums)</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">Array</span>.prototype.push.apply(nums, <span class="built_in">arguments</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sum = cSum(<span class="function">(<span class="params">x</span>) =&gt;</span> total += x)</div></pre></td></tr></table></figure><p>如果是常规的话，那么肯定会立刻计算出结果，而柯里化之后，会把计算的步骤储存起来，然后一起计算。</p><h2 id="柯里化误区"><a href="#柯里化误区" class="headerlink" title="柯里化误区"></a>柯里化误区</h2><p>在写这篇东西的时候，我关注到了一尊大神的博客 <a href="http://www.cnblogs.com/pengchen/p/5434705.html" target="_blank" rel="external">JavaScript函数柯里化的一些思考</a>，吓得我赶紧回看了自己的函数有没有“画蛇添足”的成分。嗯。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 拿下来继续学习一下</span></div><div class="line"><span class="keyword">var</span> scrollTop = Nlvi.tools.scroll(<span class="built_in">window</span>);</div><div class="line">scrollTop(<span class="function"><span class="keyword">function</span>(<span class="params">sct</span>) </span>&#123;&#125;);</div></pre></td></tr></table></figure><p>这里我想到的是，我只需要把<code>window</code>传到这个函数之后引用出一个新函数，然后我就可以带着这个函数跑了，如果是不嫌麻烦版本的话我需要则么做？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">tools.scroll = <span class="function"><span class="keyword">function</span>(<span class="params">win, fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> $(win).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sct = $(win).scrollTop();</div><div class="line">    fn&amp;&amp;fn(sct)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">// and so</span></div><div class="line">tools.scroll(<span class="built_in">window</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)</div></pre></td></tr></table></figure><p>这样就会造成，我每次想监听滚动的时候，每用一次这个方法，我就要把<code>window</code>传进去一次。如果包一下的话，我就可以拿后面那个函数走就行了，也就是我的<code>window</code>只要传一次就畅通无阻。这也是另一个好处：分段计算。好比我玩Switch，我在外面突然想玩马车的时候，如果我的卡带在卡包里，那我换上就可以玩了，就不需要等回到家把卡带从包装盒里拿出来装到机器上。</p><p>实际上到这里的话应该有所经验了，到这里还会不会觉得<code>apply(), call(), bind()</code>使用机会少之又少？这就是数学的魅力吧，可是我数学不好。</p><h2 id="柯里化-lt-gt-闭包函数？"><a href="#柯里化-lt-gt-闭包函数？" class="headerlink" title="柯里化 &lt; - &gt; 闭包函数？"></a>柯里化 &lt; - &gt; 闭包函数？</h2><p>又是每期一问了，柯里化跟闭包函数是否也有关系？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 经典面试题</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</div><div class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</div><div class="line">             setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">              <span class="built_in">console</span>.log(i);</div><div class="line">        &#125;,<span class="number">0</span>)</div><div class="line">    &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>那么，柯里化函数和闭包函数应该怎么区分？还是的确有联系？</p><p>最后感谢所有被引用的文章及其作者，感谢帮助学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在我的博客打开开发者工具 -&amp;gt; console，输入 Nlvi.tools.scroll 试试？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开个玩笑，我自己也不知道这算不算柯里化（逃&lt;/p&gt;
&lt;p&gt;总之为什么这么写，我自己觉得这样容易理解，方便盲僧（理清）。&lt;/p&gt;
&lt;p&gt;还有最近关于“如何治理别人爱装逼的毛病”系列中刚写的一坨，新鲜的：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; menuItem = &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;list&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      list.map(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;&amp;#123;title, color, icon, descs&amp;#125;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;lt;menu-item title=&amp;#123;title&amp;#125; color=&amp;#123;color&amp;#125; icon=&amp;#123;icon&amp;#125;&amp;gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          descs.map(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;v&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;lt;span&amp;gt;&amp;#123;v&amp;#125;&amp;lt;&lt;span class=&quot;regexp&quot;&gt;/span&amp;gt;)&amp;#125;&amp;lt;/m&lt;/span&gt;enu-item&amp;gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>你还在用Console.log()？</title>
    <link href="https://colmugx.github.io/blog/2017/11/20/js-console/"/>
    <id>https://colmugx.github.io/blog/2017/11/20/js-console/</id>
    <published>2017-11-20T10:06:13.000Z</published>
    <updated>2017-11-20T15:09:56.543Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>也许主题应该改为：你只会使用Console.log()？</p></blockquote><p>现在的前端虽说是越来越复杂，但是我怎么觉得现在前端的要求越来越低了？应该说现在的人，看个几遍vue，知道console.log()，知道var, {}, []，就敢出来找工作了。但是<code>console</code>就这么个方法？</p><p>搞笑，你在你的浏览器输入<code>console</code>，自己看看有多少东西！所以为了高效调试我觉得有必要全了解一遍。<br><a id="more"></a></p><h2 id="log-info-error-warn"><a href="#log-info-error-warn" class="headerlink" title="log(), info(), error(), warn()"></a>log(), info(), error(), warn()</h2><p>这几个放在一起讲</p><blockquote><p>log() 普通输出</p></blockquote><p>这是最普通，最常见，最没什么东西好讲的。输出的样式是普通样式。</p><blockquote><p>info() 提醒输出</p></blockquote><p>这是一个早期chrome才能看到的效果，现在的FireFox也能看到，是一个圆形中间一个叹号的标记。作提醒作用。chrome不是不会显示，是显示成普通样式。</p><blockquote><p>error() 错误输出</p></blockquote><p>这个应该跟<code>log()</code>同个使用数量级的，表示错误，大红颜色。chrome表现是一整行都是红色的，很显眼。用来显示错误信息。比如throw 错误之类的。如果一套都是<code>log()</code>的话肯定很难一眼看到错误。珍爱视力，路还长着…</p><blockquote><p>warn() 警告输出</p></blockquote><p>就是警告咯，可能用的比较少，但是工具类和一些库肯定会容易看到，原来跟<code>info()</code>平起平坐，现在应该是替代了。显示效果会显眼的黄色，chrome会有黄色背景。</p><blockquote><p>debug() 调试输出</p></blockquote><p>这个就是<code>log()</code>，用来输出调试信息的。不过现在的调试信息都在花式<code>log()</code>，也不需要用到这个了。</p><h2 id="exception-debug"><a href="#exception-debug" class="headerlink" title="_exception(), debug()"></a>_exception(), debug()</h2><p>这组只有两个，因为这两个没卵用…为什么…</p><blockquote><p>_exception() 例外输出</p></blockquote><p>说白了就是用来输出错误的，那错误不能用<code>error()</code>吗？！</p><blockquote><p>debug() 调试输出</p></blockquote><p>早期可能还有区别，但是这就是一个<code>log()</code>，不过现在各前端都在花式<code>log()</code>调试信息，可能也有些人<code>debug()</code>都没听说过。</p><h2 id="assert-…-clear-count"><a href="#assert-…-clear-count" class="headerlink" title="assert(…), clear(), count()"></a>assert(…), clear(), count()</h2><p>为什么第一个函数搞了三个点？</p><blockquote><p>assert() 断言输出：判断第一个参数是否为真，false的话抛出异常并且在控制台输出相应信息。——MDN</p></blockquote><p>从这里开始就要骚了，这是一个判断的方法，里面需要填写参数，然后得到返回值。如果值为真，就什么都不会发生，反之则以<code>error()</code>通知你。这是个多参数的，除了第一个参数之外，后面接的参数是被输出的对象也好，字符串也好，并且会拼接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.assert(<span class="number">1</span>&gt;<span class="number">2</span>, <span class="string">"你这么骚的？"</span>)</div><div class="line"></div><div class="line">Assertion failed: 你这么骚的？ <span class="comment">// 假装这里是红字红色背景</span></div></pre></td></tr></table></figure><blockquote><p>clear() 清空控制台</p></blockquote><p>就是把控制台全清空，terminal里面的<code>clear</code></p><blockquote><p>count() 次数输出：以参数为标识记录调用的次数，调用时在控制台打印标识以及调用次数。——MDN</p></blockquote><p>并且MDN明确指出，这个不应该列入正常使用范围，因为这是非标准方法。这是这组里最骚的方法。用来输出本身被调用了几次…虽然如果测试循环的话，一般都直接log(i)的，直接看1234567不是更明确嘛。显示效果就是，每运行一次就会在控制台打印 n + 1。</p><h2 id="dir-dirxml"><a href="#dir-dirxml" class="headerlink" title="dir(), dirxml()"></a>dir(), dirxml()</h2><p>这两个一起说是因为，有相同点和不同点。</p><blockquote><p>dir() 对象结构输出</p><p>dirxml() 节点结构输出</p></blockquote><p>这两个都是输出一个树状结构，就是前面有个小三角。但不同点就是，<code>dir()</code>是把一个对象按照对象的形式呈现，当然用来输出节点就是把节点信息按object呈现。<code>dirxml()</code>是把节点呈现出来，就还是保留xml的样式呈现。都是非标准，偶尔用用还行？</p><h2 id="group-groupCollapsed-groupEnd"><a href="#group-groupCollapsed-groupEnd" class="headerlink" title="group(), groupCollapsed(), groupEnd()"></a>group(), groupCollapsed(), groupEnd()</h2><p>这是上面那组的正房版。都是打印结构。我就不一行一行解释了有点累…</p><p>第二跟第一都是打印树状结构，但是第一个会自动打开显示结构里面有什么结构（没问题的），第二个叫内联树状，默认不打开。</p><p>而且只要你不结束，你可以一直联下去的，这样一个父节点可以一直续下去…直到通过<code>groupend()</code>来结束。</p><h2 id="table-…"><a href="#table-…" class="headerlink" title="table(…)"></a>table(…)</h2><p>我必须强调！<strong>这是最棒的我最喜欢的console方法，没有之一！</strong></p><blockquote><p>table() 表格输出</p></blockquote><p>这个方法必须传入内容，内容的类型是array或者object，输出的样式是一个key:value的表格！如果你觉得输出成对象不方便检查的话，那就用<code>table()</code>吧！（当然在表格下方还是会return一次对象或者数组）</p><p>而且不仅是key:value，<strong>你甚至还能多元数组！对象套对象！甚至是JSON！</strong></p><h2 id="另外的技巧就是可以用占位符了"><a href="#另外的技巧就是可以用占位符了" class="headerlink" title="另外的技巧就是可以用占位符了"></a>另外的技巧就是可以用占位符了</h2><p>跟C语言的<code>printf()</code>没有区别，就是可以利用占位符然后再把参数接在后面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"%d年%d月%d日"</span>,<span class="number">2017</span>,<span class="number">11</span>,<span class="number">20</span>)</div></pre></td></tr></table></figure><p>最后感谢MDN，也感谢AlphaGo！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;也许主题应该改为：你只会使用Console.log()？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在的前端虽说是越来越复杂，但是我怎么觉得现在前端的要求越来越低了？应该说现在的人，看个几遍vue，知道console.log()，知道var, {}, []，就敢出来找工作了。但是&lt;code&gt;console&lt;/code&gt;就这么个方法？&lt;/p&gt;
&lt;p&gt;搞笑，你在你的浏览器输入&lt;code&gt;console&lt;/code&gt;，自己看看有多少东西！所以为了高效调试我觉得有必要全了解一遍。&lt;br&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>引用等于指针吗？</title>
    <link href="https://colmugx.github.io/blog/2017/10/17/reference-equal-pointer/"/>
    <id>https://colmugx.github.io/blog/2017/10/17/reference-equal-pointer/</id>
    <published>2017-10-17T07:33:38.000Z</published>
    <updated>2017-10-17T14:22:18.853Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一篇思考文，关于JS的reference和Go的指针。（臆想型论文？）</p></blockquote><p>最近投入大量时间接触<code>Golang</code>，了解“指针”的时候，想起了以前学习C语言时对“指针”的疑问：指针是什么。</p><p>以前还小不理解指针和野指针，只知道野指针会出现内存溢出或者值不正确的情况。而且网上大多讲指针的文章看起来都很难。就像现在的知乎：一句话能说清楚的东西恨不得从它的诞生还是写起。就连LOL赛评也是这副P样。</p><p>以至于我后面对C语言没好感，对C++厌恶，对有“指针”的语言直接没兴趣。</p><p>在看到Go的指针的时候，我已经想放弃了。但是想回来，毕竟上一次接触指针已经6年了，也许现在看就能理解出什么呢。（过程中接触的OC根本不能算经验，因为当时完全就是靠抄靠背来写iOS应用，最后还是嫌弃OC麻烦进阶无法理解去学习了swift）<br><a id="more"></a></p><h2 id="Reference-Pointer"><a href="#Reference-Pointer" class="headerlink" title="Reference == Pointer?"></a>Reference == Pointer?</h2><p>以前看到什么内存地址啊，指向啊就已经乱了，满脑子都在想内存里面是什么样的，内存地址，寄存器又是什么东西。跟着官方教程走了一遍，了解到<strong>指针就是通过一个变量去指向一个有的变量或者说是对象，从而产生一种绑定。通过修改指针变量也可以达到修改本体的效果</strong>。</p><p>这让我想到JS，因为每天都在操作对象，知道：如果你要建立一个新的变量，比如<code>a = 1</code>，我可以通过<code>var b = a</code>得到一个新的变量。但是如果是对象则不是。如果是<code>a = {};  var b = a</code>的话，b只是单纯指向了a，并没有复制a</p><p>所以我立刻去搜索<em>关于JavaScript的指针</em>。得到这么一个结果 <a href="https://www.baidu.com/link?url=2Xxo3-ptdvabLARr0p-DcoBbeysd2lvRxH-jEevvWHBJ7pNBk-mkxGqaB6h8UTWVRi-2lc56zjWVMYPUgv6tfK&amp;wd=&amp;eqid=e1820c9600002f360000000659e5b92d" target="_blank" rel="external">JavaScript 的<em>指针</em>是什么? - 知乎</a></p><blockquote><p>JavaScript 里头什么时候有指针的概念？倒是有 reference （引用）的说法。 —— <a href="https://www.zhihu.com/people/sansmana" target="_blank" rel="external">陈木野</a></p></blockquote><p>关于this的总结，不单我自己，网络上已经大量的文章了。不管是详细解析，还是总结，都已经很多了。但是如果说：指针就是一种指向变量的话，那JavaScript就很多了，遍地都是。而这样的话，就跟reference有关系了。</p><p>说起来也是邪门了，今天打算把《红宝书》拿出来翻一下，翻到了第四章4.1.2，看到了这么一句</p><blockquote><p>当使用 num1 的值来初始化 num2 时，num2 中也保存了值 5。但 num2<br>中的 5 与 num1 中的 5 是完全独立的，该值只是 num1 中 5 的一个副本。</p><p>当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到<br>为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一<br>个对象。复制操作结束后，两个变量实际上将引用同一个对象。</p></blockquote><p>于是我的想法 “引用是一种指针” 或许成立。（复习有好处的！）</p><h2 id="Point-Reference"><a href="#Point-Reference" class="headerlink" title="Point == Reference"></a>Point == Reference</h2><p>如果反过来，还能成立吗？我觉得不行。</p><p>C++，让我很崇拜很信仰的，却因不理解和学不会让我产生厌恶的语言，在这方面是两者皆有。由于根本不懂所以不参加讨论。</p><p>Java，他也有reference，但是在<a href="https://www.baidu.com/link?url=bI4EsfOKw8lfPjTwX3_gY7pbn2LFMOwmFPmoalBBNr7lFCv9ZltHfuravfoA7uVHrNJtSUxm0Epjk-IW5Zr2z_&amp;wd=&amp;eqid=ee91ddc5000508bd0000000659e60253" target="_blank" rel="external">Java的<em>Reference</em>感觉很象C++的<em>指针</em>,但是区别是本质的 - f…_博客园</a> 提到：</p><blockquote><p>Java中你无法对这个地址进行任何数学运算，并且这个地址你不知道，是Java Runtime分配给你的，它随时还要调整这个地址（After GC,Memory要Compact，这时候一个Object Reference的地址就会改变）。</p></blockquote><p>我不是很理解，所以我也不敢评论什么。我只想关于Go和JS的东西。</p><p>也许是心理隔阂，也许是真理。我怎么都想不出怎么让“指针是一种引用”成立。</p><p>老是想内存内存，不如想成一个盒子，指针就是给盒子里的东西连了一条线。这样做就不用我找这个东西的时候去盒子里找，而是直接去找这条线？</p><p>可是在JS中，引用也不能修改和做任何运算吗？</p><h2 id="Reference-Pointer-1"><a href="#Reference-Pointer-1" class="headerlink" title="Reference === Pointer?"></a>Reference === Pointer?</h2><p>我不是语言专家，我一点都不敢保证。或者说我不懂。</p><p>我不知道所谓的指针是什么东西，但是我知道<code>reference</code>是一个<code>object</code>，毕竟不知道哪篇文章写道：函数是JavaScript第一公民。但并不是很纯的函数式编程语言。</p><p>其实思考到现在，我又有新的问题了：<strong>前端语言，或者说函数式编程语言，有没有内存，指针一说？</strong></p><p>不过现在可以知道的是：</p><p>​    在指令式编程中，数值就是数值，一切工作之后无非就是想得到一个值，过程中也在围绕着值。</p><p>​    在函数式编程中，函数还是占主要地位，它需要以数学的方式去解决编程的问题。</p><p>那我现在可不可以有一种新的理解：</p><p>​    比如C语言这种，他定义指针是需要 <code>*</code> 这种东西，也就是<code>int *a = b</code>是用a指针指向b，我可以通过a来修改b。但是如果直接<code>int a = b</code>的话，我就相当于复制了这个变量了，没权修改b变量了。而如果<code>int a</code>是一个函数的话，那它最后也需要返回一个<code>int</code>返回值。所以它并没有“用函数搞事”的权利。</p><p>​    而JS语言这种，我想用一个代码框来写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 还是根据红宝书的例子</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b = a;<span class="comment">// 一种复制，相互独立</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> x = &#123;<span class="attr">a</span>: <span class="number">5</span>&#125;</div><div class="line"><span class="keyword">var</span> y = x<span class="comment">// 一种引用，实际上操作y的时候还是在操作x</span></div><div class="line"></div><div class="line"><span class="comment">//现在暂时借用一下以 _ 代替*</span></div><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">5</span> &#125;</div><div class="line"><span class="keyword">var</span> _b = o.a<span class="comment">// 达到继承的目的？</span></div><div class="line"></div><div class="line"><span class="comment">// var _b = int *b   在某种意义上？</span></div></pre></td></tr></table></figure><p>在红宝书接下来有一句：</p><blockquote><p>换句话说，obj1和 obj2 都指向同一个对象。这样，当为 obj1 添加 name 属性后，可以通过 obj2 来访问这个属性，<br>因为这两个变量引用的都是同一个对象。</p></blockquote><p>按我的角度翻译一下，就是：<strong>我定义一个b出来，无非就是给a多了一个出口</strong></p><p>所以综上所述，我认为，对我来说，或者对C系除外的语言来说，<strong>把“指针”说成“指向”，或许让人更好理解。</strong></p><p>哼，计算机真是有趣。</p><p>（最后感谢所有被引用的文章和作者，谢谢。）</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一篇思考文，关于JS的reference和Go的指针。（臆想型论文？）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近投入大量时间接触&lt;code&gt;Golang&lt;/code&gt;，了解“指针”的时候，想起了以前学习C语言时对“指针”的疑问：指针是什么。&lt;/p&gt;
&lt;p&gt;以前还小不理解指针和野指针，只知道野指针会出现内存溢出或者值不正确的情况。而且网上大多讲指针的文章看起来都很难。就像现在的知乎：一句话能说清楚的东西恨不得从它的诞生还是写起。就连LOL赛评也是这副P样。&lt;/p&gt;
&lt;p&gt;以至于我后面对C语言没好感，对C++厌恶，对有“指针”的语言直接没兴趣。&lt;/p&gt;
&lt;p&gt;在看到Go的指针的时候，我已经想放弃了。但是想回来，毕竟上一次接触指针已经6年了，也许现在看就能理解出什么呢。（过程中接触的OC根本不能算经验，因为当时完全就是靠抄靠背来写iOS应用，最后还是嫌弃OC麻烦进阶无法理解去学习了swift）&lt;br&gt;
    
    </summary>
    
      <category term="编程议论" scheme="https://colmugx.github.io/blog/categories/%E7%BC%96%E7%A8%8B%E8%AE%AE%E8%AE%BA/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>总有一天我会死在骚操作上…</title>
    <link href="https://colmugx.github.io/blog/2017/10/09/diary-vue-jsx/"/>
    <id>https://colmugx.github.io/blog/2017/10/09/diary-vue-jsx/</id>
    <published>2017-10-09T07:22:07.000Z</published>
    <updated>2017-10-09T07:37:57.498Z</updated>
    
    <content type="html"><![CDATA[<p>得考虑去弄个图床，滥用github不太好。</p><p><img src="https://github.com/ColMugX/GitBed/raw/master/diary/vue-render1.png" alt=""></p><p><img src="https://github.com/ColMugX/GitBed/raw/master/diary/vue-render2.png" alt=""></p><p><img src="https://github.com/ColMugX/GitBed/raw/master/diary/vue-render3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;得考虑去弄个图床，滥用github不太好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/ColMugX/GitBed/raw/master/diary/vue-render1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https
      
    
    </summary>
    
      <category term="毫无意义" scheme="https://colmugx.github.io/blog/categories/%E6%AF%AB%E6%97%A0%E6%84%8F%E4%B9%89/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
      <category term="vue" scheme="https://colmugx.github.io/blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>使用桌面应用写hexo博客是什么体验？</title>
    <link href="https://colmugx.github.io/blog/2017/09/19/what-the-feeling-about-hyper/"/>
    <id>https://colmugx.github.io/blog/2017/09/19/what-the-feeling-about-hyper/</id>
    <published>2017-09-19T05:02:01.000Z</published>
    <updated>2017-11-20T10:08:01.059Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>稳的稳的，这次真是为了需求造轮子了。Hyper = Hexo + Typer. </p></blockquote><p>接触到hexo是因为，hexo可以是一个前端博客生成器，直接生成一个前端静态页面，做到可以上传到github“个人页面”作为博客网站。</p><p>不过，毕竟是基于<code>node</code>的生成器，编写过程很geek。首先创建和预览甚至发布，依赖<code>terminal</code>和<code>node</code>。你要使用一个你喜欢的<code>markdown</code>编辑器，或者直接就在代码编辑器搞例如<code>vscode</code>。原来我也是用这个写博客。因为自带了<code>terminal</code>，直接创建了搞完直接上。后来生活逐渐好点，用的 iterm2 + zsh 之后，编辑器改用了<code>Typora</code>。然而关于这段的话，我上一篇<a href="http://blog.co1mugx.tk/2017/08/22/do-markdown-hexo/" target="_blank" rel="external">搞electron+vue+webpack2+TypeScript什么体验</a> 已经讲得够多了，所以不赘述了。</p><p>但是现在，可能生活会更好了…</p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/1.png" alt=""></p><a id="more"></a><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><p>这是个<code>electron</code> + <code>Typescript</code> + <code>vue</code>的产物。也就是首先它是桌面应用了，由于<code>electron</code>意味着它可能可以跨平台。不过我没有想过…所以现在是 MacOS 版本。</p><p>为什么想起写这个，原因就两点</p><ul><li>原来的方式太过于繁琐，甚至感觉不到自己是在写博客。</li><li>对计算机理解和操作都不是顺畅的人会带来很多麻烦。</li></ul><p>博客博客，文字记录自己的生活或者技术探讨。多少写手或者说喜欢分享的人，喜欢hexo又不会用没办法用。当分享被技术限制之后，那么写文章也就不是专注于文章了。（比如我写文章也一直很跳，跟性格有关吧）</p><p>所以我才想要实现这么个东西，实际上在早之前就已经打算了，当时前端太菜。也不知道<code>electron</code>是什么东西。还是个<code>swift</code>新教徒的时候。有想过用MacOS 原生的方式去做这个东西，后来放弃了，原因还是因为技术上的问题。</p><p>这次实现这个东西的时候，巧了，跟<a href="http://www.ahonn.me" target="_blank" rel="external">@Ahonn</a>几乎不约而同的想到了一起。他也说他很早就想做了，不过大神不是因为技术原因，而是开坑不填工期延后…</p><p>不过他的实现方式是不同的，他想使用<code>cljs</code>去实现这个东西。我为了求稳，还有还是熟悉一下<code>TypeScript</code>作为脚本使用的感觉，用了这么套技术栈。</p><p>Ahonn的项目地址是这个：<a href="https://github.com/ahonn/hexdit" target="_blank" rel="external">ahonn / hexdit</a>。利益相关的话：还是算关系挺好的校友吧…</p><h2 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h2><p>不搞事情，不吹牛逼，这次为了 <del>装逼</del> 测试一下软件大概“正常使用”有没有什么问题。所以这次我这篇文章完完全全使用<code>Hyper</code>创建、编写、保存、修改，甚至我等下生成发布也直接用这个。</p><p>确实，这才像在写博客。</p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/2.png" alt=""></p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/7.png" alt=""></p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/9.png" alt=""></p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/10.png" alt=""></p><p>我甚至都不怕被你看！</p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/5.png" alt=""></p><p>（因为编辑器的样式还有预览的样式还没上，所以现在看起来还是很丑的，不过测试功能嘛，我等下还会用其他编辑器看）</p><p>但不管怎么说！就是好看！<strong>简就是美！甚至还有点少女心！</strong></p><p>在首屏直接载入<strong>整个博客程序文件夹</strong>之后，就会到达这个界面，左边是显示你当前博客程序里面的文章（名字我都不怕给你看，这名字最后会显示到网址上！），文章列表上面三个按钮分别是 “创建”，“预览”，“生成/发布”。每一个文章名称前面一个“绿色的勾”是提醒你，当前这篇文章是可见的。没错文章可以是隐藏的，这在<code>hexo</code>的文档上有提到，<code>source</code>文件夹中不会上传文件名前带’_’的文件。所以自然可以过滤“草稿”和“不想发布”的文章。所以隐藏的文章会显示一个红色的叉。</p><p>点击想编辑的文章之后，其实会有动画回馈，但是不会常驻高亮。然后右边会跳出目前文章的内容以及一些编辑文章会用到的功能。实际上我应该做一个当前编辑文件高亮的！</p><p>右边编辑区中第一个“笔样子”的图标我是放着玩的…一些测试的工作会挂在上面当starter。然后保存和删除这个应该能看懂。右边有个开关，这个开关就是作为<strong>“选择当前文章是否隐藏”</strong>的作用。当然如果是<code>off</code>状态的话就是显示了，默认也是显示的。最右边的“X”就是关闭当前编辑区咯。</p><p>下面一整个编辑区，写文章可以用，不过<code>markdown</code>了，应该熟悉的是不会用到的吧，可能会用到两个功能：一个是全屏编辑，一个是分屏编辑。噢插入表格也可以有，<code>markdown</code>的表格真是蛋疼。</p><h3 id="另外还给对hexo不熟悉的写手准备了一个大功能。"><a href="#另外还给对hexo不熟悉的写手准备了一个大功能。" class="headerlink" title="另外还给对hexo不熟悉的写手准备了一个大功能。"></a>另外还给对hexo不熟悉的写手准备了一个大功能。</h3><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/3.png" alt=""></p><p>那就是简易设置了！漂不漂亮我不敢说！反正我就喜欢清静的感觉，看看<code>Nlvi</code>！是不是还有一股禅意！</p><p>截图的信息是我在做测试的时候，我当前导入的是当时用来测试主题功能的一个示例博客，官方提供的。毕竟不敢把自己的博客导入进去，万一弄瞎了不就真瞎了…</p><p>就我遇到的很多情况看，还是会有刚接触前端或者刚接触hexo的人不知道hexo的配置文件应该是怎么弄的。虽然我在<a href="https://github.com/ColMugX/hexo-theme-Nlvi" target="_blank" rel="external">hexo-theme-Nlvi</a>里面写到：如果主题有使用问题的话，你可以提ISSUE，或者直接到知乎上锤我！</p><p>但事实上，很多给我知乎发私信的同学，问的都基本不是主题使用的问题，反而是博客本身的使用问题。所以我重新整理了博客配置文件，并把一些比较重要的，必须要的功能作为一张设置界面出来，这样就方便使用了。只要这张填的满，按道理说博客的显示和发布就没问题了。</p><p>而且这张设置界面就这么多内容，在地址设置下面也就多了一个“文章代码是否高亮”和“部署地址”。这样而已。然后就可以保存完事。</p><p>由于还是在测试和进一步编写。所以一些难看的目前用不到的我都<code>display:none</code>了，所以看不到完整设置。</p><p>初来乍到，第一次写这种软件，还是有很多问题的。如果你看到问题了还希望你能帮我指正。我也是想服务一下社区，给喜欢但是不会用的人一点帮助。</p><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>其实介绍文章按正常来说到上面就结束了。这也是为什么 “是什么 -&gt; 为什么 -&gt; 怎么做”反而是这种顺序。</p><p>关于是什么，应该很多人都不愿意去关心了，这里是我想记录的一些心得和学习遇到的坑。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;稳的稳的，这次真是为了需求造轮子了。Hyper = Hexo + Typer. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接触到hexo是因为，hexo可以是一个前端博客生成器，直接生成一个前端静态页面，做到可以上传到github“个人页面”作为博客网站。&lt;/p&gt;
&lt;p&gt;不过，毕竟是基于&lt;code&gt;node&lt;/code&gt;的生成器，编写过程很geek。首先创建和预览甚至发布，依赖&lt;code&gt;terminal&lt;/code&gt;和&lt;code&gt;node&lt;/code&gt;。你要使用一个你喜欢的&lt;code&gt;markdown&lt;/code&gt;编辑器，或者直接就在代码编辑器搞例如&lt;code&gt;vscode&lt;/code&gt;。原来我也是用这个写博客。因为自带了&lt;code&gt;terminal&lt;/code&gt;，直接创建了搞完直接上。后来生活逐渐好点，用的 iterm2 + zsh 之后，编辑器改用了&lt;code&gt;Typora&lt;/code&gt;。然而关于这段的话，我上一篇&lt;a href=&quot;http://blog.co1mugx.tk/2017/08/22/do-markdown-hexo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;搞electron+vue+webpack2+TypeScript什么体验&lt;/a&gt; 已经讲得够多了，所以不赘述了。&lt;/p&gt;
&lt;p&gt;但是现在，可能生活会更好了…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/ColMugX/GitBed/raw/master/hyper/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="实践尝试" scheme="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="electron" scheme="https://colmugx.github.io/blog/tags/electron/"/>
    
      <category term="TypeScript" scheme="https://colmugx.github.io/blog/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>构建一个简单前端开发环境</title>
    <link href="https://colmugx.github.io/blog/2017/08/31/create-fe-env/"/>
    <id>https://colmugx.github.io/blog/2017/08/31/create-fe-env/</id>
    <published>2017-08-31T10:12:20.000Z</published>
    <updated>2017-12-28T10:22:09.331Z</updated>
    
    <content type="html"><![CDATA[<p>虽然<code>webpack</code>在如今这个时代已经众所周知了。但是有些时候只是想简单涂涂画画，没必要很工程化。而且配一个<code>webpack</code>在“玩具”看来肯定是麻烦的。</p><p>这两天刚好想只写一点简单页面，不需要复杂的工程逻辑也不需要组件化（好吧实际上也组件化了），所以记录一下 <strong>一个简单页面开发环境是怎样的</strong><br><a id="more"></a></p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>不想用<code>webpack</code>的时候，第一个先想到的就是<code>gulp</code>。所以构建开发环境的打包工具就用这个了，其他就肯定是插件了。所以<strong>我的</strong>列表大概就如下</p><ul><li>gulp</li><li>gulp-autoprefixer</li><li>gulp-babel (option)</li><li>babel-core (option)</li><li>gulp-browserify (option)</li><li>gulp-concat (option)</li><li>gulp-minify-css (option)</li><li>gulp-nunjucks (option)</li><li>gulp-rename (option)</li><li>gulp-stylus (option)</li></ul><p>除了前三个，下面哪些都是可选的。接下来再讲讲为什么选这些东西。</p><h2 id="关于HTML的处理"><a href="#关于HTML的处理" class="headerlink" title="关于HTML的处理"></a>关于HTML的处理</h2><p>模板的话我选择的是<code>nunjucks</code>，业界毒瘤<code>mozilla</code>的产品。这是一个极其强大又简单的模板。选择它是因为它的基本语法都跟我用的<code>swig</code>是一样的。不过<code>swig</code>已经停止维护很久了，但是我对一些操作又比较熟悉。所以选择了它。另外一点是，<code>njk</code>是很自由的，它并没有要求你的后缀是怎样的。所以我一直使用<code>*.html</code>来命名。</p><p>所以自然需要用到<code>gulp-nunjucks</code>。最简单的处理方法是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gulp.src(<span class="string">'template/index.html'</span>)</div><div class="line">      .pipe(nunjucks.compile(json))</div><div class="line">      .pipe(gulp.dest(<span class="string">'dist'</span>))</div></pre></td></tr></table></figure><p>这里我还用到了<code>js-yaml</code>，因为我自己搞事的时候会更偏向用<code>yaml</code>来代替<code>json</code>。我觉得没有括号看起来确实要清晰一些。</p><p>实际上如果你的动态的内容是<code>json</code>格式的话，这里就结束了。插件会直接自动的把内容填进去然后生成结束。不过我的话，就会多了一步：把<code>yml</code>读成<code>json</code>然后再推进去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yaml.safeLoad(fs.readFileSync(<span class="string">'_config.yml'</span>, <span class="string">'utf8'</span>))</div></pre></td></tr></table></figure><p>同步读出<code>yml</code>文件的内容进行翻译，然后再把得到的<code>json</code>传入模板进行合并。</p><h2 id="关于CSS的处理"><a href="#关于CSS的处理" class="headerlink" title="关于CSS的处理"></a>关于CSS的处理</h2><p>我只愿意使用<code>stylus</code>，原因很简单就是不喜欢另外两个…<code>less</code>实现一个<code>mixin</code>很麻烦又不好理解，而且相对于<code>sass</code>和<code>stylus</code>少了函数的内容，所以<code>less</code>本质上还是在写<code>css</code>，没有更方便的做法。</p><p>而不用<code>sass</code>的原因更扯淡了——<code>ruby</code>实现的产物不用，虽然还有一个<code>scss</code>，而且从功能或者“文法”与<code>stylus</code>接近的，至少一个思路。但<code>stylus</code>更像<code>javascript</code>，很多操作和定义你可以按照你的<code>javascript</code>感觉来走。</p><p>然后就是兼容性补全，我直接用gulp的组件<code>gulp-autoprefixer</code>了，以简单为主，所以不考虑<code>postcss</code>。</p><p>另外就是习惯问题了，我会习惯压缩掉，<code>gulp-minify-css</code>用来压缩，顺便用<code>gulp-rename</code>加上<code>.min</code>的后缀</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'style'</span>, () =&gt; &#123;</div><div class="line">  gulp.src(<span class="string">'styles/style.styl'</span>)</div><div class="line">      .pipe(concat(<span class="string">'style.styl'</span>))</div><div class="line">      .pipe(stylus())</div><div class="line">      .pipe(autoprefixer(&#123;</div><div class="line">        browsers: [</div><div class="line">          <span class="string">'last 2 version'</span>,</div><div class="line">          <span class="string">'iOS &gt;= 7'</span>,<span class="string">'Android &gt;= 4.0'</span></div><div class="line">        ],</div><div class="line">        cascade: <span class="literal">true</span></div><div class="line">      &#125;))</div><div class="line">      .pipe(rename(&#123;<span class="attr">suffix</span>: <span class="string">'.min'</span>&#125;))</div><div class="line">      .pipe(minicss())</div><div class="line">      .pipe(gulp.dest(<span class="string">'dist/style'</span>))</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2 id="关于JS的处理"><a href="#关于JS的处理" class="headerlink" title="关于JS的处理"></a>关于JS的处理</h2><p>我会有两种做法，一种用到<code>browserify</code>，不过既然用到这个东西的话为什么不用<code>webpack</code>呢…</p><p>另一种是用<code>babel</code>，因为现在就算新司机也直接接触了ES6，习惯了的话，难免会写出一些非ES5语法的东西出来。虽然现在的现代浏览器基本都支持ES6（部分P/A+了），但是目前的话还是转一下比较保险。</p><h2 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h2><p>附加题：用的是<code>browsersync</code>，它并不是<code>gulp</code>的插件，但是可以搭配使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然&lt;code&gt;webpack&lt;/code&gt;在如今这个时代已经众所周知了。但是有些时候只是想简单涂涂画画，没必要很工程化。而且配一个&lt;code&gt;webpack&lt;/code&gt;在“玩具”看来肯定是麻烦的。&lt;/p&gt;
&lt;p&gt;这两天刚好想只写一点简单页面，不需要复杂的工程逻辑也不需要组件化（好吧实际上也组件化了），所以记录一下 &lt;strong&gt;一个简单页面开发环境是怎样的&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="实践尝试" scheme="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>搞electron + vue + webpack2 + TypeScript什么体验</title>
    <link href="https://colmugx.github.io/blog/2017/08/22/do-markdown-hexo/"/>
    <id>https://colmugx.github.io/blog/2017/08/22/do-markdown-hexo/</id>
    <published>2017-08-21T16:12:56.000Z</published>
    <updated>2017-12-07T02:26:50.637Z</updated>
    
    <content type="html"><![CDATA[<p>本来是想放弃的，后来歪打正着，成功运行。最后搞一个ts类型的启动器，不想再懵了。</p><p><a href="https://github.com/ColMugX/vue-ts-electron-starter" target="_blank" rel="external">vue-ts-electron-starter</a></p><p>想看看原项目<code>electron-vue</code>有没有这个打算，没有的话自己fork个分支出来。这个将就。</p><p>这次搞这个项目目的就很明显了，想做一个Hexo博客的编辑器（没错就是我这个博客的核心）。Hexo的话，属于页面生成器类的博客系统。直接一套生成静态页面，然后随意访问。因为一整套静态页面故还是有人喜欢直接干一套SPA上去，体验也好。</p><p>其实搞这个，我去年就想搞了。可是去年的话，明显前端的技术都不扎实更别说搞了，当时的想法是写一个Mac App（我swift应该还行，随便写写问题不大。不过可能现在的话问题就大了）。不过就一直拖拖拖，导致swift3.0都有苗头了我还是没想写。而且关于如何操作terminal命令，还是个问题。</p><p>这次心就大了。搞了再说，搞一半不行了就让他荒了。以后想起来再搞，再搞的时候技术肯定又上涨。如果这波做成了，开源，我不管有没有人用，总有人喜欢用。<br><a id="more"></a></p><h2 id="讲在前面"><a href="#讲在前面" class="headerlink" title="讲在前面"></a>讲在前面</h2><p>在这之前我用的是<a href="https://github.com/CodeFalling/blog-admin" target="_blank" rel="external">CodeFalling / blog-admin</a>。这是一个Emacs的插件，当然spacemacs也能弄来用一下。这是一个在github很活跃的大神写的（我经常看到，同时也是hexojs成员），也是很出名的Emacs教徒。不过据说他现在用的是webstorm + vim插件了…</p><p>当然今天不想吹Emacs，而且工作上我也不敢用Emacs，原因不说。</p><p>其实就是一直想做一个方便用一点的。在emacs之前我都是开一个terminal+一个编辑器来做的。在emacs之前是用<code>typora</code>和<code>vscode</code>做的。总这样不好吧太麻烦了。而且这东西又算刚需…所以算了，还是尝试一下吧，顺便把<code>electron</code>和<code>vuex</code>给学清楚了，而且顺便练一下<code>TypeScript</code>。</p><p>所以这次打算的技术选型是：</p><ul><li>TypeScript</li><li>electron</li><li>vue</li><li>vuex</li></ul><p>electron + vue环境的话，直接使用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="external">SimulatedGREG/<em>electron-vue</em></a>，这样<code>electron</code>，<code>vue</code>，<code>webpack</code>就都完成了。如果针对<code>TypeScript</code>的话<code>webpack</code>应该要小改一下。</p><h2 id="为什么使用TypeScript"><a href="#为什么使用TypeScript" class="headerlink" title="为什么使用TypeScript"></a>为什么使用TypeScript</h2><p>TypeScript是微软开发的语言，由于师出同门所以跟<code>C#</code>的语法是极其像的，不过由于是<code>JavaScript</code>的超类，所以还会考虑到ES的语法。所以很早的时候<code>ES6</code>还没流行起来的时候，<code>TypeScript</code>已经开始使用像ES6一样的语法，并提供编译把TS的代码编译成ES5的代码，在没有<code>es6</code>和<code>babel</code>的世界，需要用JS来创造更强大的程序无疑是福音。</p><p>一开始看到的时候，我觉得JS也就那样了，还能怎样…到后来去接触的原因，是因为它的语法跟我先接触的<code>swift</code>很像，我觉得可能能通过TS学好swift或者说通过对swift的理解去学TS，反正都能编译成JS的嘛。</p><p>再后来就遇到了游戏，接触Unity3D的时候，最热门最成熟的语言是C#，而我当时是个软黑。转而让我发现了Egret，Egret竟然把TS作为开发语言，我就想要不把TS也弄清楚了，以后如果接触C#可能也不会太难。可是经过几轮跌爬滚打之后，我竟然放弃了…对这就是我小时候的不懂事…大学快毕业的时候几乎每天就在后悔，为什么当时不好好学TS，而在ES6789流行开的时代里，语法完整功能完善的TS优势也没有那么大了。现在浏览器都能直接用ES7了…</p><p>但是现在说没优势都是骗人的…如果你只是单纯用JS写的话，一如果出现类型错误，不好控制。二在万物都是函数的世界中，可能如果要实现一些其他功能，可能会考虑不周。即使能考虑到了，写上去。也会造成很大的工作量。但是TS编译器都替我们想好和做好了，为什么不去用？</p><p>所以，如果是应用开发的话，为什么不考虑应用级别的开发语言呢？我是这么想的。</p><p>如果是web，但是要强大的框架比如vue，reactjs，我会选择用JS。如果是需要更强大的能力和稳定、可控的app，我肯定是选择TS。</p><h2 id="干！填坑！"><a href="#干！填坑！" class="headerlink" title="干！填坑！"></a>干！填坑！</h2><p>两点核心</p><ul><li><code>webpack</code>需要配置对<code>TypeScript</code>的编译。</li><li>从入口到组件都使用<code>TypeScript</code></li></ul><p>因为我也是误打误撞突然可以正常运行，所以我是开一个新的项目进行接下来的工作。 （结果发现并不是误打误撞，而是本来就是正确的，那么为什么会错误…）</p><p>首先npm安装<code>typescript</code>, <code>ts-loader</code>, <code>vue-class-component</code>，这三个都很重要。<code>typescript</code>提供的是语言支持，也可以说是提供内部编译，当然如果说你本身就全局装过了，那么你直接<code>link</code>就行了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">npm i -S typescript ts-loader vue-class-component</div><div class="line"></div><div class="line"><span class="comment"># or</span></div><div class="line">npm i -S ts-loader vue-class-component</div><div class="line">npm link typescript</div></pre></td></tr></table></figure><p>然后是<code>webpack.renderer.config.js</code>，不出意外的话在<code>25:3</code>入口，<code>26:58</code>把<code>js</code>改成<code>ts</code>，下面的rule添加对ts的支持</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">test: <span class="regexp">/\.ts$/</span>,</div><div class="line">loader: <span class="string">'ts-loader'</span>,</div><div class="line">exclude: <span class="regexp">/node_modules|vue\/src/</span>,</div><div class="line"> options: &#123;</div><div class="line">appendTsSuffixTo: [<span class="regexp">/\.vue$/</span>]</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果有需要<code>tslint</code>的话（说实话我还不会用…而且我觉得ts约束本来就很厉害了），需要安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i -S tslint tslint-loader</div></pre></td></tr></table></figure><p>老位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">test: <span class="regexp">/\.(ts)$/</span>,</div><div class="line">enforce: <span class="string">'pre'</span>,</div><div class="line">exclude: <span class="regexp">/node_modules/</span>,</div><div class="line">use: &#123;</div><div class="line">loader: <span class="string">'tslint-loader'</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第二，就是把关于<code>vue</code>部分的入口改成<code>main.ts</code>。这样接近完成。</p><p>第三，最重要的，<code>typescript</code>能不能用就靠这个了，<code>jsconfig.json</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tsc --init<span class="comment">#通过tsc初始化得到</span></div></pre></td></tr></table></figure><p>至于怎么配置，<code>vue</code>官方也给了一个推荐配置，<code>vue-class-component</code>也给了一个。</p><p>但不管怎样，建议把<code>allowjs</code>打开了，可以调用<code>js</code>文件。</p><h3 id="开始填坑"><a href="#开始填坑" class="headerlink" title="开始填坑"></a>开始填坑</h3><ul><li>入口必须是<code>.ts</code></li></ul><p>这点说起来很坑，TS的话，只要有<code>allowjs</code>就可以调用JS文件，运行是没问题的。但是反过来就不行了，毕竟超类能认，但JS根本不知道TS是个什么鬼，所以无法编译</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Module build failed: Error: Could not find file: <span class="string">'...*.ts'</span> </div><div class="line"></div><div class="line"><span class="comment"># 或者</span></div><div class="line">Module build failed: Error: Could not find file: <span class="string">'...*.vue'</span></div></pre></td></tr></table></figure><p>所以必须是TS入口</p><ul><li>建议关于<code>script</code>部分分开写。</li></ul><p>当然是可以直接在<code>.vue</code>写你的逻辑的，不过为了防止<code>typescript</code>有小脾气，或者关于类型推断，总的来说就是为了编译少点麻烦吧，我觉得还是分开写是最保险的。当然在组件内写也不是不可以。</p><ul><li><code>vue-class-component</code>核心</li></ul><p>如果用了TS的话，那么漂亮的组件代码肯定就是<code>class</code>了，通过修饰<code>@component</code>声明该位置是一个组件，然后开始写组件代码，继承自<code>vue</code>，然后就可以像写一个程序类一样去写这部分组件。看起来是相当漂亮的。举个例子，在通过<code>electron-vue</code>创建出来的工程中，对实例组件<code>LandingPage.vue</code>进行改写</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">  name: <span class="string">'landing-page'</span>,</div><div class="line">  components: &#123;</div><div class="line">    SystemInformation</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> LandingPage <span class="keyword">extends</span> Vue &#123;</div><div class="line">  open (link) &#123;</div><div class="line">    (<span class="keyword">this</span> <span class="keyword">as</span> <span class="built_in">any</span>).$electron.shell.openExternal(link)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>漂亮，清晰。（当然复杂一点，就复杂了！）</p><ul><li>关于对Vue进行扩展</li></ul><p>在添加<code>axios</code>的时候我遇到了问题：无法扩展<code>Vue</code>，原因好像是无法推断<code>vue</code> 的类型。这个问题的话，我还得去研究一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来是想放弃的，后来歪打正着，成功运行。最后搞一个ts类型的启动器，不想再懵了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ColMugX/vue-ts-electron-starter&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vue-ts-electron-starter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;想看看原项目&lt;code&gt;electron-vue&lt;/code&gt;有没有这个打算，没有的话自己fork个分支出来。这个将就。&lt;/p&gt;
&lt;p&gt;这次搞这个项目目的就很明显了，想做一个Hexo博客的编辑器（没错就是我这个博客的核心）。Hexo的话，属于页面生成器类的博客系统。直接一套生成静态页面，然后随意访问。因为一整套静态页面故还是有人喜欢直接干一套SPA上去，体验也好。&lt;/p&gt;
&lt;p&gt;其实搞这个，我去年就想搞了。可是去年的话，明显前端的技术都不扎实更别说搞了，当时的想法是写一个Mac App（我swift应该还行，随便写写问题不大。不过可能现在的话问题就大了）。不过就一直拖拖拖，导致swift3.0都有苗头了我还是没想写。而且关于如何操作terminal命令，还是个问题。&lt;/p&gt;
&lt;p&gt;这次心就大了。搞了再说，搞一半不行了就让他荒了。以后想起来再搞，再搞的时候技术肯定又上涨。如果这波做成了，开源，我不管有没有人用，总有人喜欢用。&lt;br&gt;
    
    </summary>
    
      <category term="实践尝试" scheme="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="vue" scheme="https://colmugx.github.io/blog/tags/vue/"/>
    
      <category term="electron" scheme="https://colmugx.github.io/blog/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的call()，bind()，apply()</title>
    <link href="https://colmugx.github.io/blog/2017/08/14/js-call-apply-bind/"/>
    <id>https://colmugx.github.io/blog/2017/08/14/js-call-apply-bind/</id>
    <published>2017-08-14T04:26:44.000Z</published>
    <updated>2017-11-20T10:07:03.112Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>联动水文，大约半年前记录了Javascript的this。顺水推舟理一下call()，bind()，apply()</p></blockquote><p>扩展阅读：<a href="https://colmugx.github.io/PersonalBlog/2017/03/03/js-this/">关于JavaScript的this</a></p><p>还是上次的代码，修改一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> test = obj.getName</div><div class="line">test()<span class="comment">//undefined.</span></div></pre></td></tr></table></figure><p>（敲黑板！）复习一下！为什么就<code>undefined</code>了！原因就是，<code>this</code>指向不同了。那么直接运行是否可以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">obj.getName()<span class="comment">//koala</span></div></pre></td></tr></table></figure><a id="more"></a><p>因为有时候并没办法这么自由的随便调用，那如果要搞个变量出来用，怎么做？</p><h2 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h2><blockquote><p><strong>call</strong></p><ul><li>vi. 呼叫；拜访；叫牌</li><li>vt. 呼叫；称呼；召集</li><li>n. 电话；呼叫；要求；访问</li><li>n. (Call)人名；(瑞典、罗)卡尔；(英)考尔<br>以上来自有道翻译</li></ul></blockquote><p>有一手有道翻译就方便了，就是call（叫）它，把要用的方法call（叫）出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> cal = obj.getName<span class="comment">//先定义出来</span></div><div class="line">cal.call(obj)<span class="comment">//koala   （指向还给他，不动其他把它叫出来</span></div></pre></td></tr></table></figure><h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h2><blockquote><p><strong>apply</strong></p><ul><li>v.应用；使用；涂；敷</li><li>Web申请；适用；套用<br>以上来自bing词典，感谢微软爸爸</li></ul></blockquote><p>再来一手必应翻译简直就是，不谈了！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> apy = obj.getName<span class="comment">//这手还是不变</span></div><div class="line">apy.apply(obj)<span class="comment">//koala  （可以说不是指向还给他，这不是假装了，而是直接套用</span></div></pre></td></tr></table></figure><p>有人要问，那你这手跟<code>call()</code>不是一样的么，为什么要区分开来。这个问题<a href="/2017/08/14/js-call-apply-bind/#call-和-apply-区别">下面再讲</a></p><h2 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h2><p>是不是以为我要用百度翻译了？我偏不！</p><blockquote><p><strong>bind</strong></p><p><strong>n.</strong> 窘境；讨厌的事情；捆绑；植物的藤蔓<br><strong>v.</strong> 捆绑；约束；装订；（使）结合；使关系密切<br>以上来自沪江小d，我学日语就靠它</p></blockquote><p><del>顺便，请以上三家公司尽快给我打钱，谢谢合作。</del></p><p><code>bind()</code>有点土匪的意思，它就是想抢走你老婆借用一晚的意思。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> bid = obj.getName<span class="comment">// [Function: getName]          (这手还是不变</span></div><div class="line"></div><div class="line"><span class="comment">// 接着这样做，把this指向回去，变成一个可以自由操作的变量</span></div><div class="line">bid = bid.bind(obj)<span class="comment">// [Function: bound getName]</span></div><div class="line"></div><div class="line">bid()<span class="comment">// koala   （这样才会运行，因为刚刚只是抢过来了</span></div></pre></td></tr></table></figure><h2 id="call-和-apply-区别"><a href="#call-和-apply-区别" class="headerlink" title="call()和#apply()区别"></a>call()和#apply()区别</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> cal = obj.getName</div><div class="line">cal.call(obj)<span class="comment">//koala</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> apy = obj.getName</div><div class="line">apy.apply(obj)<span class="comment">//koala</span></div></pre></td></tr></table></figure><p>说是这么说了，可是，他们并不是说就这么改变<code>this</code>方向然后就没什么用处了啊，可以借用<code>call()</code>和<code>apply()</code>传参数的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName(param1, param2) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' params: '</span> + param1 + param2</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> cal = obj.getName</div><div class="line">cal.call(obj, <span class="number">1</span>, <span class="number">2</span>)<span class="comment">//koala params: 12</span></div></pre></td></tr></table></figure><p>那么<code>apply()</code>就有区别了？哎！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> apy = obj.getName<span class="comment">//这手还是不变</span></div><div class="line">apy.apply(obj, [<span class="number">1</span>, <span class="number">2</span>])<span class="comment">//koala params: 12</span></div></pre></td></tr></table></figure><p><code>apply</code>后面接参数，只接受数组，<code>call</code>的话按顺序怼进去就行了。就这点区别。</p><p>暂时先这样，以后更深入的使用再深入的理解一下。现在大概就用到这些。</p><p><strong>下一篇，讲Javascript的柯基化！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;联动水文，大约半年前记录了Javascript的this。顺水推舟理一下call()，bind()，apply()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;扩展阅读：&lt;a href=&quot;https://colmugx.github.io/PersonalBlog/2017/03/03/js-this/&quot;&gt;关于JavaScript的this&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还是上次的代码，修改一下&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&#39;panda&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; obj = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&#39;koala&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    getName() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; test = obj.getName&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;test()					&lt;span class=&quot;comment&quot;&gt;//undefined.&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（敲黑板！）复习一下！为什么就&lt;code&gt;undefined&lt;/code&gt;了！原因就是，&lt;code&gt;this&lt;/code&gt;指向不同了。那么直接运行是否可以&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&#39;panda&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; obj = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&#39;koala&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    getName() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;obj.getName()		&lt;span class=&quot;comment&quot;&gt;//koala&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
</feed>
