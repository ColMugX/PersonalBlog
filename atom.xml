<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ColMugX</title>
  
  <subtitle>SHOW YOUR FUNCTION NO BB.</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://colmugx.github.io/blog/"/>
  <updated>2018-01-22T16:53:41.776Z</updated>
  <id>https://colmugx.github.io/blog/</id>
  
  <author>
    <name>Co1MugX</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通过dva得到的思考 —— “滥用”VUEX</title>
    <link href="https://colmugx.github.io/blog/2018/01/22/vuex-dva/"/>
    <id>https://colmugx.github.io/blog/2018/01/22/vuex-dva/</id>
    <published>2018-01-22T15:35:15.000Z</published>
    <updated>2018-01-22T16:53:41.776Z</updated>
    
    <content type="html"><![CDATA[<p>首先这一手骚操作要感谢@ahonn，确实这几天学习dva，我自己都觉得自己有点烦了。但是老哥好耐心，真心感谢。</p><p>直接上正题吧不磨磨唧唧的了！</p><h3 id="dva是什么"><a href="#dva是什么" class="headerlink" title="dva是什么"></a>dva是什么</h3><p>这还用说吗，坦克啊！双命特性，大招是通过机甲自爆产生大范围爆炸，本体只有100血，可以反…啊！！！别打我啊！</p><p>好吧可能阿里的工程师也喜欢玩守望先锋，而且我清晰记得dva这个框架就是守望大火的时候诞生的，而且还有一个协同工具叫路霸吧。（看来阿里的工程师都不喜欢当C…）</p><p><code>dva</code>是针对<code>react</code>的框架，实际上就是关于<code>redux</code>的一个封装。首先是让本来很难理解和使用的redux变得相对容易理解和操作。另外一个就是因为数据集中管理，并且推荐使用无状态组件，操作者只需要关心数据的走向。</p><h3 id="从dva得到了启示"><a href="#从dva得到了启示" class="headerlink" title="从dva得到了启示"></a>从dva得到了启示</h3><p>毕竟阿里前端工程师，Ahonn是真的喜欢阿里的东西…最近跟他聊天也比较深入了解“为什么我们需要dva”。</p><p>后来我一个闪念：<code>dva</code>会不会就是一个数据库模型，实际上redux对我们来说就是一个数据库，前端没有状态，不干涉数据，实际上就是我们常说的只关心增删改查？</p><p>那么dva实际上还是对<code>redux</code>，<code>redux-saga</code>，<code>redux-thunk</code>的封装，但对于vue来说简直就是先天优势，因为对于vuex来说已经相当于redux + redux-saga了。从这里也直接萌生了一个想法：vuex + stateless component = 1/2 dva ？</p><h3 id="对启示更清晰的思考"><a href="#对启示更清晰的思考" class="headerlink" title="对启示更清晰的思考"></a>对启示更清晰的思考</h3><p>首先现在的dva，把数据都封装在<code>model</code>中，一个<code>model</code>对应一个redux，<code>state</code>, <code>reducer</code>概念得以保留，引入<code>effect</code>和<code>subscriptions</code>概念。</p><p>首先副作用的目的是，通过异步操作例如网络请求或者一些需要异同步配合的操作，然后去驱使<code>reducer</code>更新<code>state</code>，因为在流中，只有<code>reducer</code>有权利去动<code>state</code>。<code>subscriptions</code>就是一个订阅的概念，在我看来就是一个初始化，或者说是一个接受状态的概念。</p><p>那么为什么说vuex有先天优势？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// dva model</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  namespace: <span class="string">"users"</span>,</div><div class="line">  state: &#123;&#125;,</div><div class="line">  reducers: &#123;&#125;,</div><div class="line">  effects: &#123;&#125;,</div><div class="line">  subscriptions: &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// vuex</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  modules: &#123;</div><div class="line">    users: &#123;</div><div class="line">      namespaced: <span class="literal">true</span>,</div><div class="line">      state: &#123;&#125;,</div><div class="line">      mutations: &#123;&#125;,</div><div class="line">      actions: &#123;&#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>如果你要无限逼近dva是什么感觉？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// users.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  namespaced: <span class="literal">true</span>,</div><div class="line">  state: &#123;&#125;,</div><div class="line">  mutations: &#123;&#125;,</div><div class="line">  actions: &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//store.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  modules: &#123;</div><div class="line">    users</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>由于 vue/vuex 对于规则还是相对宽松，但理是理法是法，约定俗成<code>mutations</code>是用来做同步的工作，可以用来操作<code>state</code>；<code>actions</code>用来做异步工作，通知<code>mutations</code>去操作<code>state</code>。所以这里是不是就有一种新的概念？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">state &lt;=&gt; state</div><div class="line">mutation &lt;=&gt; reducer</div><div class="line">action &lt;=&gt; effect</div><div class="line"></div><div class="line">_ &lt;=&gt; subscription</div></pre></td></tr></table></figure><p>对没错，订阅怎么办？</p><p>在dva的例子中，看一下示例的订阅是做了什么工作？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">subscriptions: &#123;</div><div class="line">  setup(&#123; dispatch, history &#125;) &#123;</div><div class="line">    <span class="keyword">return</span> history.listen(<span class="function">(<span class="params">&#123; pathname, query &#125;</span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">if</span> (pathname === <span class="string">'/users'</span>) &#123;</div><div class="line">        dispatch(&#123; <span class="attr">type</span>: <span class="string">'fetch'</span>, <span class="attr">payload</span>: query &#125;)</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>所以关于这个简单订阅，我们完全可以直接用<code>vue-router</code>，而其中刚好有一个概念我们可以直接使用 —— 导航守卫</p><h3 id="针对vue的操作"><a href="#针对vue的操作" class="headerlink" title="针对vue的操作"></a>针对vue的操作</h3><p>老样子，我们是怎么理解dva的<code>model</code>，就怎么理解vuex的<code>store</code>。首先<code>state</code>和<code>reducer</code>是完全对等的，不需要多理解。<code>effects</code>是使用<code>generator</code>函数来解决异同步问题的，那好办啊，都2018年了，我们直接用async/await就行了。而且我们之前关于api都是使用<code>promise</code>，而且用的也是<code>axios</code>，所以这部分可以说是无缝切换。</p><p>那么关于订阅，直接使用<code>vue-router</code>的导航守卫对路由监控，另外在必要的时候还能使用<code>meta</code>。当然导航守卫并不是只能用在全局上，也可以注入到组件中，所以我们注入到页面组件即可。</p><p>接下来就是无状态组件问题了，vue默认是状态组件，而且无状态组件也没有react来的方便。</p><p>react想要无状态组件，无非就是一个函数就结束战斗了。vue也有一个概念叫函数式组件，也就是无状态，这种组件在使用上就已经不是很方便了。</p><p>vue的函数式组件就必须使用<code>render</code>函数不能用<code>template</code>模板，一直到vue2.5才可以在<code>&lt;template functional&gt;</code>使用。但我尝试了一下，手感并不好，所以还是只能用 jsx + vue 这种搭配来操作。不过vue的无状态组件也不像react那么好理解，它依然是一个Object</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  functional: <span class="literal">true</span>， <span class="comment">// 你只不过是通过这个开关来切换组件状态</span></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> &lt;h1&gt;&#123;props.msg&#125;&lt;/h1&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>而且在实际使用中，实际上因为vue的概念，你还是没办法在所有组件完全不使用无状态组件（已经除去表单组件）。不过也无伤大雅了。</p><p>所以通过这个操作，也能近似的得到了dva的那种感觉。前端的工作只需要直观的反馈你的数据动向和状态，要那么复杂干什么？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先这一手骚操作要感谢@ahonn，确实这几天学习dva，我自己都觉得自己有点烦了。但是老哥好耐心，真心感谢。&lt;/p&gt;
&lt;p&gt;直接上正题吧不磨磨唧唧的了！&lt;/p&gt;
&lt;h3 id=&quot;dva是什么&quot;&gt;&lt;a href=&quot;#dva是什么&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="vue" scheme="https://colmugx.github.io/blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer —— 替换空格</title>
    <link href="https://colmugx.github.io/blog/2018/01/04/replace-space/"/>
    <id>https://colmugx.github.io/blog/2018/01/04/replace-space/</id>
    <published>2018-01-03T16:03:46.000Z</published>
    <updated>2018-01-03T16:06:42.821Z</updated>
    
    <content type="html"><![CDATA[<p>以后博客专职曲苑杂坛算了…</p><p>刚刚看到一题</p><blockquote><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></blockquote><p>我想这什么腿？然后什么都没想，直接就</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> str.replace(<span class="regexp">/\ /g</span>, <span class="string">'%20'</span>)</div></pre></td></tr></table></figure><p>然后过了……虽然100多毫秒</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以后博客专职曲苑杂坛算了…&lt;/p&gt;
&lt;p&gt;刚刚看到一题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
      <category term="曲苑杂坛" scheme="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>有意思的monad记录</title>
    <link href="https://colmugx.github.io/blog/2017/12/27/funny-monad/"/>
    <id>https://colmugx.github.io/blog/2017/12/27/funny-monad/</id>
    <published>2017-12-27T15:24:58.000Z</published>
    <updated>2018-01-01T14:11:05.380Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看到monad我的第一反应竟然是莫纳德…</p></blockquote><p>最近学习haskell的时候（意外的觉得入门不难），接触到函数式编程一个新的思想——Monad</p><p>之前在知乎看到轮子哥说：学习haskell是好事，但最好就是学到monad就停下来，然后去学别的。对别的语言帮助很大。</p><p>然后在知乎看了一些monad的答案，找了点关于monad的博客看，没看懂。英文的话更不可能了！直接看paper的话我会脆死的。</p><p>后来偶然找到一篇文章：<a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="external">Functors, Applicatives, And Monads In Pictures - adit.io</a></p><p>当然有中文版：<a href="http://jiyinyiyong.github.io/monads-in-pictures/" target="_blank" rel="external">Functors, Applicatives, And Monads In Pictures - adit.io</a>，<br><a href="http://www.ruanyifeng.com/blog/2015/07/monad.html" target="_blank" rel="external">图解 Monad - 阮一峰的网络日志</a></p><p>全程特别轻松，我以后写博客也要按照这个节奏来写！很有意思！<br>（那个抽东西的手直接戳爆了我的笑点…特别是解构传入胶水函数的时候）</p><p>关于理解的话，挖个坑以后总结~</p><p>但有一点是：我用 Vue-jsx 的时候，几乎全是Monad</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;看到monad我的第一反应竟然是莫纳德…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近学习haskell的时候（意外的觉得入门不难），接触到函数式编程一个新的思想——Monad&lt;/p&gt;
&lt;p&gt;之前在知乎看到轮子哥说：学习haskell是好事，但最
      
    
    </summary>
    
      <category term="曲苑杂坛" scheme="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/"/>
    
    
      <category term="Functional Programming" scheme="https://colmugx.github.io/blog/tags/Functional-Programming/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript链式方法</title>
    <link href="https://colmugx.github.io/blog/2017/12/23/js-method-chaining/"/>
    <id>https://colmugx.github.io/blog/2017/12/23/js-method-chaining/</id>
    <published>2017-12-23T10:05:54.000Z</published>
    <updated>2017-12-27T08:56:56.889Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>著名框架<code>jQuery</code>所使用的设计模式——“虾扯蛋”</p></blockquote><p>之前在知乎回答过一个问题：2018的前端应该学什么。</p><p>我回答了：就算前端再复杂，jQuery依然是最流行的那个。</p><p>这答案怎么样呢？废话！肯定没人点赞了！</p><p>人性就是如此！一旦接受了更<del>装逼</del>新的思路，就会觉得以前见过的东西都太弱了！</p><p>新项目想用什么就用什么，什么技术栈健全就用什么。可是老项目并没办法想干什么干什么，时间和精力不允许他去重构。金蝶还在卖VB呢，他们肯定也想过VB已经不行了。</p><p>好了题外话，我还是很有兴趣实现一个塞进<code>nlvi</code>的类jq的。</p><a id="more"></a><h2 id="怎么来的链式操作"><a href="#怎么来的链式操作" class="headerlink" title="怎么来的链式操作"></a>怎么来的链式操作</h2><blockquote><p>如果不用链式调用，jQuery没有性能可言 ——鲁迅</p></blockquote><p>鲁迅：我不是！我没有！别乱说啊！</p><p>我记得有人测试过，<code>$(&#39;#ele&#39;)</code>会比<code>document.getElementById(&#39;ele&#39;)</code>慢很多。如果是按行操作dom而不是用专属的链式调用，效率会更差。</p><p>但这次不是来讨论jQuery的效率的。链式方法也是一种设计模式，有必要了解一下。就算ES6常使用的<code>Promise</code>，也用到了链式调用。</p><p><code>JavaScript</code>能够函数式编程，还是因为它是个“函数为第一公民”的语言，但它并没有<code>pure function</code>是因为它的设计其实是多范式的。而ES6把构造函数和<code>classes</code>加进去之后更是证明了这一点。</p><h3 id="我用过的JavaScript"><a href="#我用过的JavaScript" class="headerlink" title="我用过的JavaScript"></a>我用过的JavaScript</h3><p>关于这部分，我觉得我想分享的东西有点超篇幅，所以移步到另外一篇分享吧：<a href="/PersonalBlog/2017/12/26/my-known-javascript/">我所认识的JavaScript</a></p><p>大致上就是<code>JavaScript</code>之所以能这么玩是因为它会把任何东西都看做“函数”来看待，并且以它的理解就是：我能且只能掌控函数，函数必有返回值。并且每产生一个函数就会有一个“我”的含义：<code>function</code>会自然而然的产生<code>this</code>并指向自己。而链式操作就是利用了这点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果是浏览器的话，在没有对象的情况下，父级应该就是<code>window</code>了。而函数返回<code>this</code>相当于把自己返回到操作空间中，而操作空间属于父级。也就是说，只要是同一级别的函数，通过返回<code>this</code>把操作权交还到父级手中从而达到继续调用同级函数的技能。还不清楚？反正我不画图。</p><h3 id="简单链式操作"><a href="#简单链式操作" class="headerlink" title="简单链式操作"></a>简单链式操作</h3><p>在此我们以著名歌唱家“雷军”举个例子。雷军可以说是目前最强悍的企业家了，写得了软件造得了手机，能唱一首好歌能吹一手好B。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 雷军（人为对象，构造成立）</span></div><div class="line"><span class="keyword">var</span> LeiJun = &#123;</div><div class="line">  hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'hello, '</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="comment">// -&gt; LeiJun</span></div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  thank: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'thank you, '</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="comment">// -&gt; LeiJun</span></div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  thanks: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'thank you very much, '</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="comment">// -&gt; LeiJun</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 驱使对象雷军唱出《Are you ok》前三句</span></div><div class="line">leijun</div><div class="line">  .hello()</div><div class="line">  .thank()</div><div class="line">  .thanks()</div></pre></td></tr></table></figure><p>如果按字面意思可能永远都理解不来，从而产生哲学三连：我是谁？我在哪？我在干什么？所以又有一句话得以解释：从哪里来，回哪里去。</p><h2 id="为什么用链式操作"><a href="#为什么用链式操作" class="headerlink" title="为什么用链式操作"></a>为什么用链式操作</h2><blockquote><p>新手村的Monad？</p></blockquote><p>所以作用很明显了，一种工厂流水线式的操作，流的形式完成任务。所以我要把这种设计模式归入函数式编程也是因为，函数式思想本来就是让数据经过所有“函数流”最后得到产物并返回。数据不变，不额外干涉操作。</p><p>不同的是，常规FP中，不管是单函数单返回走流，还是柯里化，它都是一种“一进一出”的思想——出来的产物继续传入下一道“工序”进行加工，一直到最后一个加工函数为止。</p><p>然而链式操作并不是这种哲学，它是一种“从第一次进入就买定离手”的操作——只要一开头传入参数，流不结束不会见到半成品。数据经过一层函数之后，可能经过加工处理结束后，又会被打包/压缩/处理到‘this’中并继续接下来的工作。</p><p>链式操作相对于柯里化来说，起码它做到了：</p><ul><li>可阅读</li><li>少占用</li><li>减少代码重复性（都有）</li><li>代码简洁（都有）</li></ul><p>柯里化最明显的优点就是阅读性差（？？？），假设有个方法叫<code>leijun</code>,那么调用方法的画风就大不相同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">leijun()()()</div></pre></td></tr></table></figure><p>鬼才知道他想唱的是“Are you ok”还是“Indian Mi Fans”呢……</p><p>还有就是，因为流操作可以异步。JS也是患有懒癌很多年了，必须靠事件驱动才能工作，所以注定它是不能异步编程的。</p><p>所以jQuery还是很强大的框架，在ES5什么都没有就靠三种规范的语法，已经要实现那么多东西了。让JS支持异步编程也就两种操作吧：函数内回调函数、链式操作函数。这框架两种都用上了。而说NodeJS速度快，一方面也是因为目前两个服务器框架都是异步（一堆回调函数）得到的结果吧。</p><h2 id="不止JavaScript能用"><a href="#不止JavaScript能用" class="headerlink" title="不止JavaScript能用"></a>不止JavaScript能用</h2><p>实际上本质就是，把执行权交给函数之后，函数执行完自己的工作之后，还可以吧执行权重新交回父级手中，让父级自行处理接下来的工作。</p><p>所以强化函数式编程的语言或者说能返回自身的语言应该都可以支持该模式，在这之后我只接触过<code>Golang</code>有这种操作，不过那当时哪来的Go啊…</p><p>这个世界本来就先有的FP，因为概念不够清晰才出现了OOP。现在业务量复杂到OOP已经不好解决了，这个时候人们又想起了凉了的FP。2018年如果前端继续发展下去，可能又会回到一个FP的年代（然后我要放弃FP看着它火了？不！这次看到希望不会撒手了！）</p><p>在我在无脑吹FP的时候（懂得概念不懂得实践），我看到了swift的出现，JAVA8强化λ，go的出现，TypeScript的出现（乱入，它强调OOP）。前几天看到了<code>haskell-react</code>，以后还会有什么？</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;著名框架&lt;code&gt;jQuery&lt;/code&gt;所使用的设计模式——“虾扯蛋”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前在知乎回答过一个问题：2018的前端应该学什么。&lt;/p&gt;
&lt;p&gt;我回答了：就算前端再复杂，jQuery依然是最流行的那个。&lt;/p&gt;
&lt;p&gt;这答案怎么样呢？废话！肯定没人点赞了！&lt;/p&gt;
&lt;p&gt;人性就是如此！一旦接受了更&lt;del&gt;装逼&lt;/del&gt;新的思路，就会觉得以前见过的东西都太弱了！&lt;/p&gt;
&lt;p&gt;新项目想用什么就用什么，什么技术栈健全就用什么。可是老项目并没办法想干什么干什么，时间和精力不允许他去重构。金蝶还在卖VB呢，他们肯定也想过VB已经不行了。&lt;/p&gt;
&lt;p&gt;好了题外话，我还是很有兴趣实现一个塞进&lt;code&gt;nlvi&lt;/code&gt;的类jq的。&lt;/p&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序的骚思路</title>
    <link href="https://colmugx.github.io/blog/2017/12/20/exchange_number/"/>
    <id>https://colmugx.github.io/blog/2017/12/20/exchange_number/</id>
    <published>2017-12-20T06:46:41.000Z</published>
    <updated>2017-12-22T02:59:02.058Z</updated>
    
    <content type="html"><![CDATA[<p>想起以前很容易就会被问到一个问题</p><blockquote><p>如何把两个数值进行交换？</p></blockquote><p>教科书式的编程怎么做？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> k = i;</div><div class="line"></div><div class="line">i = j;</div><div class="line">j = k;</div><div class="line"></div><div class="line"><span class="comment">// 两个数值，把其中一个寄存起来，然后再两次赋值。</span></div></pre></td></tr></table></figure><p>以前去写代码的社团，当时我巨活跃，有个师兄就过来说：看你资质不错，我打算亲自培养你，先问你一个问题吧：你如何把两个数值进行交换？写不出代码没关系，我只是要听思路。</p><p>我：什么跟什么交换？</p><p>师兄：随便你。</p><p>于是我打开了<code>sublime text</code>写下这么些东西</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> j = <span class="number">2</span>;</div><div class="line"></div><div class="line">i += j;</div><div class="line">j = i - j;</div><div class="line">i -= j;</div></pre></td></tr></table></figure><p>然后师兄就懵了，你这个B不按套路出牌？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想起以前很容易就会被问到一个问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何把两个数值进行交换？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;教科书式的编程怎么做？&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="曲苑杂坛" scheme="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>使用JSX的VUE应用开发体验</title>
    <link href="https://colmugx.github.io/blog/2017/12/11/vue-jsx/"/>
    <id>https://colmugx.github.io/blog/2017/12/11/vue-jsx/</id>
    <published>2017-12-11T14:34:10.000Z</published>
    <updated>2017-12-13T02:16:42.951Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我说我是做外包的肯定没人信，给你看看外包程序员瞎几把搞的热情！</p></blockquote><p>前排提醒：vue-jsx和react-jsx相差甚远，前者基本就是玩具生产链。很多想利用JS语言特性的骚套路基本上都不好实现，而且感觉奇奇怪怪的。所以你的生产环境，千万不要乱试vue-jsx这种搭配，够简单就无所谓了…</p><a id="more"></a><h2 id="开局搭环境"><a href="#开局搭环境" class="headerlink" title="开局搭环境"></a>开局搭环境</h2><p>要什么环境，<code>vue-cli</code>就行了，又不是什么大项目大团队需要约定<code>webpack</code>。</p><h2 id="装插件"><a href="#装插件" class="headerlink" title="装插件"></a>装插件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">npm install\</div><div class="line">  babel-plugin-syntax-jsx\</div><div class="line">  babel-plugin-transform-vue-jsx\</div><div class="line">  babel-helper-vue-jsx-merge-props\</div><div class="line">  babel-preset-env\</div><div class="line">  --save-dev</div></pre></td></tr></table></figure><p><code>.babelrc</code>主要是这个</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"plugins"</span>: [<span class="string">"transform-vue-jsx"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为其他的东西基本上都会有，主要是要添加这个东西。至此。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>没错的这文章本来是属于实践的又不是教程。还是要讲一下自己的体验的。</p><h3 id="渲染元素"><a href="#渲染元素" class="headerlink" title="渲染元素"></a>渲染元素</h3><p>感想最大的就是这个，Vue在使用jsx的时候很迷，最明显的感觉怪怪的地方有两个：</p><ol><li>它并不是哪个位置的方法都会有createElement函数的。</li><li>classes形式的组件找不到render函数！</li></ol><p>其实关于vue与jsx，tsx我是做了很多次尝试</p><p>首先第一种，常规的就是一个<code>object</code>对象，然后通过<code>Vue.component()</code>方法构建。这种可以说是我现在看来最没坑的一种形式了。平常的话还是像<code>*.vue</code>里的<code>script</code>标签一样，直接<code>export</code>打头开写，<code>&lt;template /&gt;</code>渲染部分移入了<code>render()</code>函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  render(<span class="comment">/* h / createElement */</span>) &#123;</div><div class="line">    <span class="keyword">return</span> &lt;h1&gt; Hello World &lt;/h1&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种情况的结构与单文件的代码结构是相差无几的，不过换了种渲染方式而已，而且<code>render()</code>函数可以做一些与渲染相关的子方法，比如条件渲染之类的。所以总的来说：</p><p>优点：</p><ol><li>顺手，完全单文件中的<code>script</code>标签</li><li>没了</li></ol><p>缺点：</p><ol><li>这么搞肯定容易眼花啊！</li><li>不好维护，不直观</li></ol><p>第二种，如果是这种结构的tsx的话，与jsx同理。</p><p>第三种，class形式的组件，需要<code>vue-class-component</code>插件。然后可以写出类似于这样的东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">    &lt;h1&gt;Hello World&lt;/h1&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">  @Component</div><div class="line">  export default class MainClass extends Vue &#123;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>乍一看你还以为这是<code>Angular</code>呢！Vue在这方面真的是取长补短的典范。对这种的话，就比传统的方式要好多了，首先全局变量或者<code>data()</code>函数返回值变得特别清晰；再者是原来<code>methods</code>存放的函数可以以<code>class</code>形式的函数来写，那<code>computeds</code>怎么办？直接用<code>get/set</code>关键词，太方便了有没有！</p><p>好了关键的来了…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</div><div class="line">  </div><div class="line">  get render() &#123;</div><div class="line">    <span class="keyword">return</span> &lt;h1&gt; Hello World &lt;/h1&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// render or template not defind.</span></div></pre></td></tr></table></figure><p>这是什么鬼，可能是我操作不当，但是不加<code>get</code>的话不会注入createElement，但是这又是个<code>render()</code>函数，本来不需要加什么前缀的。但是不加有感觉会不会把<code>render()</code>函数识别成是传统写法中存在于<code>methods</code>的函数。</p><p>官方在自动注入这方面有一个栗子的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'jsx-example'</span>, &#123;</div><div class="line">  render () &#123; <span class="comment">// h will be injected</span></div><div class="line">    <span class="keyword">return</span> &lt;div id="foo"&gt;bar&lt;/div&gt;</div><div class="line">  &#125;,</div><div class="line">  myMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// h will not be injected</span></div><div class="line">    <span class="keyword">return</span> &lt;div id="foo"&gt;bar&lt;/div&gt;</div><div class="line">  &#125;,</div><div class="line">  someOtherMethod: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// h will not be injected</span></div><div class="line">    <span class="keyword">return</span> &lt;div id="foo"&gt;bar&lt;/div&gt;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">@Component</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</div><div class="line">  get computed () &#123; <span class="comment">// h will be injected</span></div><div class="line">    <span class="keyword">return</span> &lt;div id="foo"&gt;bar&lt;/div&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中<code>h</code>就是<code>createElement</code>的别称，而且在jsx的话一般都是不用写的。所以这个函数注入的就有点迷了，不过根据亲测，在<code>methods</code>定义的函数是有<code>h</code>的，可能最后也会在<code>render</code>函数里调用吧。</p><p>后来我尝试两三个星期之后，我就放弃了classes形式的jsx写法，等过几天又有经历的时候再继续尝试。目前自己在用的两套写法：例如<code>Hyper</code>那种的classes形式的vue+ts，传统方式的jsx。</p><p>还有就是，对于vue来说，有时候要时常关心<code>h</code>函数有没有被注入，这是一件挺不愉快的事情的。比如说你写了一个渲染函数，然后运行的时候发现惨了凉了函数刚好在渲染范围之外（比如把函数直接分离出去，并不存在于<code>render</code>函数中），这是不运行的，那怎么做？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">h, args</span>) </span>&#123;&#125;</div></pre></td></tr></table></figure><p>就是这样的！必须在render函数中调用而且<code>h</code>必须是第一个参数！不然不是报错就是不渲染！</p><h3 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h3><p>可能是解决刚刚提到的“经常找不到自动注入函数”的困扰吧。多了一个这么个东西。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  functional: <span class="literal">true</span>,</div><div class="line">  </div><div class="line">  render() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一个关键词<code>functional</code>声明这个位置是个函数式组件。函数式可以直接看做一个能主动注入<code>h</code>的函数，因为它没有状态的，甚至是个RBQ，用完就丢（死无全尸，在组件树是看不到的，依托父组件生存）。同时最大的特点也就是可复用。想想<code>react</code>一个正常语法函数就能搞定的事情…</p><p>有利有弊，这种组件因为没状态，用过就丢，所以它需要的数据全靠传递。也就是单向数据，从父组件 -&gt; props -&gt; 处理 -&gt; 输出 -&gt; 销毁一条龙。很简单就是把它看做是<code>render</code>里面的一个函数就行，本意也是如此。</p><p>所以这种组件就两个接收参数：负责渲染的<code>h</code>，负责上下文<code>context</code>。各种所需的乱七八糟都在<code>context</code>中，比如全程最重要的<code>props</code>。而且多数组件的参数都有调整：</p><blockquote><ul><li><code>props</code>：提供 props 的对象</li><li><code>children</code>: VNode 子节点的数组</li><li><code>slots</code>: slots 对象</li><li><code>data</code>：传递给组件的 data 对象</li><li><code>parent</code>：对父组件的引用</li><li><code>listeners</code>: (2.3.0+) 一个包含了组件上所注册的 <code>v-on</code> 侦听器的对象。这只是一个指向 <code>data.on</code> 的别名。</li><li><code>injections</code>: (2.3.0+) 如果使用了 <a href="https://cn.vuejs.org/v2/api/#provide-inject" target="_blank" rel="external"><code>inject</code></a> 选项，则该对象包含了应当被注入的属性。</li></ul></blockquote><h3 id="JSX的一些小区别"><a href="#JSX的一些小区别" class="headerlink" title="JSX的一些小区别"></a>JSX的一些小区别</h3><p>因为我还没怎么体验过<code>react</code>，所以就只有一个关于dom书写的区别。在<code>react-jsx</code>中，<code>class</code>可是会被识别成关键词的，所以做样式的<code>class</code>要写成<code>className</code>，但在<code>vue-jsx</code>是不需要的。可能一开始这么做没想过后面竟然还有<code>class-component</code>的需求吧。</p><p><code>vue</code>现在大多奇技淫巧都是基于社区的各种<code>babel</code>插件，并不像<code>react</code>两个官方库皇帝级别支持，也不像<code>angular</code>自从诞生时期就声明“劳资要用TypeScript作为开发语言，你不用也得用ES6形式！”</p><p><code>vue-jsx</code>这种写法我现在也会用，搞点小的就直接这么写，而且这么做实际上思路会清晰一点——像在写一个应用而不是写一个网页，你只需要把dom相关的字段脑里想成一个字符串或者一个子函数就行了。（只是老遇到一些乱七八糟的问题）</p><p>（<code>angular</code>与<code>angular.js</code>至今还是两种东西，不要乱了）</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我说我是做外包的肯定没人信，给你看看外包程序员瞎几把搞的热情！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前排提醒：vue-jsx和react-jsx相差甚远，前者基本就是玩具生产链。很多想利用JS语言特性的骚套路基本上都不好实现，而且感觉奇奇怪怪的。所以你的生产环境，千万不要乱试vue-jsx这种搭配，够简单就无所谓了…&lt;/p&gt;
    
    </summary>
    
      <category term="实践尝试" scheme="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
      <category term="vue" scheme="https://colmugx.github.io/blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>扯扯柯里化</title>
    <link href="https://colmugx.github.io/blog/2017/12/07/about-currying/"/>
    <id>https://colmugx.github.io/blog/2017/12/07/about-currying/</id>
    <published>2017-12-07T13:17:31.000Z</published>
    <updated>2017-12-29T06:39:53.874Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在我的博客打开开发者工具 -&gt; console，输入 Nlvi.tools.scroll 试试？</p></blockquote><p>开个玩笑，我自己也不知道这算不算柯里化（逃</p><p>总之为什么这么写，我自己觉得这样容易理解，方便盲僧（理清）。</p><p>还有最近关于“如何治理别人爱装逼的毛病”系列中刚写的一坨，新鲜的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> menuItem = <span class="function">(<span class="params">list</span>) =&gt;</span> </div><div class="line">      list.map(<span class="function">(<span class="params">&#123;title, color, icon, descs&#125;</span>) =&gt;</span> </div><div class="line">        &lt;menu-item title=&#123;title&#125; color=&#123;color&#125; icon=&#123;icon&#125;&gt;&#123;</div><div class="line">          descs.map(<span class="function"><span class="params">v</span> =&gt;</span> &lt;span&gt;&#123;v&#125;&lt;<span class="regexp">/span&gt;)&#125;&lt;/m</span>enu-item&gt;)</div></pre></td></tr></table></figure><a id="more"></a><h2 id="柯里化是什么？"><a href="#柯里化是什么？" class="headerlink" title="柯里化是什么？"></a>柯里化是什么？</h2><p>好了讲柯里化，就是<strong>接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。柯里化属于函数式编程的内容</strong>。</p><p>在这里有一个<a href="http://www.zhangxinxu.com/wordpress/2013/02/js-currying/" target="_blank" rel="external">张鑫旭博客</a>讲关于柯里化（柯南嗑药）的例子，很方便理解。当然我想讲点自己的东西，拿<code>Nlvi.tools.scroll</code>说一下吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">tools.scroll = <span class="function"><span class="keyword">function</span> (<span class="params">win</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">    $(win).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> sct = $(win).scrollTop();</div><div class="line">      fn &amp;&amp; fn(sct);</div><div class="line">    &#125;);</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 实际上如果不作的话，这样就结束了</span></div><div class="line">tools.scroll = <span class="function"><span class="keyword">function</span>(<span class="params">win, fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> $(win).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sct = $(win).scrollTop();</div><div class="line">    fn&amp;&amp;fn(sct)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>所以函数柯里化看上去有一个特点，会嵌套函数。而且道理就跟柯里化的解释一样：用一些参数，剩下的函数作为返回值里的函数的参数。这样我在调用的时候怎么调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scrollTop = Nlvi.tools.scroll(<span class="built_in">window</span>);</div><div class="line">scrollTop(<span class="function"><span class="keyword">function</span>(<span class="params">sct</span>) </span>&#123;&#125;);</div></pre></td></tr></table></figure><p>首先我给个变量（实际上ES6直接用<code>const</code>，毕竟固定量）引用这个方法，方法传入第一个参数。接着里面的函数返回值函数是接收一个函数变量。</p><p>理一下，函数 - 的返回值 - 是个函数，这个函数接收一个 - 函数 - 的 - 变量。</p><p>然后这个函数参数传进去之后，实际上就是传一个方法进去以便于我等下里面的逻辑走完之后可以把这个函数参数运行起来，行程一个特别做作的回调函数。（当然回调函数带的是当前滚动条的数据）</p><p>为什么这么做呢？一点就是我觉得这样思路就清晰多了，而且在调用区域写起来干净。第二点就是参数复用。</p><p>虽然这个例子看不出什么，但是难免会遇到一些情况，就是明明一个变量或者一个参数，我只要取一次然后调用一次之后，剩下的内容我只要在这个情况之上去处理就行。但是如果传统单函数的做法的话，就会使得这个局外参数也跟着在里面做一些乱七八糟的运动，比如跟着去递归，被扯着去多次判断，这样就会莫名其妙浪费了一堆性能。很简单我举个例子：4x100，明明你交接之后剩下的就接下来的人跑就行了，你非得交接之后跟着跑，边跑边喊加油？</p><p>第三点就是延时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> total = <span class="number">0</span></div><div class="line"><span class="comment">// normal</span></div><div class="line"><span class="keyword">var</span> nSum = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</div><div class="line">  total += num</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//currying</span></div><div class="line"><span class="keyword">var</span> cSum = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">var</span> nums = []</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</div><div class="line">      <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, nums)</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">Array</span>.prototype.push.apply(nums, <span class="built_in">arguments</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sum = cSum(<span class="function">(<span class="params">x</span>) =&gt;</span> total += x)</div></pre></td></tr></table></figure><p>如果是常规的话，那么肯定会立刻计算出结果，而柯里化之后，会把计算的步骤储存起来，然后一起计算。</p><h2 id="柯里化误区"><a href="#柯里化误区" class="headerlink" title="柯里化误区"></a>柯里化误区</h2><p>在写这篇东西的时候，我关注到了一尊大神的博客 <a href="http://www.cnblogs.com/pengchen/p/5434705.html" target="_blank" rel="external">JavaScript函数柯里化的一些思考</a>，吓得我赶紧回看了自己的函数有没有“画蛇添足”的成分。嗯。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 拿下来继续学习一下</span></div><div class="line"><span class="keyword">var</span> scrollTop = Nlvi.tools.scroll(<span class="built_in">window</span>);</div><div class="line">scrollTop(<span class="function"><span class="keyword">function</span>(<span class="params">sct</span>) </span>&#123;&#125;);</div></pre></td></tr></table></figure><p>这里我想到的是，我只需要把<code>window</code>传到这个函数之后引用出一个新函数，然后我就可以带着这个函数跑了，如果是不嫌麻烦版本的话我需要则么做？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">tools.scroll = <span class="function"><span class="keyword">function</span>(<span class="params">win, fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> $(win).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sct = $(win).scrollTop();</div><div class="line">    fn&amp;&amp;fn(sct)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">// and so</span></div><div class="line">tools.scroll(<span class="built_in">window</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)</div></pre></td></tr></table></figure><p>这样就会造成，我每次想监听滚动的时候，每用一次这个方法，我就要把<code>window</code>传进去一次。如果包一下的话，我就可以拿后面那个函数走就行了，也就是我的<code>window</code>只要传一次就畅通无阻。这也是另一个好处：分段计算。好比我玩Switch，我在外面突然想玩马车的时候，如果我的卡带在卡包里，那我换上就可以玩了，就不需要等回到家把卡带从包装盒里拿出来装到机器上。</p><p>实际上到这里的话应该有所经验了，到这里还会不会觉得<code>apply(), call(), bind()</code>使用机会少之又少？这就是数学的魅力吧，可是我数学不好。</p><h2 id="柯里化-lt-gt-闭包函数？"><a href="#柯里化-lt-gt-闭包函数？" class="headerlink" title="柯里化 &lt; - &gt; 闭包函数？"></a>柯里化 &lt; - &gt; 闭包函数？</h2><p>又是每期一问了，柯里化跟闭包函数是否也有关系？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 经典面试题</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</div><div class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</div><div class="line">             setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">              <span class="built_in">console</span>.log(i);</div><div class="line">        &#125;,<span class="number">0</span>)</div><div class="line">    &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>那么，柯里化函数和闭包函数应该怎么区分？还是的确有联系？</p><p>最后感谢所有被引用的文章及其作者，感谢帮助学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在我的博客打开开发者工具 -&amp;gt; console，输入 Nlvi.tools.scroll 试试？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开个玩笑，我自己也不知道这算不算柯里化（逃&lt;/p&gt;
&lt;p&gt;总之为什么这么写，我自己觉得这样容易理解，方便盲僧（理清）。&lt;/p&gt;
&lt;p&gt;还有最近关于“如何治理别人爱装逼的毛病”系列中刚写的一坨，新鲜的：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; menuItem = &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;list&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      list.map(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;&amp;#123;title, color, icon, descs&amp;#125;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;lt;menu-item title=&amp;#123;title&amp;#125; color=&amp;#123;color&amp;#125; icon=&amp;#123;icon&amp;#125;&amp;gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          descs.map(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;v&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;lt;span&amp;gt;&amp;#123;v&amp;#125;&amp;lt;&lt;span class=&quot;regexp&quot;&gt;/span&amp;gt;)&amp;#125;&amp;lt;/m&lt;/span&gt;enu-item&amp;gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>你还在用Console.log()？</title>
    <link href="https://colmugx.github.io/blog/2017/11/20/js-console/"/>
    <id>https://colmugx.github.io/blog/2017/11/20/js-console/</id>
    <published>2017-11-20T10:06:13.000Z</published>
    <updated>2017-11-20T15:09:56.543Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>也许主题应该改为：你只会使用Console.log()？</p></blockquote><p>现在的前端虽说是越来越复杂，但是我怎么觉得现在前端的要求越来越低了？应该说现在的人，看个几遍vue，知道console.log()，知道var, {}, []，就敢出来找工作了。但是<code>console</code>就这么个方法？</p><p>搞笑，你在你的浏览器输入<code>console</code>，自己看看有多少东西！所以为了高效调试我觉得有必要全了解一遍。<br><a id="more"></a></p><h2 id="log-info-error-warn"><a href="#log-info-error-warn" class="headerlink" title="log(), info(), error(), warn()"></a>log(), info(), error(), warn()</h2><p>这几个放在一起讲</p><blockquote><p>log() 普通输出</p></blockquote><p>这是最普通，最常见，最没什么东西好讲的。输出的样式是普通样式。</p><blockquote><p>info() 提醒输出</p></blockquote><p>这是一个早期chrome才能看到的效果，现在的FireFox也能看到，是一个圆形中间一个叹号的标记。作提醒作用。chrome不是不会显示，是显示成普通样式。</p><blockquote><p>error() 错误输出</p></blockquote><p>这个应该跟<code>log()</code>同个使用数量级的，表示错误，大红颜色。chrome表现是一整行都是红色的，很显眼。用来显示错误信息。比如throw 错误之类的。如果一套都是<code>log()</code>的话肯定很难一眼看到错误。珍爱视力，路还长着…</p><blockquote><p>warn() 警告输出</p></blockquote><p>就是警告咯，可能用的比较少，但是工具类和一些库肯定会容易看到，原来跟<code>info()</code>平起平坐，现在应该是替代了。显示效果会显眼的黄色，chrome会有黄色背景。</p><blockquote><p>debug() 调试输出</p></blockquote><p>这个就是<code>log()</code>，用来输出调试信息的。不过现在的调试信息都在花式<code>log()</code>，也不需要用到这个了。</p><h2 id="exception-debug"><a href="#exception-debug" class="headerlink" title="_exception(), debug()"></a>_exception(), debug()</h2><p>这组只有两个，因为这两个没卵用…为什么…</p><blockquote><p>_exception() 例外输出</p></blockquote><p>说白了就是用来输出错误的，那错误不能用<code>error()</code>吗？！</p><blockquote><p>debug() 调试输出</p></blockquote><p>早期可能还有区别，但是这就是一个<code>log()</code>，不过现在各前端都在花式<code>log()</code>调试信息，可能也有些人<code>debug()</code>都没听说过。</p><h2 id="assert-…-clear-count"><a href="#assert-…-clear-count" class="headerlink" title="assert(…), clear(), count()"></a>assert(…), clear(), count()</h2><p>为什么第一个函数搞了三个点？</p><blockquote><p>assert() 断言输出：判断第一个参数是否为真，false的话抛出异常并且在控制台输出相应信息。——MDN</p></blockquote><p>从这里开始就要骚了，这是一个判断的方法，里面需要填写参数，然后得到返回值。如果值为真，就什么都不会发生，反之则以<code>error()</code>通知你。这是个多参数的，除了第一个参数之外，后面接的参数是被输出的对象也好，字符串也好，并且会拼接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.assert(<span class="number">1</span>&gt;<span class="number">2</span>, <span class="string">"你这么骚的？"</span>)</div><div class="line"></div><div class="line">Assertion failed: 你这么骚的？ <span class="comment">// 假装这里是红字红色背景</span></div></pre></td></tr></table></figure><blockquote><p>clear() 清空控制台</p></blockquote><p>就是把控制台全清空，terminal里面的<code>clear</code></p><blockquote><p>count() 次数输出：以参数为标识记录调用的次数，调用时在控制台打印标识以及调用次数。——MDN</p></blockquote><p>并且MDN明确指出，这个不应该列入正常使用范围，因为这是非标准方法。这是这组里最骚的方法。用来输出本身被调用了几次…虽然如果测试循环的话，一般都直接log(i)的，直接看1234567不是更明确嘛。显示效果就是，每运行一次就会在控制台打印 n + 1。</p><h2 id="dir-dirxml"><a href="#dir-dirxml" class="headerlink" title="dir(), dirxml()"></a>dir(), dirxml()</h2><p>这两个一起说是因为，有相同点和不同点。</p><blockquote><p>dir() 对象结构输出</p><p>dirxml() 节点结构输出</p></blockquote><p>这两个都是输出一个树状结构，就是前面有个小三角。但不同点就是，<code>dir()</code>是把一个对象按照对象的形式呈现，当然用来输出节点就是把节点信息按object呈现。<code>dirxml()</code>是把节点呈现出来，就还是保留xml的样式呈现。都是非标准，偶尔用用还行？</p><h2 id="group-groupCollapsed-groupEnd"><a href="#group-groupCollapsed-groupEnd" class="headerlink" title="group(), groupCollapsed(), groupEnd()"></a>group(), groupCollapsed(), groupEnd()</h2><p>这是上面那组的正房版。都是打印结构。我就不一行一行解释了有点累…</p><p>第二跟第一都是打印树状结构，但是第一个会自动打开显示结构里面有什么结构（没问题的），第二个叫内联树状，默认不打开。</p><p>而且只要你不结束，你可以一直联下去的，这样一个父节点可以一直续下去…直到通过<code>groupend()</code>来结束。</p><h2 id="table-…"><a href="#table-…" class="headerlink" title="table(…)"></a>table(…)</h2><p>我必须强调！<strong>这是最棒的我最喜欢的console方法，没有之一！</strong></p><blockquote><p>table() 表格输出</p></blockquote><p>这个方法必须传入内容，内容的类型是array或者object，输出的样式是一个key:value的表格！如果你觉得输出成对象不方便检查的话，那就用<code>table()</code>吧！（当然在表格下方还是会return一次对象或者数组）</p><p>而且不仅是key:value，<strong>你甚至还能多元数组！对象套对象！甚至是JSON！</strong></p><h2 id="另外的技巧就是可以用占位符了"><a href="#另外的技巧就是可以用占位符了" class="headerlink" title="另外的技巧就是可以用占位符了"></a>另外的技巧就是可以用占位符了</h2><p>跟C语言的<code>printf()</code>没有区别，就是可以利用占位符然后再把参数接在后面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"%d年%d月%d日"</span>,<span class="number">2017</span>,<span class="number">11</span>,<span class="number">20</span>)</div></pre></td></tr></table></figure><p>最后感谢MDN，也感谢AlphaGo！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;也许主题应该改为：你只会使用Console.log()？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在的前端虽说是越来越复杂，但是我怎么觉得现在前端的要求越来越低了？应该说现在的人，看个几遍vue，知道console.log()，知道var, {}, []，就敢出来找工作了。但是&lt;code&gt;console&lt;/code&gt;就这么个方法？&lt;/p&gt;
&lt;p&gt;搞笑，你在你的浏览器输入&lt;code&gt;console&lt;/code&gt;，自己看看有多少东西！所以为了高效调试我觉得有必要全了解一遍。&lt;br&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>引用等于指针吗？</title>
    <link href="https://colmugx.github.io/blog/2017/10/17/reference-equal-pointer/"/>
    <id>https://colmugx.github.io/blog/2017/10/17/reference-equal-pointer/</id>
    <published>2017-10-17T07:33:38.000Z</published>
    <updated>2017-10-17T14:22:18.853Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一篇思考文，关于JS的reference和Go的指针。（臆想型论文？）</p></blockquote><p>最近投入大量时间接触<code>Golang</code>，了解“指针”的时候，想起了以前学习C语言时对“指针”的疑问：指针是什么。</p><p>以前还小不理解指针和野指针，只知道野指针会出现内存溢出或者值不正确的情况。而且网上大多讲指针的文章看起来都很难。就像现在的知乎：一句话能说清楚的东西恨不得从它的诞生还是写起。就连LOL赛评也是这副P样。</p><p>以至于我后面对C语言没好感，对C++厌恶，对有“指针”的语言直接没兴趣。</p><p>在看到Go的指针的时候，我已经想放弃了。但是想回来，毕竟上一次接触指针已经6年了，也许现在看就能理解出什么呢。（过程中接触的OC根本不能算经验，因为当时完全就是靠抄靠背来写iOS应用，最后还是嫌弃OC麻烦进阶无法理解去学习了swift）<br><a id="more"></a></p><h2 id="Reference-Pointer"><a href="#Reference-Pointer" class="headerlink" title="Reference == Pointer?"></a>Reference == Pointer?</h2><p>以前看到什么内存地址啊，指向啊就已经乱了，满脑子都在想内存里面是什么样的，内存地址，寄存器又是什么东西。跟着官方教程走了一遍，了解到<strong>指针就是通过一个变量去指向一个有的变量或者说是对象，从而产生一种绑定。通过修改指针变量也可以达到修改本体的效果</strong>。</p><p>这让我想到JS，因为每天都在操作对象，知道：如果你要建立一个新的变量，比如<code>a = 1</code>，我可以通过<code>var b = a</code>得到一个新的变量。但是如果是对象则不是。如果是<code>a = {};  var b = a</code>的话，b只是单纯指向了a，并没有复制a</p><p>所以我立刻去搜索<em>关于JavaScript的指针</em>。得到这么一个结果 <a href="https://www.baidu.com/link?url=2Xxo3-ptdvabLARr0p-DcoBbeysd2lvRxH-jEevvWHBJ7pNBk-mkxGqaB6h8UTWVRi-2lc56zjWVMYPUgv6tfK&amp;wd=&amp;eqid=e1820c9600002f360000000659e5b92d" target="_blank" rel="external">JavaScript 的<em>指针</em>是什么? - 知乎</a></p><blockquote><p>JavaScript 里头什么时候有指针的概念？倒是有 reference （引用）的说法。 —— <a href="https://www.zhihu.com/people/sansmana" target="_blank" rel="external">陈木野</a></p></blockquote><p>关于this的总结，不单我自己，网络上已经大量的文章了。不管是详细解析，还是总结，都已经很多了。但是如果说：指针就是一种指向变量的话，那JavaScript就很多了，遍地都是。而这样的话，就跟reference有关系了。</p><p>说起来也是邪门了，今天打算把《红宝书》拿出来翻一下，翻到了第四章4.1.2，看到了这么一句</p><blockquote><p>当使用 num1 的值来初始化 num2 时，num2 中也保存了值 5。但 num2<br>中的 5 与 num1 中的 5 是完全独立的，该值只是 num1 中 5 的一个副本。</p><p>当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到<br>为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一<br>个对象。复制操作结束后，两个变量实际上将引用同一个对象。</p></blockquote><p>于是我的想法 “引用是一种指针” 或许成立。（复习有好处的！）</p><h2 id="Point-Reference"><a href="#Point-Reference" class="headerlink" title="Point == Reference"></a>Point == Reference</h2><p>如果反过来，还能成立吗？我觉得不行。</p><p>C++，让我很崇拜很信仰的，却因不理解和学不会让我产生厌恶的语言，在这方面是两者皆有。由于根本不懂所以不参加讨论。</p><p>Java，他也有reference，但是在<a href="https://www.baidu.com/link?url=bI4EsfOKw8lfPjTwX3_gY7pbn2LFMOwmFPmoalBBNr7lFCv9ZltHfuravfoA7uVHrNJtSUxm0Epjk-IW5Zr2z_&amp;wd=&amp;eqid=ee91ddc5000508bd0000000659e60253" target="_blank" rel="external">Java的<em>Reference</em>感觉很象C++的<em>指针</em>,但是区别是本质的 - f…_博客园</a> 提到：</p><blockquote><p>Java中你无法对这个地址进行任何数学运算，并且这个地址你不知道，是Java Runtime分配给你的，它随时还要调整这个地址（After GC,Memory要Compact，这时候一个Object Reference的地址就会改变）。</p></blockquote><p>我不是很理解，所以我也不敢评论什么。我只想关于Go和JS的东西。</p><p>也许是心理隔阂，也许是真理。我怎么都想不出怎么让“指针是一种引用”成立。</p><p>老是想内存内存，不如想成一个盒子，指针就是给盒子里的东西连了一条线。这样做就不用我找这个东西的时候去盒子里找，而是直接去找这条线？</p><p>可是在JS中，引用也不能修改和做任何运算吗？</p><h2 id="Reference-Pointer-1"><a href="#Reference-Pointer-1" class="headerlink" title="Reference === Pointer?"></a>Reference === Pointer?</h2><p>我不是语言专家，我一点都不敢保证。或者说我不懂。</p><p>我不知道所谓的指针是什么东西，但是我知道<code>reference</code>是一个<code>object</code>，毕竟不知道哪篇文章写道：函数是JavaScript第一公民。但并不是很纯的函数式编程语言。</p><p>其实思考到现在，我又有新的问题了：<strong>前端语言，或者说函数式编程语言，有没有内存，指针一说？</strong></p><p>不过现在可以知道的是：</p><p>​    在指令式编程中，数值就是数值，一切工作之后无非就是想得到一个值，过程中也在围绕着值。</p><p>​    在函数式编程中，函数还是占主要地位，它需要以数学的方式去解决编程的问题。</p><p>那我现在可不可以有一种新的理解：</p><p>​    比如C语言这种，他定义指针是需要 <code>*</code> 这种东西，也就是<code>int *a = b</code>是用a指针指向b，我可以通过a来修改b。但是如果直接<code>int a = b</code>的话，我就相当于复制了这个变量了，没权修改b变量了。而如果<code>int a</code>是一个函数的话，那它最后也需要返回一个<code>int</code>返回值。所以它并没有“用函数搞事”的权利。</p><p>​    而JS语言这种，我想用一个代码框来写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 还是根据红宝书的例子</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b = a;<span class="comment">// 一种复制，相互独立</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> x = &#123;<span class="attr">a</span>: <span class="number">5</span>&#125;</div><div class="line"><span class="keyword">var</span> y = x<span class="comment">// 一种引用，实际上操作y的时候还是在操作x</span></div><div class="line"></div><div class="line"><span class="comment">//现在暂时借用一下以 _ 代替*</span></div><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">5</span> &#125;</div><div class="line"><span class="keyword">var</span> _b = o.a<span class="comment">// 达到继承的目的？</span></div><div class="line"></div><div class="line"><span class="comment">// var _b = int *b   在某种意义上？</span></div></pre></td></tr></table></figure><p>在红宝书接下来有一句：</p><blockquote><p>换句话说，obj1和 obj2 都指向同一个对象。这样，当为 obj1 添加 name 属性后，可以通过 obj2 来访问这个属性，<br>因为这两个变量引用的都是同一个对象。</p></blockquote><p>按我的角度翻译一下，就是：<strong>我定义一个b出来，无非就是给a多了一个出口</strong></p><p>所以综上所述，我认为，对我来说，或者对C系除外的语言来说，<strong>把“指针”说成“指向”，或许让人更好理解。</strong></p><p>哼，计算机真是有趣。</p><p>（最后感谢所有被引用的文章和作者，谢谢。）</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一篇思考文，关于JS的reference和Go的指针。（臆想型论文？）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近投入大量时间接触&lt;code&gt;Golang&lt;/code&gt;，了解“指针”的时候，想起了以前学习C语言时对“指针”的疑问：指针是什么。&lt;/p&gt;
&lt;p&gt;以前还小不理解指针和野指针，只知道野指针会出现内存溢出或者值不正确的情况。而且网上大多讲指针的文章看起来都很难。就像现在的知乎：一句话能说清楚的东西恨不得从它的诞生还是写起。就连LOL赛评也是这副P样。&lt;/p&gt;
&lt;p&gt;以至于我后面对C语言没好感，对C++厌恶，对有“指针”的语言直接没兴趣。&lt;/p&gt;
&lt;p&gt;在看到Go的指针的时候，我已经想放弃了。但是想回来，毕竟上一次接触指针已经6年了，也许现在看就能理解出什么呢。（过程中接触的OC根本不能算经验，因为当时完全就是靠抄靠背来写iOS应用，最后还是嫌弃OC麻烦进阶无法理解去学习了swift）&lt;br&gt;
    
    </summary>
    
      <category term="编程议论" scheme="https://colmugx.github.io/blog/categories/%E7%BC%96%E7%A8%8B%E8%AE%AE%E8%AE%BA/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>总有一天我会死在骚操作上…</title>
    <link href="https://colmugx.github.io/blog/2017/10/09/diary-vue-jsx/"/>
    <id>https://colmugx.github.io/blog/2017/10/09/diary-vue-jsx/</id>
    <published>2017-10-09T07:22:07.000Z</published>
    <updated>2017-10-09T07:37:57.498Z</updated>
    
    <content type="html"><![CDATA[<p>得考虑去弄个图床，滥用github不太好。</p><p><img src="https://github.com/ColMugX/GitBed/raw/master/diary/vue-render1.png" alt=""></p><p><img src="https://github.com/ColMugX/GitBed/raw/master/diary/vue-render2.png" alt=""></p><p><img src="https://github.com/ColMugX/GitBed/raw/master/diary/vue-render3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;得考虑去弄个图床，滥用github不太好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/ColMugX/GitBed/raw/master/diary/vue-render1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https
      
    
    </summary>
    
      <category term="毫无意义" scheme="https://colmugx.github.io/blog/categories/%E6%AF%AB%E6%97%A0%E6%84%8F%E4%B9%89/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
      <category term="vue" scheme="https://colmugx.github.io/blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>使用桌面应用写hexo博客是什么体验？</title>
    <link href="https://colmugx.github.io/blog/2017/09/19/what-the-feeling-about-hyper/"/>
    <id>https://colmugx.github.io/blog/2017/09/19/what-the-feeling-about-hyper/</id>
    <published>2017-09-19T05:02:01.000Z</published>
    <updated>2017-11-20T10:08:01.059Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>稳的稳的，这次真是为了需求造轮子了。Hyper = Hexo + Typer. </p></blockquote><p>接触到hexo是因为，hexo可以是一个前端博客生成器，直接生成一个前端静态页面，做到可以上传到github“个人页面”作为博客网站。</p><p>不过，毕竟是基于<code>node</code>的生成器，编写过程很geek。首先创建和预览甚至发布，依赖<code>terminal</code>和<code>node</code>。你要使用一个你喜欢的<code>markdown</code>编辑器，或者直接就在代码编辑器搞例如<code>vscode</code>。原来我也是用这个写博客。因为自带了<code>terminal</code>，直接创建了搞完直接上。后来生活逐渐好点，用的 iterm2 + zsh 之后，编辑器改用了<code>Typora</code>。然而关于这段的话，我上一篇<a href="http://blog.co1mugx.tk/2017/08/22/do-markdown-hexo/" target="_blank" rel="external">搞electron+vue+webpack2+TypeScript什么体验</a> 已经讲得够多了，所以不赘述了。</p><p>但是现在，可能生活会更好了…</p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/1.png" alt=""></p><a id="more"></a><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><p>这是个<code>electron</code> + <code>Typescript</code> + <code>vue</code>的产物。也就是首先它是桌面应用了，由于<code>electron</code>意味着它可能可以跨平台。不过我没有想过…所以现在是 MacOS 版本。</p><p>为什么想起写这个，原因就两点</p><ul><li>原来的方式太过于繁琐，甚至感觉不到自己是在写博客。</li><li>对计算机理解和操作都不是顺畅的人会带来很多麻烦。</li></ul><p>博客博客，文字记录自己的生活或者技术探讨。多少写手或者说喜欢分享的人，喜欢hexo又不会用没办法用。当分享被技术限制之后，那么写文章也就不是专注于文章了。（比如我写文章也一直很跳，跟性格有关吧）</p><p>所以我才想要实现这么个东西，实际上在早之前就已经打算了，当时前端太菜。也不知道<code>electron</code>是什么东西。还是个<code>swift</code>新教徒的时候。有想过用MacOS 原生的方式去做这个东西，后来放弃了，原因还是因为技术上的问题。</p><p>这次实现这个东西的时候，巧了，跟<a href="http://www.ahonn.me" target="_blank" rel="external">@Ahonn</a>几乎不约而同的想到了一起。他也说他很早就想做了，不过大神不是因为技术原因，而是开坑不填工期延后…</p><p>不过他的实现方式是不同的，他想使用<code>cljs</code>去实现这个东西。我为了求稳，还有还是熟悉一下<code>TypeScript</code>作为脚本使用的感觉，用了这么套技术栈。</p><p>Ahonn的项目地址是这个：<a href="https://github.com/ahonn/hexdit" target="_blank" rel="external">ahonn / hexdit</a>。利益相关的话：还是算关系挺好的校友吧…</p><h2 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h2><p>不搞事情，不吹牛逼，这次为了 <del>装逼</del> 测试一下软件大概“正常使用”有没有什么问题。所以这次我这篇文章完完全全使用<code>Hyper</code>创建、编写、保存、修改，甚至我等下生成发布也直接用这个。</p><p>确实，这才像在写博客。</p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/2.png" alt=""></p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/7.png" alt=""></p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/9.png" alt=""></p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/10.png" alt=""></p><p>我甚至都不怕被你看！</p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/5.png" alt=""></p><p>（因为编辑器的样式还有预览的样式还没上，所以现在看起来还是很丑的，不过测试功能嘛，我等下还会用其他编辑器看）</p><p>但不管怎么说！就是好看！<strong>简就是美！甚至还有点少女心！</strong></p><p>在首屏直接载入<strong>整个博客程序文件夹</strong>之后，就会到达这个界面，左边是显示你当前博客程序里面的文章（名字我都不怕给你看，这名字最后会显示到网址上！），文章列表上面三个按钮分别是 “创建”，“预览”，“生成/发布”。每一个文章名称前面一个“绿色的勾”是提醒你，当前这篇文章是可见的。没错文章可以是隐藏的，这在<code>hexo</code>的文档上有提到，<code>source</code>文件夹中不会上传文件名前带’_’的文件。所以自然可以过滤“草稿”和“不想发布”的文章。所以隐藏的文章会显示一个红色的叉。</p><p>点击想编辑的文章之后，其实会有动画回馈，但是不会常驻高亮。然后右边会跳出目前文章的内容以及一些编辑文章会用到的功能。实际上我应该做一个当前编辑文件高亮的！</p><p>右边编辑区中第一个“笔样子”的图标我是放着玩的…一些测试的工作会挂在上面当starter。然后保存和删除这个应该能看懂。右边有个开关，这个开关就是作为<strong>“选择当前文章是否隐藏”</strong>的作用。当然如果是<code>off</code>状态的话就是显示了，默认也是显示的。最右边的“X”就是关闭当前编辑区咯。</p><p>下面一整个编辑区，写文章可以用，不过<code>markdown</code>了，应该熟悉的是不会用到的吧，可能会用到两个功能：一个是全屏编辑，一个是分屏编辑。噢插入表格也可以有，<code>markdown</code>的表格真是蛋疼。</p><h3 id="另外还给对hexo不熟悉的写手准备了一个大功能。"><a href="#另外还给对hexo不熟悉的写手准备了一个大功能。" class="headerlink" title="另外还给对hexo不熟悉的写手准备了一个大功能。"></a>另外还给对hexo不熟悉的写手准备了一个大功能。</h3><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/3.png" alt=""></p><p>那就是简易设置了！漂不漂亮我不敢说！反正我就喜欢清静的感觉，看看<code>Nlvi</code>！是不是还有一股禅意！</p><p>截图的信息是我在做测试的时候，我当前导入的是当时用来测试主题功能的一个示例博客，官方提供的。毕竟不敢把自己的博客导入进去，万一弄瞎了不就真瞎了…</p><p>就我遇到的很多情况看，还是会有刚接触前端或者刚接触hexo的人不知道hexo的配置文件应该是怎么弄的。虽然我在<a href="https://github.com/ColMugX/hexo-theme-Nlvi" target="_blank" rel="external">hexo-theme-Nlvi</a>里面写到：如果主题有使用问题的话，你可以提ISSUE，或者直接到知乎上锤我！</p><p>但事实上，很多给我知乎发私信的同学，问的都基本不是主题使用的问题，反而是博客本身的使用问题。所以我重新整理了博客配置文件，并把一些比较重要的，必须要的功能作为一张设置界面出来，这样就方便使用了。只要这张填的满，按道理说博客的显示和发布就没问题了。</p><p>而且这张设置界面就这么多内容，在地址设置下面也就多了一个“文章代码是否高亮”和“部署地址”。这样而已。然后就可以保存完事。</p><p>由于还是在测试和进一步编写。所以一些难看的目前用不到的我都<code>display:none</code>了，所以看不到完整设置。</p><p>初来乍到，第一次写这种软件，还是有很多问题的。如果你看到问题了还希望你能帮我指正。我也是想服务一下社区，给喜欢但是不会用的人一点帮助。</p><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>其实介绍文章按正常来说到上面就结束了。这也是为什么 “是什么 -&gt; 为什么 -&gt; 怎么做”反而是这种顺序。</p><p>关于是什么，应该很多人都不愿意去关心了，这里是我想记录的一些心得和学习遇到的坑。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;稳的稳的，这次真是为了需求造轮子了。Hyper = Hexo + Typer. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接触到hexo是因为，hexo可以是一个前端博客生成器，直接生成一个前端静态页面，做到可以上传到github“个人页面”作为博客网站。&lt;/p&gt;
&lt;p&gt;不过，毕竟是基于&lt;code&gt;node&lt;/code&gt;的生成器，编写过程很geek。首先创建和预览甚至发布，依赖&lt;code&gt;terminal&lt;/code&gt;和&lt;code&gt;node&lt;/code&gt;。你要使用一个你喜欢的&lt;code&gt;markdown&lt;/code&gt;编辑器，或者直接就在代码编辑器搞例如&lt;code&gt;vscode&lt;/code&gt;。原来我也是用这个写博客。因为自带了&lt;code&gt;terminal&lt;/code&gt;，直接创建了搞完直接上。后来生活逐渐好点，用的 iterm2 + zsh 之后，编辑器改用了&lt;code&gt;Typora&lt;/code&gt;。然而关于这段的话，我上一篇&lt;a href=&quot;http://blog.co1mugx.tk/2017/08/22/do-markdown-hexo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;搞electron+vue+webpack2+TypeScript什么体验&lt;/a&gt; 已经讲得够多了，所以不赘述了。&lt;/p&gt;
&lt;p&gt;但是现在，可能生活会更好了…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/ColMugX/GitBed/raw/master/hyper/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="实践尝试" scheme="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="electron" scheme="https://colmugx.github.io/blog/tags/electron/"/>
    
      <category term="TypeScript" scheme="https://colmugx.github.io/blog/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>构建一个简单前端开发环境</title>
    <link href="https://colmugx.github.io/blog/2017/08/31/create-fe-env/"/>
    <id>https://colmugx.github.io/blog/2017/08/31/create-fe-env/</id>
    <published>2017-08-31T10:12:20.000Z</published>
    <updated>2017-12-28T10:22:09.331Z</updated>
    
    <content type="html"><![CDATA[<p>虽然<code>webpack</code>在如今这个时代已经众所周知了。但是有些时候只是想简单涂涂画画，没必要很工程化。而且配一个<code>webpack</code>在“玩具”看来肯定是麻烦的。</p><p>这两天刚好想只写一点简单页面，不需要复杂的工程逻辑也不需要组件化（好吧实际上也组件化了），所以记录一下 <strong>一个简单页面开发环境是怎样的</strong><br><a id="more"></a></p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>不想用<code>webpack</code>的时候，第一个先想到的就是<code>gulp</code>。所以构建开发环境的打包工具就用这个了，其他就肯定是插件了。所以<strong>我的</strong>列表大概就如下</p><ul><li>gulp</li><li>gulp-autoprefixer</li><li>gulp-babel (option)</li><li>babel-core (option)</li><li>gulp-browserify (option)</li><li>gulp-concat (option)</li><li>gulp-minify-css (option)</li><li>gulp-nunjucks (option)</li><li>gulp-rename (option)</li><li>gulp-stylus (option)</li></ul><p>除了前三个，下面哪些都是可选的。接下来再讲讲为什么选这些东西。</p><h2 id="关于HTML的处理"><a href="#关于HTML的处理" class="headerlink" title="关于HTML的处理"></a>关于HTML的处理</h2><p>模板的话我选择的是<code>nunjucks</code>，业界毒瘤<code>mozilla</code>的产品。这是一个极其强大又简单的模板。选择它是因为它的基本语法都跟我用的<code>swig</code>是一样的。不过<code>swig</code>已经停止维护很久了，但是我对一些操作又比较熟悉。所以选择了它。另外一点是，<code>njk</code>是很自由的，它并没有要求你的后缀是怎样的。所以我一直使用<code>*.html</code>来命名。</p><p>所以自然需要用到<code>gulp-nunjucks</code>。最简单的处理方法是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gulp.src(<span class="string">'template/index.html'</span>)</div><div class="line">      .pipe(nunjucks.compile(json))</div><div class="line">      .pipe(gulp.dest(<span class="string">'dist'</span>))</div></pre></td></tr></table></figure><p>这里我还用到了<code>js-yaml</code>，因为我自己搞事的时候会更偏向用<code>yaml</code>来代替<code>json</code>。我觉得没有括号看起来确实要清晰一些。</p><p>实际上如果你的动态的内容是<code>json</code>格式的话，这里就结束了。插件会直接自动的把内容填进去然后生成结束。不过我的话，就会多了一步：把<code>yml</code>读成<code>json</code>然后再推进去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yaml.safeLoad(fs.readFileSync(<span class="string">'_config.yml'</span>, <span class="string">'utf8'</span>))</div></pre></td></tr></table></figure><p>同步读出<code>yml</code>文件的内容进行翻译，然后再把得到的<code>json</code>传入模板进行合并。</p><h2 id="关于CSS的处理"><a href="#关于CSS的处理" class="headerlink" title="关于CSS的处理"></a>关于CSS的处理</h2><p>我只愿意使用<code>stylus</code>，原因很简单就是不喜欢另外两个…<code>less</code>实现一个<code>mixin</code>很麻烦又不好理解，而且相对于<code>sass</code>和<code>stylus</code>少了函数的内容，所以<code>less</code>本质上还是在写<code>css</code>，没有更方便的做法。</p><p>而不用<code>sass</code>的原因更扯淡了——<code>ruby</code>实现的产物不用，虽然还有一个<code>scss</code>，而且从功能或者“文法”与<code>stylus</code>接近的，至少一个思路。但<code>stylus</code>更像<code>javascript</code>，很多操作和定义你可以按照你的<code>javascript</code>感觉来走。</p><p>然后就是兼容性补全，我直接用gulp的组件<code>gulp-autoprefixer</code>了，以简单为主，所以不考虑<code>postcss</code>。</p><p>另外就是习惯问题了，我会习惯压缩掉，<code>gulp-minify-css</code>用来压缩，顺便用<code>gulp-rename</code>加上<code>.min</code>的后缀</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'style'</span>, () =&gt; &#123;</div><div class="line">  gulp.src(<span class="string">'styles/style.styl'</span>)</div><div class="line">      .pipe(concat(<span class="string">'style.styl'</span>))</div><div class="line">      .pipe(stylus())</div><div class="line">      .pipe(autoprefixer(&#123;</div><div class="line">        browsers: [</div><div class="line">          <span class="string">'last 2 version'</span>,</div><div class="line">          <span class="string">'iOS &gt;= 7'</span>,<span class="string">'Android &gt;= 4.0'</span></div><div class="line">        ],</div><div class="line">        cascade: <span class="literal">true</span></div><div class="line">      &#125;))</div><div class="line">      .pipe(rename(&#123;<span class="attr">suffix</span>: <span class="string">'.min'</span>&#125;))</div><div class="line">      .pipe(minicss())</div><div class="line">      .pipe(gulp.dest(<span class="string">'dist/style'</span>))</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2 id="关于JS的处理"><a href="#关于JS的处理" class="headerlink" title="关于JS的处理"></a>关于JS的处理</h2><p>我会有两种做法，一种用到<code>browserify</code>，不过既然用到这个东西的话为什么不用<code>webpack</code>呢…</p><p>另一种是用<code>babel</code>，因为现在就算新司机也直接接触了ES6，习惯了的话，难免会写出一些非ES5语法的东西出来。虽然现在的现代浏览器基本都支持ES6（部分P/A+了），但是目前的话还是转一下比较保险。</p><h2 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h2><p>附加题：用的是<code>browsersync</code>，它并不是<code>gulp</code>的插件，但是可以搭配使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然&lt;code&gt;webpack&lt;/code&gt;在如今这个时代已经众所周知了。但是有些时候只是想简单涂涂画画，没必要很工程化。而且配一个&lt;code&gt;webpack&lt;/code&gt;在“玩具”看来肯定是麻烦的。&lt;/p&gt;
&lt;p&gt;这两天刚好想只写一点简单页面，不需要复杂的工程逻辑也不需要组件化（好吧实际上也组件化了），所以记录一下 &lt;strong&gt;一个简单页面开发环境是怎样的&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="实践尝试" scheme="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>搞electron + vue + webpack2 + TypeScript什么体验</title>
    <link href="https://colmugx.github.io/blog/2017/08/22/do-markdown-hexo/"/>
    <id>https://colmugx.github.io/blog/2017/08/22/do-markdown-hexo/</id>
    <published>2017-08-21T16:12:56.000Z</published>
    <updated>2017-12-07T02:26:50.637Z</updated>
    
    <content type="html"><![CDATA[<p>本来是想放弃的，后来歪打正着，成功运行。最后搞一个ts类型的启动器，不想再懵了。</p><p><a href="https://github.com/ColMugX/vue-ts-electron-starter" target="_blank" rel="external">vue-ts-electron-starter</a></p><p>想看看原项目<code>electron-vue</code>有没有这个打算，没有的话自己fork个分支出来。这个将就。</p><p>这次搞这个项目目的就很明显了，想做一个Hexo博客的编辑器（没错就是我这个博客的核心）。Hexo的话，属于页面生成器类的博客系统。直接一套生成静态页面，然后随意访问。因为一整套静态页面故还是有人喜欢直接干一套SPA上去，体验也好。</p><p>其实搞这个，我去年就想搞了。可是去年的话，明显前端的技术都不扎实更别说搞了，当时的想法是写一个Mac App（我swift应该还行，随便写写问题不大。不过可能现在的话问题就大了）。不过就一直拖拖拖，导致swift3.0都有苗头了我还是没想写。而且关于如何操作terminal命令，还是个问题。</p><p>这次心就大了。搞了再说，搞一半不行了就让他荒了。以后想起来再搞，再搞的时候技术肯定又上涨。如果这波做成了，开源，我不管有没有人用，总有人喜欢用。<br><a id="more"></a></p><h2 id="讲在前面"><a href="#讲在前面" class="headerlink" title="讲在前面"></a>讲在前面</h2><p>在这之前我用的是<a href="https://github.com/CodeFalling/blog-admin" target="_blank" rel="external">CodeFalling / blog-admin</a>。这是一个Emacs的插件，当然spacemacs也能弄来用一下。这是一个在github很活跃的大神写的（我经常看到，同时也是hexojs成员），也是很出名的Emacs教徒。不过据说他现在用的是webstorm + vim插件了…</p><p>当然今天不想吹Emacs，而且工作上我也不敢用Emacs，原因不说。</p><p>其实就是一直想做一个方便用一点的。在emacs之前我都是开一个terminal+一个编辑器来做的。在emacs之前是用<code>typora</code>和<code>vscode</code>做的。总这样不好吧太麻烦了。而且这东西又算刚需…所以算了，还是尝试一下吧，顺便把<code>electron</code>和<code>vuex</code>给学清楚了，而且顺便练一下<code>TypeScript</code>。</p><p>所以这次打算的技术选型是：</p><ul><li>TypeScript</li><li>electron</li><li>vue</li><li>vuex</li></ul><p>electron + vue环境的话，直接使用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="external">SimulatedGREG/<em>electron-vue</em></a>，这样<code>electron</code>，<code>vue</code>，<code>webpack</code>就都完成了。如果针对<code>TypeScript</code>的话<code>webpack</code>应该要小改一下。</p><h2 id="为什么使用TypeScript"><a href="#为什么使用TypeScript" class="headerlink" title="为什么使用TypeScript"></a>为什么使用TypeScript</h2><p>TypeScript是微软开发的语言，由于师出同门所以跟<code>C#</code>的语法是极其像的，不过由于是<code>JavaScript</code>的超类，所以还会考虑到ES的语法。所以很早的时候<code>ES6</code>还没流行起来的时候，<code>TypeScript</code>已经开始使用像ES6一样的语法，并提供编译把TS的代码编译成ES5的代码，在没有<code>es6</code>和<code>babel</code>的世界，需要用JS来创造更强大的程序无疑是福音。</p><p>一开始看到的时候，我觉得JS也就那样了，还能怎样…到后来去接触的原因，是因为它的语法跟我先接触的<code>swift</code>很像，我觉得可能能通过TS学好swift或者说通过对swift的理解去学TS，反正都能编译成JS的嘛。</p><p>再后来就遇到了游戏，接触Unity3D的时候，最热门最成熟的语言是C#，而我当时是个软黑。转而让我发现了Egret，Egret竟然把TS作为开发语言，我就想要不把TS也弄清楚了，以后如果接触C#可能也不会太难。可是经过几轮跌爬滚打之后，我竟然放弃了…对这就是我小时候的不懂事…大学快毕业的时候几乎每天就在后悔，为什么当时不好好学TS，而在ES6789流行开的时代里，语法完整功能完善的TS优势也没有那么大了。现在浏览器都能直接用ES7了…</p><p>但是现在说没优势都是骗人的…如果你只是单纯用JS写的话，一如果出现类型错误，不好控制。二在万物都是函数的世界中，可能如果要实现一些其他功能，可能会考虑不周。即使能考虑到了，写上去。也会造成很大的工作量。但是TS编译器都替我们想好和做好了，为什么不去用？</p><p>所以，如果是应用开发的话，为什么不考虑应用级别的开发语言呢？我是这么想的。</p><p>如果是web，但是要强大的框架比如vue，reactjs，我会选择用JS。如果是需要更强大的能力和稳定、可控的app，我肯定是选择TS。</p><h2 id="干！填坑！"><a href="#干！填坑！" class="headerlink" title="干！填坑！"></a>干！填坑！</h2><p>两点核心</p><ul><li><code>webpack</code>需要配置对<code>TypeScript</code>的编译。</li><li>从入口到组件都使用<code>TypeScript</code></li></ul><p>因为我也是误打误撞突然可以正常运行，所以我是开一个新的项目进行接下来的工作。 （结果发现并不是误打误撞，而是本来就是正确的，那么为什么会错误…）</p><p>首先npm安装<code>typescript</code>, <code>ts-loader</code>, <code>vue-class-component</code>，这三个都很重要。<code>typescript</code>提供的是语言支持，也可以说是提供内部编译，当然如果说你本身就全局装过了，那么你直接<code>link</code>就行了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">npm i -S typescript ts-loader vue-class-component</div><div class="line"></div><div class="line"><span class="comment"># or</span></div><div class="line">npm i -S ts-loader vue-class-component</div><div class="line">npm link typescript</div></pre></td></tr></table></figure><p>然后是<code>webpack.renderer.config.js</code>，不出意外的话在<code>25:3</code>入口，<code>26:58</code>把<code>js</code>改成<code>ts</code>，下面的rule添加对ts的支持</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">test: <span class="regexp">/\.ts$/</span>,</div><div class="line">loader: <span class="string">'ts-loader'</span>,</div><div class="line">exclude: <span class="regexp">/node_modules|vue\/src/</span>,</div><div class="line"> options: &#123;</div><div class="line">appendTsSuffixTo: [<span class="regexp">/\.vue$/</span>]</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果有需要<code>tslint</code>的话（说实话我还不会用…而且我觉得ts约束本来就很厉害了），需要安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i -S tslint tslint-loader</div></pre></td></tr></table></figure><p>老位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">test: <span class="regexp">/\.(ts)$/</span>,</div><div class="line">enforce: <span class="string">'pre'</span>,</div><div class="line">exclude: <span class="regexp">/node_modules/</span>,</div><div class="line">use: &#123;</div><div class="line">loader: <span class="string">'tslint-loader'</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第二，就是把关于<code>vue</code>部分的入口改成<code>main.ts</code>。这样接近完成。</p><p>第三，最重要的，<code>typescript</code>能不能用就靠这个了，<code>jsconfig.json</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tsc --init<span class="comment">#通过tsc初始化得到</span></div></pre></td></tr></table></figure><p>至于怎么配置，<code>vue</code>官方也给了一个推荐配置，<code>vue-class-component</code>也给了一个。</p><p>但不管怎样，建议把<code>allowjs</code>打开了，可以调用<code>js</code>文件。</p><h3 id="开始填坑"><a href="#开始填坑" class="headerlink" title="开始填坑"></a>开始填坑</h3><ul><li>入口必须是<code>.ts</code></li></ul><p>这点说起来很坑，TS的话，只要有<code>allowjs</code>就可以调用JS文件，运行是没问题的。但是反过来就不行了，毕竟超类能认，但JS根本不知道TS是个什么鬼，所以无法编译</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Module build failed: Error: Could not find file: <span class="string">'...*.ts'</span> </div><div class="line"></div><div class="line"><span class="comment"># 或者</span></div><div class="line">Module build failed: Error: Could not find file: <span class="string">'...*.vue'</span></div></pre></td></tr></table></figure><p>所以必须是TS入口</p><ul><li>建议关于<code>script</code>部分分开写。</li></ul><p>当然是可以直接在<code>.vue</code>写你的逻辑的，不过为了防止<code>typescript</code>有小脾气，或者关于类型推断，总的来说就是为了编译少点麻烦吧，我觉得还是分开写是最保险的。当然在组件内写也不是不可以。</p><ul><li><code>vue-class-component</code>核心</li></ul><p>如果用了TS的话，那么漂亮的组件代码肯定就是<code>class</code>了，通过修饰<code>@component</code>声明该位置是一个组件，然后开始写组件代码，继承自<code>vue</code>，然后就可以像写一个程序类一样去写这部分组件。看起来是相当漂亮的。举个例子，在通过<code>electron-vue</code>创建出来的工程中，对实例组件<code>LandingPage.vue</code>进行改写</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">  name: <span class="string">'landing-page'</span>,</div><div class="line">  components: &#123;</div><div class="line">    SystemInformation</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> LandingPage <span class="keyword">extends</span> Vue &#123;</div><div class="line">  open (link) &#123;</div><div class="line">    (<span class="keyword">this</span> <span class="keyword">as</span> <span class="built_in">any</span>).$electron.shell.openExternal(link)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>漂亮，清晰。（当然复杂一点，就复杂了！）</p><ul><li>关于对Vue进行扩展</li></ul><p>在添加<code>axios</code>的时候我遇到了问题：无法扩展<code>Vue</code>，原因好像是无法推断<code>vue</code> 的类型。这个问题的话，我还得去研究一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来是想放弃的，后来歪打正着，成功运行。最后搞一个ts类型的启动器，不想再懵了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ColMugX/vue-ts-electron-starter&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vue-ts-electron-starter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;想看看原项目&lt;code&gt;electron-vue&lt;/code&gt;有没有这个打算，没有的话自己fork个分支出来。这个将就。&lt;/p&gt;
&lt;p&gt;这次搞这个项目目的就很明显了，想做一个Hexo博客的编辑器（没错就是我这个博客的核心）。Hexo的话，属于页面生成器类的博客系统。直接一套生成静态页面，然后随意访问。因为一整套静态页面故还是有人喜欢直接干一套SPA上去，体验也好。&lt;/p&gt;
&lt;p&gt;其实搞这个，我去年就想搞了。可是去年的话，明显前端的技术都不扎实更别说搞了，当时的想法是写一个Mac App（我swift应该还行，随便写写问题不大。不过可能现在的话问题就大了）。不过就一直拖拖拖，导致swift3.0都有苗头了我还是没想写。而且关于如何操作terminal命令，还是个问题。&lt;/p&gt;
&lt;p&gt;这次心就大了。搞了再说，搞一半不行了就让他荒了。以后想起来再搞，再搞的时候技术肯定又上涨。如果这波做成了，开源，我不管有没有人用，总有人喜欢用。&lt;br&gt;
    
    </summary>
    
      <category term="实践尝试" scheme="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="vue" scheme="https://colmugx.github.io/blog/tags/vue/"/>
    
      <category term="electron" scheme="https://colmugx.github.io/blog/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的call()，bind()，apply()</title>
    <link href="https://colmugx.github.io/blog/2017/08/14/js-call-apply-bind/"/>
    <id>https://colmugx.github.io/blog/2017/08/14/js-call-apply-bind/</id>
    <published>2017-08-14T04:26:44.000Z</published>
    <updated>2017-11-20T10:07:03.112Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>联动水文，大约半年前记录了Javascript的this。顺水推舟理一下call()，bind()，apply()</p></blockquote><p>扩展阅读：<a href="https://colmugx.github.io/PersonalBlog/2017/03/03/js-this/">关于JavaScript的this</a></p><p>还是上次的代码，修改一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> test = obj.getName</div><div class="line">test()<span class="comment">//undefined.</span></div></pre></td></tr></table></figure><p>（敲黑板！）复习一下！为什么就<code>undefined</code>了！原因就是，<code>this</code>指向不同了。那么直接运行是否可以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">obj.getName()<span class="comment">//koala</span></div></pre></td></tr></table></figure><a id="more"></a><p>因为有时候并没办法这么自由的随便调用，那如果要搞个变量出来用，怎么做？</p><h2 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h2><blockquote><p><strong>call</strong></p><ul><li>vi. 呼叫；拜访；叫牌</li><li>vt. 呼叫；称呼；召集</li><li>n. 电话；呼叫；要求；访问</li><li>n. (Call)人名；(瑞典、罗)卡尔；(英)考尔<br>以上来自有道翻译</li></ul></blockquote><p>有一手有道翻译就方便了，就是call（叫）它，把要用的方法call（叫）出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> cal = obj.getName<span class="comment">//先定义出来</span></div><div class="line">cal.call(obj)<span class="comment">//koala   （指向还给他，不动其他把它叫出来</span></div></pre></td></tr></table></figure><h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h2><blockquote><p><strong>apply</strong></p><ul><li>v.应用；使用；涂；敷</li><li>Web申请；适用；套用<br>以上来自bing词典，感谢微软爸爸</li></ul></blockquote><p>再来一手必应翻译简直就是，不谈了！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> apy = obj.getName<span class="comment">//这手还是不变</span></div><div class="line">apy.apply(obj)<span class="comment">//koala  （可以说不是指向还给他，这不是假装了，而是直接套用</span></div></pre></td></tr></table></figure><p>有人要问，那你这手跟<code>call()</code>不是一样的么，为什么要区分开来。这个问题<a href="/2017/08/14/js-call-apply-bind/#call-和-apply-区别">下面再讲</a></p><h2 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h2><p>是不是以为我要用百度翻译了？我偏不！</p><blockquote><p><strong>bind</strong></p><p><strong>n.</strong> 窘境；讨厌的事情；捆绑；植物的藤蔓<br><strong>v.</strong> 捆绑；约束；装订；（使）结合；使关系密切<br>以上来自沪江小d，我学日语就靠它</p></blockquote><p><del>顺便，请以上三家公司尽快给我打钱，谢谢合作。</del></p><p><code>bind()</code>有点土匪的意思，它就是想抢走你老婆借用一晚的意思。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> bid = obj.getName<span class="comment">// [Function: getName]          (这手还是不变</span></div><div class="line"></div><div class="line"><span class="comment">// 接着这样做，把this指向回去，变成一个可以自由操作的变量</span></div><div class="line">bid = bid.bind(obj)<span class="comment">// [Function: bound getName]</span></div><div class="line"></div><div class="line">bid()<span class="comment">// koala   （这样才会运行，因为刚刚只是抢过来了</span></div></pre></td></tr></table></figure><h2 id="call-和-apply-区别"><a href="#call-和-apply-区别" class="headerlink" title="call()和#apply()区别"></a>call()和#apply()区别</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> cal = obj.getName</div><div class="line">cal.call(obj)<span class="comment">//koala</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> apy = obj.getName</div><div class="line">apy.apply(obj)<span class="comment">//koala</span></div></pre></td></tr></table></figure><p>说是这么说了，可是，他们并不是说就这么改变<code>this</code>方向然后就没什么用处了啊，可以借用<code>call()</code>和<code>apply()</code>传参数的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName(param1, param2) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' params: '</span> + param1 + param2</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> cal = obj.getName</div><div class="line">cal.call(obj, <span class="number">1</span>, <span class="number">2</span>)<span class="comment">//koala params: 12</span></div></pre></td></tr></table></figure><p>那么<code>apply()</code>就有区别了？哎！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> apy = obj.getName<span class="comment">//这手还是不变</span></div><div class="line">apy.apply(obj, [<span class="number">1</span>, <span class="number">2</span>])<span class="comment">//koala params: 12</span></div></pre></td></tr></table></figure><p><code>apply</code>后面接参数，只接受数组，<code>call</code>的话按顺序怼进去就行了。就这点区别。</p><p>暂时先这样，以后更深入的使用再深入的理解一下。现在大概就用到这些。</p><p><strong>下一篇，讲Javascript的柯基化！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;联动水文，大约半年前记录了Javascript的this。顺水推舟理一下call()，bind()，apply()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;扩展阅读：&lt;a href=&quot;https://colmugx.github.io/PersonalBlog/2017/03/03/js-this/&quot;&gt;关于JavaScript的this&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还是上次的代码，修改一下&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&#39;panda&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; obj = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&#39;koala&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    getName() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; test = obj.getName&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;test()					&lt;span class=&quot;comment&quot;&gt;//undefined.&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（敲黑板！）复习一下！为什么就&lt;code&gt;undefined&lt;/code&gt;了！原因就是，&lt;code&gt;this&lt;/code&gt;指向不同了。那么直接运行是否可以&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&#39;panda&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; obj = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&#39;koala&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    getName() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;obj.getName()		&lt;span class=&quot;comment&quot;&gt;//koala&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>关于Javascript的条件判断</title>
    <link href="https://colmugx.github.io/blog/2017/08/09/about-conditionals/"/>
    <id>https://colmugx.github.io/blog/2017/08/09/about-conditionals/</id>
    <published>2017-08-09T06:47:58.000Z</published>
    <updated>2017-10-17T13:56:03.783Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录这个不为什么，就是遇到SB，不想争执。</p></blockquote><p>撕逼文，小标题都会比较小，方便撕逼思路的连续性！<br><a id="more"></a></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>之所以想到写这个。是因为，公司给我安排的领导一直做的J2SE，没怎么过JS。然后接触了点ES6就疯狂装逼，看谁都是错的。要代码优雅但不愿意开ESLint；不要滥用语法糖却强制让人所有函数使用Promise；代码强调简洁但是非常简单的类似于<code>() =&gt; console.log(&#39;hello world&#39;))</code>都要分成三行写。这就是这次撕逼的源头了。</p><h3 id="JS的条件判断需不需要花括号？"><a href="#JS的条件判断需不需要花括号？" class="headerlink" title="JS的条件判断需不需要花括号？"></a>JS的条件判断需不需要花括号？</h3><blockquote><p>大多数语言中，条件判断语句后不接花括号的话，默认只会取接下来的语句作为子语句。</p></blockquote><p>在这点的话，无论Java或者Javascript都是一样的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (;;) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 可以是这样的</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (;;) <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>那么这么说没有什么说服力，比如这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一种</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) <span class="built_in">console</span>.log(i)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 第二种</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</div><div class="line">  <span class="built_in">console</span>.log(i)</div><div class="line">&#125;</div><div class="line"></div><div class="line">test1() <span class="comment">// 01234</span></div><div class="line">test2() <span class="comment">// 01234</span></div></pre></td></tr></table></figure><p>那么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一种</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) <span class="built_in">console</span>.log(i)</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'你真TM搞笑'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 第二种</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</div><div class="line">  <span class="built_in">console</span>.log(i)</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'你真TM搞笑'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 第三种</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</div><div class="line">  <span class="built_in">console</span>.log(i); <span class="built_in">console</span>.log(<span class="string">'你真TM搞笑'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样的，三个答案是不是一样的？建议看到的如果不清楚答案，可以去试一下，如果你的node是从官网下的的话，就是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">你真TM搞笑</div></pre></td></tr></table></figure><p>很失望是不是！为什么第二种不是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">你真TM搞笑</div><div class="line">1</div><div class="line">你真TM搞笑</div><div class="line">2</div><div class="line">你真TM搞笑</div><div class="line">3</div><div class="line">你真TM搞笑</div><div class="line">4</div><div class="line">你真TM搞笑</div></pre></td></tr></table></figure><p><strong>那语言设计就是这样的，我能怎么办，我也很绝望啊</strong></p><p>那么“大神怎么说的”</p><blockquote><p>某“ES6专家”：你忘记的时候多写一行就会出现bug</p></blockquote><p>这又是什么情况呢？原题目的话是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (exist) <span class="keyword">return</span> <span class="string">'该数据存在'</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="string">'不存在数据，需要添加'</span></div></pre></td></tr></table></figure><p>这实在让我抓破了头都不知道他想表达什么。难道他的意思是这样的？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (exist) <span class="keyword">return</span> <span class="string">'该数据存在'</span>  <span class="comment">// 不存在else 报错？</span></div><div class="line"><span class="comment">// else return '不存在数据，需要添加'</span></div><div class="line"></div><div class="line"><span class="comment">//或者第二种情况</span></div><div class="line"><span class="keyword">if</span> (exist) <span class="keyword">return</span> <span class="string">'该数据存在'</span></div><div class="line"><span class="comment">// else return '不存在数据，需要添加'</span></div><div class="line"><span class="built_in">console</span>.log(exist) <span class="comment">// 报错？</span></div></pre></td></tr></table></figure><p>但是，根据JS “没有花括号的情况下只会把接下来的第一句作为子语句” 已经证明不存在该问题了。那么他要说明什么？</p><h3 id="可能声明式编程真的会出现这种错误"><a href="#可能声明式编程真的会出现这种错误" class="headerlink" title="可能声明式编程真的会出现这种错误"></a>可能声明式编程真的会出现这种错误</h3><h4 id="第一种情况，if中为Boolean类型报错。"><a href="#第一种情况，if中为Boolean类型报错。" class="headerlink" title="第一种情况，if中为Boolean类型报错。"></a>第一种情况，if中为Boolean类型报错。</h4><p>就上面问题，我去百度了（这种垃圾问题Google什么？是看不起百度还是看不起谷歌还是你想装逼展示你会把梯子竖起来？）关键词<code>java if 不写大括号 报错</code></p><p>在CSDN确实有一处，<a href="http://blog.csdn.net/androidiscoding/article/details/47725347" target="_blank" rel="external"><a href="http://blog.csdn.net/androidiscoding/article/details/47725347" target="_blank" rel="external">你不知道java问题if后面加不加括号的问题</a></a>。（感谢大神分享）确实明确提到了</p><blockquote><p>if (boolean) 后面不使用花括号时，里面不能出现声明语句。</p></blockquote><p>哦，那还真对不起了ES6大神。</p><h4 id="第二种情况，作用域错误"><a href="#第二种情况，作用域错误" class="headerlink" title="第二种情况，作用域错误"></a>第二种情况，作用域错误</h4><p>这个可能需要代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog) </div><div class="line">Dog d = (Dog) a;</div></pre></td></tr></table></figure><p>这里还是CSDN得内容，<a href="http://bbs.csdn.net/topics/391057013?page=1" target="_blank" rel="external">为什么省略if后的大括号｛｝会报错</a>，其中<a href="http://my.csdn.net/finemi" target="_blank" rel="external">@finemi</a>提到，可能是java虚拟机的作用域问题，会把下面那句当做大作用域的内容，并不归属于if语句了。这是因为作用域错乱导致的错误，所以用花括号括住保证if内部作用域不受污染。</p><p>哦~<strong>私的ES6大神是本当对不起了！</strong></p><p>这也说明了，声明式编程在语法上确实比较严谨，看起来比较安全。我当时学习Objective-C的时候也确实踩了不少类似于奇怪语法的坑，不过后来信仰了Swift的结构式时候会好了很多。</p><h3 id="最后补一手关于ES6箭头函数的换行与不换行"><a href="#最后补一手关于ES6箭头函数的换行与不换行" class="headerlink" title="最后补一手关于ES6箭头函数的换行与不换行"></a>最后补一手关于ES6箭头函数的换行与不换行</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">() =&gt; <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</div></pre></td></tr></table></figure><p>（有时候真感觉语法糖害死人，不过也方便了我们作死和捣乱）</p><p>其实关于这个，阮一峰老师的开源书<a href="http://es6.ruanyifeng.com/#docs/function#箭头函数" target="_blank" rel="external">函数的扩展 - ECMAScript 6入门</a></p><blockquote><p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</p><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。</p></blockquote><p>代码例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>也就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> test1 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">let</span> test2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 如果有些变态喜欢这么写</span></div><div class="line"><span class="keyword">let</span> test3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最后阮老师强调了</p><blockquote><p><strong>箭头函数使得表达更加简洁。</strong></p><p><strong>如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</strong></p></blockquote><h3 id="最后总结一手"><a href="#最后总结一手" class="headerlink" title="最后总结一手"></a>最后总结一手</h3><p>在知乎，轮子哥解释过函数式编程</p><blockquote><p>函数是语言都倾向于让你用函数来组成函数，而不是把函数看成是一个数据弄成另一个数据的过程。</p></blockquote><p>还有我最喜欢的<a href="https://www.zhihu.com/people/be5invis" target="_blank" rel="external">@Belleve</a>贴了一张图说明了“越往下面走离函数式编程越远”</p><p><img src="https://pic4.zhimg.com/v2-a31b50055c9b896f7e3b9bb4467204e3_b.png" alt=""></p><p>另外，在Javascript中，虽然被称为“玩具语言”，但是就现在被开发的情况来说，Javascript绝对是目前最灵活和最强大的语言了，虽然它运行环境苛刻而严格，还不能做到anyway。</p><p>不过一码归一码，我这么说是想表达，Javascript发展到现在，应该说还有一大块大陆需要去探索，可能这个语言就像我们大脑一样，虽然很厉害了，实际上才开发了一点点而已吧。我也是正在学习这个语言，我只是想说，从想成为JSer开始，就意味着要不断学习。因为这个语言只会随着时间被开发得越来越多。</p><p>而且，几乎每每都能看到有人一直强调：<strong>函数是JS的第一公民</strong>。</p><p>这是什么意思？如果是函数式编程的话，那么，它所定义的每一个语句或者每一个代码块都可以视为函数。</p><p>声明式编程是让你声明某些东西，把内容转化为数据，数据转化为数据。而很明显javascript并不隶属这一家族。而且，js好像连Object都是Function类型的吧！</p><p>而且script，脚本语言+函数式语言，这才是我热爱并追随的地方。虽然我在JS是真的菜！</p><p>最后</p><p style="font-size:24px;font-weight:500;text-align:center;">把Javascript当做指令式编程的人都是神经病！</p><p>（最后感谢所有被引用的文章和作者，谢谢。）</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录这个不为什么，就是遇到SB，不想争执。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;撕逼文，小标题都会比较小，方便撕逼思路的连续性！&lt;br&gt;
    
    </summary>
    
      <category term="编程议论" scheme="https://colmugx.github.io/blog/categories/%E7%BC%96%E7%A8%8B%E8%AE%AE%E8%AE%BA/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>也许是第一个最好理解的Vuex入门</title>
    <link href="https://colmugx.github.io/blog/2017/04/14/easyknow-vuex/"/>
    <id>https://colmugx.github.io/blog/2017/04/14/easyknow-vuex/</id>
    <published>2017-04-14T02:58:13.000Z</published>
    <updated>2017-08-21T16:31:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚用vue不久，应该说还有大量的API还没用过还没熟悉过的时候，突然接受一个新内容，而且还是个很抽象的东西，说实话刚接触的时候完全不知道这东西有什么用…只听说过它能状态管理啊，什么全局控制啊。好牛逼啊666啊。</p><p><strong>哦，然后呢？</strong></p><p>后来稍微理解之后，决定写出来。浅入浅出的理解一下vuex。<a id="more"></a></p><h2 id="what-s-vuex"><a href="#what-s-vuex" class="headerlink" title="what s vuex"></a>what s vuex</h2><p>官方文档：<a href="https://vuex.vuejs.org/zh-cn/" target="_blank" rel="external">Introduction · GitBook</a>，vue的内容都挺良心的，都是看似官方的中文文档…</p><p>Vuex还是跟上面所述…一个应用的状态管理模式。</p><blockquote><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p></blockquote><p>所以只能说它是一个接近于redux，类似于react与redux的那种存在。可是印象没记错的话，react和redux其实是可以独立使用的，这完全就是两个东西，只是可以配合到一块儿去。而vue+vuex不同，vuex之为vue工作，并不能为react等其他框架使用。（也就是redux和vuex都可以为vue服务！不同在于vuex是正室redux是娼！）</p><p>至于“什么是状态管理模式”，官方给了一个例子，看例子就行了。</p><p>什么看不懂？看得懂就不用看这个了？好的可以。开始举例子了啊！</p><p>比如你现在看到桌面上有个馒头，然后你觉得不够吃不爽，你又从冰箱里拿出了一个叉烧包放在桌子上。所以这个时候桌面上就会有一个馒头和一个叉烧包。然后你是哪种什么难吃先吃什么的人（没酱！干吃！反驳我的人晚上别吃饭了！），然后你拿起一个馒头咬了一口然后放在手上。</p><p>OK举例完了。这就是状态管理。</p><p>我们一个vue实例（我就以我会用的2.0角度说），首先会有一个template，模板文件，里面存放的是dom。然后是<code>data()</code>方法，存放固定或不固定的数据。还有一个<code>methods</code>，存放方法，各种方法。对吧没问题吧！你看到(<code>view or template</code>)桌面上<code>{ mantou: 1 }</code>，你觉得不爽去拿(<code>methods -&gt; take()</code>)，然后多了一个叉烧包放在桌子上<code>{ mantou: 1, chashaobao: 1 }</code>，然后你拿起馒头就吃(<code>methods -&gt; ate()</code>)，还拿在手上(保持状态) ，当然data()目前肯定是 { mantou: 0.9, chashaobao: 1 }。<strong>其实我有个梦想，去教小朋友学编程，从小把路给他带歪掉。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="comment">// state</span></div><div class="line">  data () &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      food: &#123;</div><div class="line">        mantou: <span class="number">1</span>,</div><div class="line">        chashaobao: <span class="number">0</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// view</span></div><div class="line">  template: <span class="string">`</span></div><div class="line"><span class="string">    &lt;div class="table"&gt;</span></div><div class="line"><span class="string">&lt;p&gt;&#123;&#123; food.mantou &#125;&#125; &lt;/p&gt;</span></div><div class="line"><span class="string">&lt;p&gt;&#123;&#123; food.chashaobao &#125;&#125; &lt;/p&gt;</span></div><div class="line"><span class="string">&lt;/div&gt;</span></div><div class="line"><span class="string">  `</span>,</div><div class="line">  <span class="comment">// actions</span></div><div class="line">  methods: &#123;</div><div class="line">    ate () &#123;</div><div class="line">      <span class="keyword">this</span>.mantou -= <span class="number">0.1</span></div><div class="line">    &#125;,</div><div class="line">    take () &#123;</div><div class="line">      <span class="keyword">this</span>.chashaobao += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>那么按照vuex开说，就是三种状态，<code>state</code>, <code>action</code>,<code>view</code>。分别就状态，动作，视图。按照官方说的，如果是按照单向数据流来说的话就是 视图 -&gt; 动作 -&gt; 状态 -&gt; 视图。当然刚刚那个例子很明显，都在一个组件内…涉及到多个组件了。就会出现“单向数据流简洁性被破坏”</p><blockquote><ul><li>多个视图依赖于同一状态。</li><li>来自不同视图的行为需要变更同一状态。</li></ul></blockquote><p>就好比现在只是你一个人在做这些事而已，如果家里来了个女朋友呢？（对不起我知道你没有。那你还是单组件管理就行了）。</p><p>官方的意思就是：如果多个视图依赖一个状态，就会出现组件嵌套特别繁琐，而且状态数据也不好传递。如果不同视图行为都要变一个状态，意思就是你咬了一口的馒头你女朋友直接从你嘴里叼走一块！那怎么办！你可以选择不带套路的顺便亲一下是吧！<strong>但是程序并不会“亲一下”。</strong></p><p>所以<code>vuex</code>或者说<code>redux</code>就是因为这个“状态共享解决”而诞生的。（或者说vuex的诞生就是为了提醒你你还没有女朋友。</p><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>按照官方文档，核心概念一共有5个：<code>State</code>, <code>Getters</code>, <code>Mutations</code>, <code>Actions</code>, <code>Modules</code>，一整个vuex在项目里称为<code>store</code>。</p><blockquote><ol><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交(commit) mutations</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li></ol></blockquote><p>首先是在main.js先声明你要用vuex，你要把vuex导入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></div><div class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"></div><div class="line">Vue.use(Vuex)</div></pre></td></tr></table></figure><p>然后创建一个基础的Store，是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * main.js</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  state: &#123;</div><div class="line">    mantou: <span class="number">1</span></div><div class="line">  &#125;,</div><div class="line">  mutations: &#123;</div><div class="line">    ate: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</div><div class="line">      state.mantou -= <span class="number">0.1</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>要记得实例要调用一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  ...,</div><div class="line">  ...,</div><div class="line">  store</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>冰箱啊！也叫做单一状态树，也就是说一整个应用就只有这么一个state，因为放在store中，而store又是一个全局的，所以这是一个人人都能用的大冰箱！（你女朋友也能开</p><p>那么，比如冰箱现在是这么些东西。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">state = &#123;</div><div class="line">  mantou: <span class="number">1</span>,</div><div class="line">  chashao: <span class="number">3</span>,</div><div class="line">  panzi: <span class="string">'红烧鱼'</span>,</div><div class="line">  wan: &#123;</div><div class="line">    name: <span class="string">'卤水鸡腿'</span>,</div><div class="line">    num: <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后这么取出东西：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">store.state.mantou <span class="comment">//获取馒头的值(数量)</span></div><div class="line">store.state.panzi <span class="comment">//红烧鱼</span></div></pre></td></tr></table></figure><p>如果在vue实例中，应该这么取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.$store.state.mantou <span class="comment">// 1</span></div></pre></td></tr></table></figure><p>之所以有<code>$store</code>这种定义，是因为已经作为vue的一个插件了，一开始是不是有<code>Vue.use</code>过。</p><h3 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h3><p>这就是决定是你女朋友吃还是你自己吃了</p><blockquote><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutations 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mutations = &#123;</div><div class="line">  ate (state) &#123;</div><div class="line">    state.mantou -= <span class="number">0.1</span></div><div class="line">  &#125;,</div><div class="line">  take (state) &#123;</div><div class="line">    state.chashao -= <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>虽然是在<code>mutaitons</code>构造方法，但这个载体并不是一个方法载体，等下讲。</p><p>那么如果决定是谁吃：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * SingleDog.js</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  ... ,</div><div class="line">  ... ,</div><div class="line">  method: &#123;</div><div class="line">    ...() &#123;</div><div class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'ate'</span>)  <span class="comment">//mantou: 0.9</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不一定非要这么写，反正只要能调用就行了。</p><h3 id="mutations-payload"><a href="#mutations-payload" class="headerlink" title="mutations payload"></a>mutations payload</h3><p>还有一个是mutations 的载荷（payload），就是在上面那种调用的基础上再传入第二个参数，第二个参数就叫payload。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mutations = &#123;</div><div class="line">  take (state, value) &#123;</div><div class="line">    state.chashao -= value</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>比如这样，首先构建的时候已经有准备可以传入第二个参数，然后调用的时候同理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">store.commit(<span class="string">'take'</span>, <span class="number">1</span>)<span class="comment">//chashao - 1</span></div></pre></td></tr></table></figure><p>或者payload也可以是个Object（对象！你没有！）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mutations = &#123;</div><div class="line">  take (state, obj) &#123;</div><div class="line">    state.chashao -= obj.num</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * GirlFriend.js</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  ... ,</div><div class="line">  ... ,</div><div class="line">  method: &#123;</div><div class="line">    ...() &#123;</div><div class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'take'</span>, &#123;</div><div class="line">        num: <span class="number">1</span></div><div class="line">      &#125;)  <span class="comment">//chashao - 2 （刚被狗吃了一个）</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>暂时先总结这两个。</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="1-mutations-amp-actions"><a href="#1-mutations-amp-actions" class="headerlink" title="1. mutations &amp; actions"></a>1. mutations &amp; actions</h3><p><a href="https://www.zhihu.com/question/48759748" target="_blank" rel="external">vuex中为什么把把异步操作封装在action，把同步操作放在mutations？ - 知乎</a></p><p>官方也有提到，mutations跟actions是差不多的，不同在于</p><blockquote><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul></blockquote><p>也就是按我的理解，他们的关系是这样的：<strong>mutations直接操作state内容，actions直接操作的是mutations。如果需要用actions去操作state的话建议做法就是通过actions操作mutations使state发生变化。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">actions = &#123;</div><div class="line">  onAte (someOne) &#123;</div><div class="line">    someOne.commit(<span class="string">'ate'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个怎么举例啊…你劝着你女朋友：来嘛来嘛吃一口嘛。这样？</p><p>那么如何劝？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">store.dispatch(<span class="string">'onAte'</span>)</div></pre></td></tr></table></figure><p>不仅这样，mutations和actions分开使用还有一个场景：<strong>同步和异步</strong>。</p><p>这个就好比，如果你只是使用<code>mutations</code>来操作state的话，就是你只能看着你女朋友吃完然后你吃剩下的。</p><p>而使用<code>actions</code>的话，你可以边劝你女朋友吃一口，你自己还可以顺便咬一口，因为异步不受限制。</p><p>关于同步跟异步的代码例子，官方已经列举特别特别多了。</p><p><a href="https://vuex.vuejs.org/zh-cn/actions.html" target="_blank" rel="external">Actions · GitBook</a></p><p>结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚用vue不久，应该说还有大量的API还没用过还没熟悉过的时候，突然接受一个新内容，而且还是个很抽象的东西，说实话刚接触的时候完全不知道这东西有什么用…只听说过它能状态管理啊，什么全局控制啊。好牛逼啊666啊。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;哦，然后呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后来稍微理解之后，决定写出来。浅入浅出的理解一下vuex。
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="vue" scheme="https://colmugx.github.io/blog/tags/vue/"/>
    
      <category term="vuex" scheme="https://colmugx.github.io/blog/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vue2.0的网络请求 - Axios</title>
    <link href="https://colmugx.github.io/blog/2017/04/07/axios-tutorial/"/>
    <id>https://colmugx.github.io/blog/2017/04/07/axios-tutorial/</id>
    <published>2017-04-07T07:20:16.000Z</published>
    <updated>2017-08-21T16:14:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我没进传销！真是日了皮皮虾了…</p></blockquote><p>由于Vue2.0之后，<code>vue-resource</code>也停止更新了，改为使用尤老师钦点的<code>axios</code>。<a href="https://github.com/mzabriskie/axios" target="_blank" rel="external">mzabriskie/axios: Promise based HTTP client for the browser and node.js</a></p><p>那反正不管！他说不合适我不用，我就去学个新的。其实接触过微信小程序的话，稍加理解，这就是一个比较厉害点但是又有局限的<code>wx.request()</code></p><h2 id="what-s-Axios"><a href="#what-s-Axios" class="headerlink" title="what s Axios"></a>what s Axios</h2><a id="more"></a><blockquote><p>Promise based HTTP client for the browser and node.js</p></blockquote><p>就是一个基于ES6的<code>Promise</code>的网络请求库，其实说干净了就是一个打包好的<code>XMLHttpRequests</code>，也就是说不过一个Ajax库。</p><p>所以它一样可以实现：</p><ul><li>在浏览器里建立XHR</li><li>通过nodejs进行http请求</li><li>转换或者拦截请求数据或者相应数据</li><li>支持<code>Promise</code>的API</li><li>可以取消请求</li><li>自动转换JSON</li><li><strong>可以防御XSRF攻击！</strong></li></ul><p>浏览器支持问题也没什么问题，IE这种本时代异端都能支持到8+，这问题是不大了。（VUE不也是8+！）</p><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>如果有用npm管理包的话，那么安装还是老规矩的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install axios</div></pre></td></tr></table></figure><p>或者用到了bower（反正我没用过）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bower install axios</div></pre></td></tr></table></figure><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">axios.get(<span class="string">'/* url */'</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// Do Somethings</span></div><div class="line">  <span class="comment">// console.log(response)</span></div><div class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(error)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>因为可以使用Promise的API，那么毫无悬念它的运行肯定也是以Promise来运行。</p><p>而且url，可以是带参数的，例如<code>/user?id=666</code>，或者也可以拆分开来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">axios.get(<span class="string">'/user'</span>, &#123;</div><div class="line">  params: &#123;</div><div class="line">    id: ColMugX</div><div class="line">  &#125;</div><div class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)).catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</div></pre></td></tr></table></figure><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">axios.post(<span class="string">'/* url */'</span>, &#123;</div><div class="line">  <span class="comment">/* Config */</span></div><div class="line">  <span class="comment">// id: 666,</span></div><div class="line">  <span class="comment">// name: ColMugX</span></div><div class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</div></pre></td></tr></table></figure><p>其他的大概也跟GET相差无几。只不过关于’url’后面传入的Object，有可能是用不了的，也有可能是用的了的。因为其他人有类似情况发生。所以我一般都是按照axios api的做法，怎么做下面有！</p><p>因为大概用的多的就这两个…所以举例就差不多这样了，毕竟<code>vue-resource</code>有的基本都有。</p><h3 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h3><h4 id="1-axios是一个方法，你甚至可以整个config传进去"><a href="#1-axios是一个方法，你甚至可以整个config传进去" class="headerlink" title="1. axios是一个方法，你甚至可以整个config传进去"></a>1. axios是一个方法，你甚至可以整个config传进去</h4><p>文档有提到，关于<code>axios API</code>有一条实现方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">axios(config) <span class="comment">//config: Object</span></div></pre></td></tr></table></figure><p>这就意味着，我们可以直接创建一整套静态的config，然后请求的时候带进去就能实现了。比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> *config.js</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  method: <span class="string">'GET'</span>,</div><div class="line">  url: <span class="string">'localhost:6666'</span>,</div><div class="line">  headers: &#123;</div><div class="line">    token: <span class="string">'ftv1443qby6bdfa41t90sfvq89hg3h54u989m9imog79g4'</span> </div><div class="line">    <span class="comment">//这一看就知道是滚键盘的…</span></div><div class="line">  &#125;,</div><div class="line">  data: &#123;</div><div class="line">    id: <span class="number">666</span>,</div><div class="line">    name: <span class="string">'ColMugX'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> *Axios.js</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'config'</span></div><div class="line"><span class="keyword">import</span> axios form <span class="string">'axios'</span></div><div class="line"></div><div class="line">axios(config)</div></pre></td></tr></table></figure><p>配置和运行分离可以带来很多好处，比如baseUrl，header 等等一堆需要重复调用又可以不用重复写，甚至还可以把这些静态的东西直接静态常量掉。避免自己出错或者被更改。而且这么一来的话，甚至请求的话只需要改动url和method就行了。</p><p>因为用的是对象的方法，那好办啊！干对象有什么难的！</p><p>- 今天要用什么姿势！</p><p>- 要不你在上面吧我趴着！</p><p>好那就趴着！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> conf = config</div><div class="line">conf.method = <span class="string">'PUT'</span></div><div class="line"><span class="comment">//其他该怎么传怎么传</span></div></pre></td></tr></table></figure><p>然后请求配置官方有一个<a href="https://github.com/mzabriskie/axios#request-config" target="_blank" rel="external">默认配置方案</a>，照着这个看一下大概也知道它支持传什么东西进去了。</p><p>（默认就有baseURL的配置确实是很惊讶，而且文档写的很清楚，如果没有baseURL或者url已经绝对了的话直接走url）</p><h4 id="2-换了个姿势也许会压到头！"><a href="#2-换了个姿势也许会压到头！" class="headerlink" title="2. 换了个姿势也许会压到头！"></a>2. 换了个姿势也许会压到头！</h4><p>并不是说上面趴着会压爆头什么的…只是顺着梗玩下来而已！</p><p>因为上面说了，axios是可以把整个config都传进去然后开展工作的，所以也就意味着headers和method也可以带在config对象里一起进去，那么可能会有个小问题</p><p><strong>当你的<code>content-tyle</code>是<code>application/x-www-form-urlencoded</code>的时候，<code>POST</code>会用不了！</strong>你请求一下会发现方法直接变成<code>OPTION</code>。</p><p>那是为什么反正我也不知道，我只知道怎么处理，原因是axios的post请求不支持<code>x-www-form-urlencoded</code>，确实是挺奇怪的一件事…</p><p>所以使用到post的时候，要不主动把头改成<code>application/json</code>，这是没问题的，如果不想用或者不能用json的话，传进去的data也就是参数必须是<code>string</code>形式的。这个时候官方建议是多加一个库叫<code>qs</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">'qs'</span></div><div class="line"></div><div class="line">axios.post(<span class="string">'foo'</span>, qs.stringify(config.data))</div></pre></td></tr></table></figure><p>这也是上面说的，为什么有些人在使用<code>POST</code>的时候会遇到“明明跟着官方做却又不对”的情况。</p><p>（稍微吐槽一下！隔壁那个什么微信小程序！他们的<code>get</code>是要求<code>json</code>的，<code>post</code>是要求要<code>form-urlencoded</code>的，逆着来对我等运动员不友好啊！）</p><h4 id="3-实际上错误也不是非得catch"><a href="#3-实际上错误也不是非得catch" class="headerlink" title="3. 实际上错误也不是非得catch"></a>3. 实际上错误也不是非得catch</h4><p>实际上<code>.then()</code>会跟两个参数的：<code>resolve, reject</code>，在axios的话，reject是可以用来输出错误的。而且他们也已经这么定义好了。所以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">axios(config).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res), err =&gt; <span class="built_in">console</span>.log(err))</div></pre></td></tr></table></figure><p>也是没问题的</p><h4 id="4-请求完得到的response会得到这次请求的所有内容"><a href="#4-请求完得到的response会得到这次请求的所有内容" class="headerlink" title="4. 请求完得到的response会得到这次请求的所有内容"></a>4. 请求完得到的response会得到这次请求的所有内容</h4><p>包括<code>config ,data, headers, status, statusText</code>，请求凭证等在headers里，请求到的数据在data里。而且因为会自动转换为JSON，所以基本上请求到的所有数据都已经变成JSON了，可以直接就使用。</p><h4 id="5-withCredentials"><a href="#5-withCredentials" class="headerlink" title="5. withCredentials"></a>5. withCredentials</h4><p>在<code>axios</code>中这是个默认配置里面一个参数，按照我自己的理解，这是一个“是否保存跨域请求凭证”的一个开关，因为众所周知跨域请求是取不到cookie的，这是一个安全策略。但是浏览器可以获取，浏览器可以使用。<strong>人类看不到也使用不到！</strong></p><p>不过道理还是道理，如果你不打开，跨域的不管toekn还是cookie在浏览器里也是一个子都取不到用不到。</p><p>而且设置了<code>withCredentials</code>之后，axios是会保存所有来自远程域的cookie的，比如某些需要登录过后才能访问的内容，就可以直接调用访问了，只要你不清空。</p><p>结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我没进传销！真是日了皮皮虾了…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于Vue2.0之后，&lt;code&gt;vue-resource&lt;/code&gt;也停止更新了，改为使用尤老师钦点的&lt;code&gt;axios&lt;/code&gt;。&lt;a href=&quot;https://github.com/mzabriskie/axios&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;mzabriskie/axios: Promise based HTTP client for the browser and node.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那反正不管！他说不合适我不用，我就去学个新的。其实接触过微信小程序的话，稍加理解，这就是一个比较厉害点但是又有局限的&lt;code&gt;wx.request()&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;what-s-Axios&quot;&gt;&lt;a href=&quot;#what-s-Axios&quot; class=&quot;headerlink&quot; title=&quot;what s Axios&quot;&gt;&lt;/a&gt;what s Axios&lt;/h2&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="vue" scheme="https://colmugx.github.io/blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>关于JavaScript的this</title>
    <link href="https://colmugx.github.io/blog/2017/03/03/js-this/"/>
    <id>https://colmugx.github.io/blog/2017/03/03/js-this/</id>
    <published>2017-03-03T10:34:23.000Z</published>
    <updated>2017-08-21T16:32:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一次被this支配之后的思考</p></blockquote><h3 id="开门见山"><a href="#开门见山" class="headerlink" title="开门见山"></a>开门见山</h3><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(obj.getName()())    <span class="comment">//undefined.</span></div></pre></td></tr></table></figure><p>题目这样，我第一次回答的是<code>koala</code>。现在想了一下，估计是满脑子想吃波星冰乐给冲昏了脑子。<br>如果我改下！<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">        <span class="keyword">let</span> that = <span class="keyword">this</span>    <span class="comment">//this -&gt; that</span></div><div class="line">        <span class="keyword">let</span> name = <span class="string">'koala'</span></div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> that.name <span class="comment">//this -&gt; that</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(obj.getName()()) <span class="comment">//koala</span></div><div class="line"></div><div class="line"><span class="comment">// 或者第二种，利用ES6</span></div><div class="line"><span class="keyword">let</span> name = <span class="string">'panda'</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'koala'</span>,</div><div class="line">    getName() &#123;</div><div class="line">        <span class="keyword">let</span> name = <span class="string">'koala'</span></div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(obj.getName()()) <span class="comment">//koala</span></div></pre></td></tr></table></figure></p><h3 id="解题想法"><a href="#解题想法" class="headerlink" title="解题想法"></a>解题想法</h3><p>我的理解，<code>this</code>其实跟其他语言的<code>self</code>应该是差不多。就是指代自己，比如说在一个<code>function</code>里面，那么<code>this</code>指向的就是这个func。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">colmugx</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//do something.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可能我讲的不清楚，就是<strong>this其实就是括号里的东西。</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">colmugx</span>(<span class="params"><span class="regexp">/** this */</span></span>) </span>&#123;</div><div class="line">    <span class="comment">//do somethings</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当然这是我的理解，我觉得应该就是这样的，所以刚刚那样取到的this并不是this。</p><h3 id="浅谈this"><a href="#浅谈this" class="headerlink" title="浅谈this"></a>浅谈this</h3><p>只讲两种我懂的东西。</p><h4 id="跟着new走"><a href="#跟着new走" class="headerlink" title="跟着new走"></a>跟着new走</h4><p>就是用new来创建对象的话，那么<code>this</code>就会跟着这个new<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    func() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">'koala'</span>)</div><div class="line"><span class="built_in">console</span>.log(a.name) <span class="comment">//koala</span></div></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    func() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">'koala'</span>)</div><div class="line"><span class="built_in">console</span>.log(a.func()) <span class="comment">//Animal &#123; name: 'koala' &#125;</span></div></pre></td></tr></table></figure><h4 id="ES6中括号函数的this"><a href="#ES6中括号函数的this" class="headerlink" title="ES6中括号函数的this"></a>ES6中括号函数的this</h4><p>括号函数的<code>this</code>，不存在的！</p><p>说是不存在，实际上并不是说真的不见了，而是它会绑定到上一层函数中<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</div><div class="line">    <span class="comment">//do somethings.</span></div><div class="line">&#125;<span class="comment">/** ,this */</span>)</div></pre></td></tr></table></figure></p><p>而如果不是括号的话</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="regexp">/** this */</span></span>)</span>&#123;</div><div class="line">    <span class="comment">//do somethings.</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一次被this支配之后的思考&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;开门见山&quot;&gt;&lt;a href=&quot;#开门见山&quot; class=&quot;headerlink&quot; title=&quot;开门见山&quot;&gt;&lt;/a&gt;开门见山&lt;/h3&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript所有for</title>
    <link href="https://colmugx.github.io/blog/2017/03/02/js-for/"/>
    <id>https://colmugx.github.io/blog/2017/03/02/js-for/</id>
    <published>2017-03-02T15:40:42.000Z</published>
    <updated>2017-12-26T10:03:29.491Z</updated>
    
    <content type="html"><![CDATA[<p>其实也是看到了<a href="https://zhuanlan.zhihu.com/jbangit" target="_blank" rel="external">匠邦互联网 - 知乎专栏</a>，其中一篇讲for的</p><p>觉得我不服！我要上！<br><a id="more"></a></p><h3 id="先讲for"><a href="#先讲for" class="headerlink" title="先讲for"></a>先讲for</h3><p>我觉得这应该是最古老而且实用性最强的for了，就是三段式定义。<code>for (;;)</code><br>想到当年考java编程基础的时候（一门学科），有一道手写题要用到循环，我抬手就是<code>for (var ...)</code>…<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i;i&lt;len;i++)</div></pre></td></tr></table></figure></p><p>其中不管怎样，常规for必须要两个;，因为就是这样，里面有三段式嘛。第一个是定义自走变量，第二个是条件，第三个是自加或自减。实际上for应该是这样的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i;<span class="keyword">let</span> len;i&lt;len;++i)</div></pre></td></tr></table></figure></p><h3 id="for-in"><a href="#for-in" class="headerlink" title="for..in"></a>for..in</h3><p>这个在上次总结对象遍历已经提到了，它好像也就遍历对象用得多一点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> sth) &#123;&#125;</div></pre></td></tr></table></figure></p><p>不过<code>for in</code>的话，为什么说遍历对象比较多，其中一个除了好写<del>（打死吧这人）</del>，还有一点它只能用来遍历有key或者说是个index的东西，比如数组，它只能读到数组的index，那对象的话就直接读到键值咯。而且有一点的是，你读数组，<strong>读出来的index是个string不是number</strong>。这个要记得，因为js这种弱类型的东西，如果索引相加就变成字符串相加了……<strong>（我幼儿园就会20以内加减法了，1加2等于12)</strong></p><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>这个方法就不是古老的方法了，JS(ES5)版本的时候的，针对数组的一个方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.forEach(<span class="function">(<span class="params">i</span>)=&gt;</span> &#123;&#125;)</div></pre></td></tr></table></figure></p><p>这种遍历的话，你遍历完直接能把数据处理掉最好，因为如果不是的话就麻烦了…它并不是一个开放的遍历，而是借用的闭包函数做的遍历。可以看成是<code>arr.func()</code>，它是一个数组方法，传进去一个<code>callback</code>，那就厉害了啊，闭包一个特点就是保护变量避免污染啊，变量保护是双向的啊…进得去出不来… （所以我的微信小程序openradio有用到计数器的时候不敢用这个，而且这个方法也是针对数组才能用的）</p><h3 id="for-of"><a href="#for-of" class="headerlink" title="for..of"></a>for..of</h3><p>这是ES6的新东西，它比<code>for in</code>遍历的更多，没有<code>for (;;)</code>复杂，对比<code>forEach</code>它是开放的不是闭包，也就是那些条件控制流什么的都可以操作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr)</div></pre></td></tr></table></figure></p><p>可是不止，好像还可以<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> <span class="string">'colmu'</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(i)  <span class="comment">//'c'\n 'o'\n 'l'\n 'm'\n 'u'\n</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>不过它不能遍历对象！不能遍历对象！不能遍历对象！而且错误信息<code>TypeError: str[Symbol.iterator] is not a function</code>。所以这里我不行不BB了。</p><blockquote><p>所有实现了[Symbol.iterator]接口的对象都可以被遍历。</p></blockquote><h3 id="for-in-和-for-of-对比"><a href="#for-in-和-for-of-对比" class="headerlink" title="for in 和 for of 对比"></a>for in 和 for of 对比</h3><p>一个栗子就能锤到头皮发麻<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">6</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>]</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</div><div class="line">    <span class="built_in">console</span>.log(i)  <span class="comment">// 0,1,2,3,4</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">6</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>]</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</div><div class="line">    <span class="built_in">console</span>.log(i)  <span class="comment">//6,6,4,2,8</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>光说区别不行，我要讲怎么用！</p><p><del>万能膏药<code>while</code></del> （不对走错片场…）</p><p>万能膏药<code>for (;;)</code>：这是怎样都能用的，不过就是长了点，但是定义细了多。</p><p>数组专利<code>forEach</code>：数组的方法，只能用在数组。</p><p>能用在数组的：<code>for</code>, <code>forEach</code>, <code>for in</code>, <code>for of</code></p><p>能用在找头的：<code>for in</code></p><p>只要支持[Symbol.iterator]要什么找什么的：<code>for of</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实也是看到了&lt;a href=&quot;https://zhuanlan.zhihu.com/jbangit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;匠邦互联网 - 知乎专栏&lt;/a&gt;，其中一篇讲for的&lt;/p&gt;
&lt;p&gt;觉得我不服！我要上！&lt;br&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6对象遍历</title>
    <link href="https://colmugx.github.io/blog/2017/02/28/object-traversal/"/>
    <id>https://colmugx.github.io/blog/2017/02/28/object-traversal/</id>
    <published>2017-02-28T04:21:34.000Z</published>
    <updated>2017-08-19T15:54:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>花了几天时间都在探究ES6，为了实现对象遍历，一个头两个大。</p></blockquote><p>最新超想玩《尼尔：机械纪元》，被那种机械元素迷得死死的，故把最近正在写的博客主题融入机械风。另外我打算这次主题换个姿势来写，想用各种新鲜没尝试过的结构。于是……</p><h3 id="作死起源"><a href="#作死起源" class="headerlink" title="作死起源"></a>作死起源</h3><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//app.js</span></div><div class="line">App(&#123;</div><div class="line">  onLaunch: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    </div><div class="line">  &#125;,</div><div class="line">  onShow: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    </div><div class="line">  &#125;,</div><div class="line">  onHide: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    </div><div class="line">  &#125;,</div><div class="line">  globalData: globalData</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>万恶之源就是微信小程序，通过执行App()传入一套<code>params</code>，然后能执行下面那些方法。这我就心底长毛了啊，我也想实现类似这样的执行方法。所以就搞。现在尝试了不知道多少种方法，成功率0%</p><h3 id="谈一下ES6对象扩展-–-遍历对象"><a href="#谈一下ES6对象扩展-–-遍历对象" class="headerlink" title="谈一下ES6对象扩展 – 遍历对象"></a>谈一下ES6对象扩展 – 遍历对象</h3><p>先讲目的，我想这样然后<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> test = (<span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> sliv = params</div><div class="line">    </div><div class="line">    <span class="keyword">this</span>.sliv = sliv</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">test(&#123;</div><div class="line">    first() &#123;</div><div class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'first 666'</span>)</div><div class="line">    &#125;,</div><div class="line">    second() &#123;</div><div class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'second 666'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>当然了无法执行，东西是读进去了，但是谁知道你想执行谁，就因为这个所以想到了对象遍历。好了</p><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><p><code>for in</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> test = (<span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> sliv = params</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> params) &#123;</div><div class="line">        <span class="built_in">console</span>.log(i)      <span class="comment">//first, second</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.sliv = sliv</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><p><code>Object.keys()</code><br>我的处理方法是这样的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> test = (<span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> sliv = params</div><div class="line">    <span class="keyword">let</span> &#123;keys&#125; = <span class="built_in">Object</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> keys(sliv)) &#123;</div><div class="line">        <span class="built_in">console</span>.log(i)      <span class="comment">//first, second</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.sliv = sliv</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>结果跟第一种一样，下一个！</p><h4 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h4><p><code>Object.getOwnPropertyNames()</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> test = (<span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> sliv = params</div><div class="line">    <span class="keyword">let</span> a = <span class="built_in">Object</span>.getOwnPropertyNames(params)</div><div class="line">    <span class="built_in">console</span>.log(a)      <span class="comment">//[ 'first', 'second' ]</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;a.length;i++) &#123;</div><div class="line">        <span class="built_in">console</span>.log(a[i])    <span class="comment">//first, second</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.sliv = sliv</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>对象遍历讲完！</p><h3 id="目的，我想执行"><a href="#目的，我想执行" class="headerlink" title="目的，我想执行"></a>目的，我想执行</h3><p>所以我想到的执行方法是这样<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> test = (<span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> sliv = params</div><div class="line">    params.first()      <span class="comment">//first 666</span></div><div class="line">    <span class="keyword">this</span>.sliv = sliv</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>但是如果我这么执行的话<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> test = (<span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> sliv = params</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> params) &#123;</div><div class="line">        <span class="keyword">let</span> func = sliv.i   <span class="comment">//undefined</span></div><div class="line">        func()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.sliv = sliv</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>亦或者<code>sliv.i()</code>都是失败告终，所以我就看了一下<code>typeof</code>，这first这些的类型均为<code>string</code>。</p><p>于是挖个坑记录一下，是否有办法可以遍历完对象之后执行掉对象内函数，我甚至连<code>new Object</code>都用过了……</p><p>所以这篇的记录只是ES6中对象的遍历！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;花了几天时间都在探究ES6，为了实现对象遍历，一个头两个大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最新超想玩《尼尔：机械纪元》，被那种机械元素迷得死死的，故把最近正在写的博客主题融入机械风。另外我打算这次主题换个姿势来写，想用各种新鲜没尝试过的结构。于是……&lt;/p&gt;
&lt;h3 id=&quot;作死起源&quot;&gt;&lt;a href=&quot;#作死起源&quot; class=&quot;headerlink&quot; title=&quot;作死起源&quot;&gt;&lt;/a&gt;作死起源&lt;/h3&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://colmugx.github.io/blog/tags/ES6/"/>
    
  </entry>
  
</feed>
