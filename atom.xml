<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Colmugx &#39;s Blog</title>
  
  <subtitle>让一切充满想象力</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://colmugx.github.io/blog/"/>
  <updated>2019-04-23T09:07:32.109Z</updated>
  <id>https://colmugx.github.io/blog/</id>
  
  <author>
    <name>colmugx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>defineProperty? Proxy?</title>
    <link href="https://colmugx.github.io/blog/2019/04/20/why-vue-proxy/"/>
    <id>https://colmugx.github.io/blog/2019/04/20/why-vue-proxy/</id>
    <published>2019-04-20T04:47:12.000Z</published>
    <updated>2019-04-23T09:07:32.109Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>听说 Vue3 数据绑定要切换到 Proxy，为什么？</p></blockquote><p>这就是这篇文章的原因，来源于某个牛逼公司的面试。<del>我真的应该学会怎么清楚表达观点…</del></p><p><code>defineProperty</code> 和 <code>Proxy</code> 使用方式和效果看起来是差不多的，但如果翻译成中文的话，一个是定义属性，一个是代理，并且 MDN 上描述有所不同。</p><blockquote><p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 —— MDN</p></blockquote><blockquote><p>Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。  —— MDN</p></blockquote><h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h3><p>这是一个 <code>ES5</code> 的方法。一个 <code>defineProperty</code> 需要三个参数，都是 <code>require</code><br><a id="more"></a></p><blockquote><p>Object.defineProperty(obj, prop, descriptor)<br>obj: object, 定义的对象（我理解为附着于哪个对象）<br>prop: 定义的对象名称(key)<br>descriptor: 将被定义或修改的属性描述符。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'colmugx'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>descriptor</code> 存在可选项：</p><table><thead><tr><th style="text-align:left">key</th><th style="text-align:left">value</th></tr></thead><tbody><tr><td style="text-align:left">configurable</td><td style="text-align:left">该属性为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</td></tr><tr><td style="text-align:left">enumerable</td><td style="text-align:left">该属性为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。</td></tr><tr><td style="text-align:left">value</td><td style="text-align:left">该属性对应的值。</td></tr><tr><td style="text-align:left">writable</td><td style="text-align:left">该属性为 true 时，value才能被赋值运算符改变。默认为 false。</td></tr><tr><td style="text-align:left">get</td><td style="text-align:left">getter 方法</td></tr><tr><td style="text-align:left">set</td><td style="text-align:left">setter 方法</td></tr></tbody></table><p>除了 <code>boolean</code> 类型，值都默认为 <code>undefined</code></p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>这是一个 <code>ES6</code> 的方法，<code>Proxy</code> 参数比较简单</p><blockquote><p>new Proxy(target, handler)<br>target: 目标对象<br>handler: 属性/操作对象，当执行一个操作时定义代理的行为的函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, name) &#123;</span><br><span class="line">    <span class="keyword">return</span> name <span class="keyword">in</span> target ? target[name] : target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="？"><a href="#？" class="headerlink" title="？"></a>？</h3><h4 id="数据拦截"><a href="#数据拦截" class="headerlink" title="数据拦截"></a>数据拦截</h4><p>先看看 <code>Vue</code> 那种数据拦截是怎样的，做一个简单实现。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> value = <span class="literal">undefined</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'key'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span>(val) &#123;</span><br><span class="line">    value = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>很明显，我可以劫持一个对象的 <code>getter</code> 和 <code>setter</code>，同时也很明显，貌似需要一个缓存量。</p><p>如果说和 <code>Proxy</code> 比较呢？因为 <code>Proxy</code> 实现的是代理下整个对象，那么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;<span class="attr">key</span>: <span class="literal">undefined</span>&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">    <span class="comment">// 由于代理了所有操作，那么返回 404 纯属意愿</span></span><br><span class="line">    <span class="keyword">return</span> prop <span class="keyword">in</span> target ? target[prop] : <span class="string">'404 Not Found'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span>(val) &#123;</span><br><span class="line">    target[prop] = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>写法有点像<code>computed</code></p><p>那么，为什么<code>defineProperty</code>不直接<code>target[prop] = val</code>？因为劫持关系，你会看到狗咬尾巴的奇观。也就是说，<code>defineProperty</code> 对原对象操作就会触发劫持，而<code>Proxy</code>操作的是实例对象，每个实例对象相对独立。</p><p>所以通过两次面试，闭环了这个知识。另外一篇：<a href="/blog/2018/03/16/vue-watcher">vue watch存在永动吗？</a></p><p>然而<code>Vue</code>换方式，显然不止因为这个，或许连这个都谈不上。</p><h4 id="只需要-defineProperty？怎么可能？"><a href="#只需要-defineProperty？怎么可能？" class="headerlink" title="只需要 defineProperty？怎么可能？"></a>只需要 defineProperty？怎么可能？</h4><p>首先，上面例子这种方式可以看出，我每次操作都只能监听一个值，但一个应用不可能只有一个属性，而且没办法及时知道哪一个属性获得了更新。在深入了解之后，<code>Vue</code>好像用了订阅的方式在做这些事情。</p><p><a href="https://github.com/vuejs/vue/blob/52719ccab8/src/core/observer/index.js#L109" target="_blank" rel="noopener">vue/src/core/observer/index.js#L109</a></p><p>除了简单（没有深度）数据，其他一概遍历进观察者。</p><h4 id="为什么-Proxy？"><a href="#为什么-Proxy？" class="headerlink" title="为什么 Proxy？"></a>为什么 Proxy？</h4><ol><li><code>defineProperty</code> 对数组有硬伤</li></ol><p>因为设定关系，<code>defineProperty</code>不能观察到数组内部，如果直接修改数组而不是返回新数组的话，无法触发劫持。<code>Vue</code>文档以一个简单的方式解释了<a href="https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B" target="_blank" rel="noopener">这个问题</a>，解决这个问题的方法有点骚，<a href="https://github.com/vuejs/vue/blob/52719ccab8fccffbdf497b96d3731dc86f04c1ce/src/core/observer/array.js#L11" target="_blank" rel="noopener">相关源码位置</a>。但这只是让数组方法可以“正常使用”，万一有人<code>arr[0] = 0</code>呢？</p><ol start="2"><li>一个方法只能监听一个属性</li></ol><p>如果我需要监听这个对象里所有键，我需要把所有键都<code>defineProperty</code>一次。需要创建一个缓存变量倒不是什么“难事”，封装成一个方法就成了，但：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">d</span>: &#123; <span class="attr">e</span>: <span class="string">'???'</span> &#125;&#125;&#125;&#125;&#125;  <span class="comment">// ???</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>Proxy</code> 可以做到上面所有事情</li></ol><p>上面提到，<code>Proxy</code>是代理了整个对象，而且是以根据 target 创建实例来进行接下来的工作，每一个都相对独立。</p><p>第一个问题，因为我们有这个“对象”的所有操作权，而且每次<code>set</code>都能返回新的“对象”，并且我们可以自己定义“数据如何改变”</p><p>第二个问题，因为<code>Proxy</code>实现的是观察到整个对象而不是对象属性，那自然不存在这个问题了。</p><ol start="4"><li>除了 <code>getter</code>, <code>setter</code>，<code>Proxy</code>还有其他用法</li></ol><p>比如<code>apply</code>，可以劫持对象的函数（我的理解是把对象可以执行，当然JavaScript中，一切都是对象）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  apply(target, context, args) &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所以你可以执行一些东西，甚至是通过方法创建/改变得到一个对象（对 target 直接修改）</p><p>感觉，如果<code>Vue3</code>用<code>Proxy</code>改写之后，代码会简洁非常多。而且性能可能会比现在提高好几倍（？），毕竟看目前得到的信息，对每一个数据创建<code>Observer</code> + <code>defineProperty</code>，性能挺要命的……</p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><code>Proxy</code>在这里的用法只能说是「能当对象使用的对象」吧，毕竟它还是一个实例(Proxy(…)，而<code>defineProperty</code>操作的是意义上的对象。</p><p>而且我本以为我应该会先读<code>React</code>的源码，没想到…</p><h3 id="为什么-Vue2-不直接用-Proxy"><a href="#为什么-Vue2-不直接用-Proxy" class="headerlink" title="为什么 Vue2 不直接用 Proxy"></a>为什么 Vue2 不直接用 Proxy</h3><p><code>Vue</code> 最早出现于 2013 年，<code>ES2015</code> 规范确定于 2015年，目前找不到 <code>Vue2</code> 第一个 commit 是什么时候（懒），推算了一下，不应该是赶不上，所以有第二种猜想：兼容性问题。</p><p><code>Vue</code>可以支持到 IE9+，目前的兼容性是 IE10+。首先<code>Proxy</code>就已经把 IE 完整的抛弃掉了，一点点都不支持。就算上 <code>polyfill</code>，也仅可以使用<code>get</code>, <code>set</code>, <code>apply</code>, <code>construct</code>，而 <code>Proxy</code> 的钩子(陷阱)达到十几种，显然物尽其能是不可能。</p><p>时代不同了，现在是现代浏览器时代，IE 淡出，连 Edge 都投靠敌台了。话说我最喜欢的就是最后一代斯巴达，渲染很快又开始支持插件。</p><h3 id="Vue-amp-React"><a href="#Vue-amp-React" class="headerlink" title="Vue &amp; React"></a>Vue &amp; React</h3><p>18 年我经常说的就是，如果技术参差不齐的团队，显然<code>Vue</code>更合适。反正你照着说明书一行一行抄肯定不会抄出问题。<strong>所以我不喜欢 Vue 就是因为不够自由，但如果无法驾驭自由，React 性能会更差。</strong></p><p>其中一个原因就是 <code>Vue</code> 跟 <code>React</code> 对数据的操作是不一样的。<code>React</code>单向，通过对比来更新数据，所以今日会有两种组件创建方式：<code>Component</code>, <code>PureComponent</code>。</p><blockquote><p>为什么 React 不学 Vue 搞这手，表单验证之类工作不是很好实现</p></blockquote><p>说实话我听到这个问题，我有点想脱口而出“NM$L”，大家的想法都不一样为什么要强比较？所以我的回答是：</p><blockquote><p>这是 React 的设计原因，React 的做法是数据流单向，利用函数式的思想，像管道一样的操作使得副作用更加可控。</p></blockquote><p>只是回答得不完美，我有面试就紧张的坏心态。我的本意是我可以清楚数据的流向，同时采用数据不可变，这样根本不用担心数据在中途突然被什么做了修改。因为前面的原因，第二个问题忘记回答了：因为用函数式的思想，那么表单验证我可以用高阶函数呀。</p><p>但并不是说<code>Vue</code>的做法不是高阶函数，其实也是的。只是我们在用<code>React</code>的时候，感觉<code>React</code>只提供了把代码转成视图的功能，就没了，什么都没有什么都是自己实现。而<code>Vue</code>已经实装了非常多的操作使得开发过程不用想多一些问题。举一个小栗子：<code>React</code>渲染一个列表，靠的是自己用<code>JavaScript</code>的方法生成一个装着<code>ReactNode</code>的数组，而<code>Vue</code>只需要在模板中标记列表数据和在哪个节点渲染，把要渲染的内容写在其中即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;听说 Vue3 数据绑定要切换到 Proxy，为什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就是这篇文章的原因，来源于某个牛逼公司的面试。&lt;del&gt;我真的应该学会怎么清楚表达观点…&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;defineProperty&lt;/code&gt; 和 &lt;code&gt;Proxy&lt;/code&gt; 使用方式和效果看起来是差不多的，但如果翻译成中文的话，一个是定义属性，一个是代理，并且 MDN 上描述有所不同。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 —— MDN&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。  —— MDN&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;defineProperty&quot;&gt;&lt;a href=&quot;#defineProperty&quot; class=&quot;headerlink&quot; title=&quot;defineProperty&quot;&gt;&lt;/a&gt;defineProperty&lt;/h3&gt;&lt;p&gt;这是一个 &lt;code&gt;ES5&lt;/code&gt; 的方法。一个 &lt;code&gt;defineProperty&lt;/code&gt; 需要三个参数，都是 &lt;code&gt;require&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="编程议论" scheme="https://colmugx.github.io/blog/categories/%E7%BC%96%E7%A8%8B%E8%AE%AE%E8%AE%BA/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
      <category term="vue" scheme="https://colmugx.github.io/blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>关于 Nlvi 「添加到桌面」</title>
    <link href="https://colmugx.github.io/blog/2019/04/17/about-nlvi-pwa/"/>
    <id>https://colmugx.github.io/blog/2019/04/17/about-nlvi-pwa/</id>
    <published>2019-04-17T09:36:28.000Z</published>
    <updated>2019-04-17T10:17:35.456Z</updated>
    
    <content type="html"><![CDATA[<p>其实这个功能早在 2.x 版本就加入了，那时候对 PWA 并没有什么概念。<del>好想换 iPad Mini (new)</del></p><p><img src="/blog/Image/nlvi-ios-desktop.gif" alt="nlvi-ios-desktop"></p><p>目前 3.x 只改了启动图，适配了 iPad 横屏和 iPhone 全面屏（普通屏和plus后续加）。之前看到苹果对 PWA 持拒绝态度我是震惊的，你 tm 早就给 safari 加入了这个功能，也有相关<code>meta</code>配置（包括”识别为<code>WebApp</code>“），然后你告诉我这东西不是 PWA？</p><p>本来确实想支持 PWA 的，想到除了要 <code>manifest.json</code>，还要搞定对应生成 <code>service worker</code>，使用不是很友好，所以取消计划。这部分添加功能就是一个尝试的甜点，所以也没有拿出来说。目前 3.x 开启 <code>pjax</code> 然后添加到桌面，阅读体验还是挺好的。</p><p>所以这次打算讲讲「苹果式网页应用安装」，其实挺简单的。<br><a id="more"></a></p><h3 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h3><p>这里没有列出所有关于 safari 支持的 meta，只针对这个功能部分。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-touch-fullscreen"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-capable"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-title"</span> <span class="attr">content</span>=<span class="string">"Colmugx's Blog"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-status-bar-style"</span> <span class="attr">content</span>=<span class="string">"default"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon"</span>  <span class="attr">sizes</span>=<span class="string">"72x72"</span>  <span class="attr">href</span>=<span class="string">"icon.ico"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon-precomposed"</span>  <span class="attr">sizes</span>=<span class="string">"72x72"</span>  <span class="attr">href</span>=<span class="string">"icon.ico"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-startup-image"</span> <span class="attr">media</span>=<span class="string">"(device-width: 375px)"</span> <span class="attr">href</span>=<span class="string">"apple-launch-1125x2436.png"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-startup-image"</span> <span class="attr">media</span>=<span class="string">"(orientation: landscape)"</span> <span class="attr">href</span>=<span class="string">"apple-touch-startup-image-2048x1496.png"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>从上到下分别是：</p><ul><li>添加到主屏幕后，是否全屏显示</li><li>是否显示 safari 菜单</li><li>应用默认名称（在添加的时候可以修改）</li><li>打开时，顶上状态栏应该呈现什么颜色（白色，黑色，透明）</li><li>设置 icon (72x72, 114x114)，图标在「书签」也可适用</li><li>设置启动画面（这里只设置了手机与平板横置）</li></ul><h3 id="apple-touch-startup-image"><a href="#apple-touch-startup-image" class="headerlink" title="apple-touch-startup-image"></a>apple-touch-startup-image</h3><p>其他的没什么坑点，只是<code>apple-touch-startup-image</code>会复杂一些。它分成很多分辨率，设置不清楚的话就不会显示。而且它不能像图标一样设置<code>size</code>。只能用<code>media</code>一行一行写。</p><p>比如 iPad，设置倒是不需要跟手机一样那么多图片，只需要准备一张垂直一张水平。垂直 <code>768x1024</code>，水平<code>748x1024</code>，水平图也需要摆成垂直的，也就是<code>1024x748</code>，当然内容也是横直，相当于顺时针 90°。接着就考虑一下屏幕用的是二倍图还是三倍图了。</p><p>参考文章：<a href="https://medium.com/appscope/adding-custom-ios-splash-screens-to-your-progressive-web-app-41a9b18bdca3" target="_blank" rel="noopener">Adding Custom iOS Splash Screens To Your Progressive Web App</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实这个功能早在 2.x 版本就加入了，那时候对 PWA 并没有什么概念。&lt;del&gt;好想换 iPad Mini (new)&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/Image/nlvi-ios-desktop.gif&quot; alt=&quot;nlvi-ios-desktop&quot;&gt;&lt;/p&gt;
&lt;p&gt;目前 3.x 只改了启动图，适配了 iPad 横屏和 iPhone 全面屏（普通屏和plus后续加）。之前看到苹果对 PWA 持拒绝态度我是震惊的，你 tm 早就给 safari 加入了这个功能，也有相关&lt;code&gt;meta&lt;/code&gt;配置（包括”识别为&lt;code&gt;WebApp&lt;/code&gt;“），然后你告诉我这东西不是 PWA？&lt;/p&gt;
&lt;p&gt;本来确实想支持 PWA 的，想到除了要 &lt;code&gt;manifest.json&lt;/code&gt;，还要搞定对应生成 &lt;code&gt;service worker&lt;/code&gt;，使用不是很友好，所以取消计划。这部分添加功能就是一个尝试的甜点，所以也没有拿出来说。目前 3.x 开启 &lt;code&gt;pjax&lt;/code&gt; 然后添加到桌面，阅读体验还是挺好的。&lt;/p&gt;
&lt;p&gt;所以这次打算讲讲「苹果式网页应用安装」，其实挺简单的。&lt;br&gt;
    
    </summary>
    
      <category term="实践尝试" scheme="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="nlvi" scheme="https://colmugx.github.io/blog/tags/nlvi/"/>
    
  </entry>
  
  <entry>
    <title>我今天给 let 安排了</title>
    <link href="https://colmugx.github.io/blog/2019/03/27/you-dont-know-let/"/>
    <id>https://colmugx.github.io/blog/2019/03/27/you-dont-know-let/</id>
    <published>2019-03-27T10:13:29.000Z</published>
    <updated>2019-04-08T09:02:18.111Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Round-1"><a href="#Round-1" class="headerlink" title="Round 1"></a>Round 1</h4><blockquote><p>- 我现在把所有东西都注释掉，改成这样<br>function a() {<br>  return inner;<br>  let inner;<br>}<br>返回什么？</p><p>- 那就应该 undefined 了，反正后面不执行</p></blockquote><p>自信的不行，出了门掏出全世界最牛逼的千元机<strong>坚果 Pro 2S</strong>，验证了一下。</p><blockquote><p>inner is not defined</p></blockquote><p>确实是不执行，但好像不是 <code>undefined</code> 啊╭(*ﾟДﾟ*)╮</p><h4 id="Round-2"><a href="#Round-2" class="headerlink" title="Round 2"></a>Round 2</h4><blockquote><p>- 如果改成这样呢<br>function a() {<br>  function inner() {}<br>  return inner;<br>  let inner;<br>}<br>返回什么？</p><p>- 返回方法</p></blockquote><p>自信的不行，同样用全世界最牛逼的千元机<strong>坚果 Pro 2S</strong>，验证了一下。</p><blockquote><p>Identifier ‘inner’ has already been declared</p></blockquote><p>(ﾟДﾟ≡ﾟдﾟ)!? 你在返回你🐴呢？<br><a id="more"></a></p><h3 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h3><p>原本我以为只有 <code>var</code> 会变量提升，实际上错了，<code>var/let/const</code>都会。</p><p><code>var</code> 和 <code>let</code> 在某种时候是相似的，他们都会提升，但 <code>let</code> 少了初始化的过程。MDN 对 <code>let</code> 死区是这么解释的</p><blockquote><p>在 ECMAScript 2015 中，let 绑定不受变量提升的约束，这意味着 let  声明不会被提升到当前执行上下文的顶部。在块中的变量初始化之前，引用它将会导致 ReferenceError（而使用 var 声明变量则恰恰相反，该变量的值是 undefined ）。这个变量处于从块开始到 let 初始化处理的”暂存死区“之中。 —— MDN</p></blockquote><p>暂存死区又有这么个说法，用一个代码块解释一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  a = <span class="string">'caonima'</span> <span class="comment">// 下面有 let，a 直接被该块锁定，这里报错</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> a <span class="comment">// 到这里才完成初始化，变量开始正常使用，但变量早已提升</span></span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// 这里不是 caonima 而是 undefined</span></span><br><span class="line"></span><br><span class="line">  a = <span class="string">'woshinidie'</span></span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// woshinidie</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/getify/You-Dont-Know-JS/issues/767" target="_blank" rel="noopener">You-Dont-Know-JS#767</a> 讨论了这个问题, creeperyang 总结了四点</p><blockquote><ol><li>Hoisting includes both declare and initialize.</li><li>Only initialized variable can be used in a scope.</li><li>var do both declare and initialize, the two cannot be split for var.</li><li>let do firstly declare in the top of the scope, and do initialize when encounter the let xxx statements.<br>—— @creeperyang</li></ol></blockquote><p>另外，方应杭在知乎专栏的文章<a href="https://zhuanlan.zhihu.com/p/28140450" target="_blank" rel="noopener">《我用了两个月的时间才理解 let》</a>也总结出</p><blockquote><ol><li>let 的「创建」过程被提升了，但是初始化没有提升。</li><li>var 的「创建」和「初始化」都被提升了。</li><li>function 的「创建」「初始化」和「赋值」都被提升了。<br>—— <a href="https://www.zhihu.com/people/zhihusucks" target="_blank" rel="noopener">@方应杭</a></li></ol></blockquote><p>理论上 <code>const</code> 应该是 <code>let</code> 的不可修改版本，所以应该是类似的。但也仅限提升原理相同，因为 <code>const</code> 只能初始化时赋值一次。</p><p>不过，阮一峰的《ECMAScript 6 入门》是什么意思？在 let 有单独一小节讲 <a href="http://es6.ruanyifeng.com/#docs/let#%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87" target="_blank" rel="noopener">不存在变量提升</a>，虽然后面解释了暂时性死区，但……</p><p>总结：被安排明白了。根据 @Ahonn 所说，这个问题在高程有讲过，书读少了读少了</p><p>（最后感谢所有被引用的文章和作者，谢谢。）</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Round-1&quot;&gt;&lt;a href=&quot;#Round-1&quot; class=&quot;headerlink&quot; title=&quot;Round 1&quot;&gt;&lt;/a&gt;Round 1&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;- 我现在把所有东西都注释掉，改成这样&lt;br&gt;function a() {&lt;br&gt;  return inner;&lt;br&gt;  let inner;&lt;br&gt;}&lt;br&gt;返回什么？&lt;/p&gt;
&lt;p&gt;- 那就应该 undefined 了，反正后面不执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自信的不行，出了门掏出全世界最牛逼的千元机&lt;strong&gt;坚果 Pro 2S&lt;/strong&gt;，验证了一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;inner is not defined&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;确实是不执行，但好像不是 &lt;code&gt;undefined&lt;/code&gt; 啊╭(*ﾟДﾟ*)╮&lt;/p&gt;
&lt;h4 id=&quot;Round-2&quot;&gt;&lt;a href=&quot;#Round-2&quot; class=&quot;headerlink&quot; title=&quot;Round 2&quot;&gt;&lt;/a&gt;Round 2&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;- 如果改成这样呢&lt;br&gt;function a() {&lt;br&gt;  function inner() {}&lt;br&gt;  return inner;&lt;br&gt;  let inner;&lt;br&gt;}&lt;br&gt;返回什么？&lt;/p&gt;
&lt;p&gt;- 返回方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自信的不行，同样用全世界最牛逼的千元机&lt;strong&gt;坚果 Pro 2S&lt;/strong&gt;，验证了一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Identifier ‘inner’ has already been declared&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(ﾟДﾟ≡ﾟдﾟ)!? 你在返回你🐴呢？&lt;br&gt;
    
    </summary>
    
      <category term="编程议论" scheme="https://colmugx.github.io/blog/categories/%E7%BC%96%E7%A8%8B%E8%AE%AE%E8%AE%BA/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>最后的 Nlvi</title>
    <link href="https://colmugx.github.io/blog/2019/03/25/bye-nlvi/"/>
    <id>https://colmugx.github.io/blog/2019/03/25/bye-nlvi/</id>
    <published>2019-03-25T06:34:53.000Z</published>
    <updated>2019-04-17T09:39:37.597Z</updated>
    
    <content type="html"><![CDATA[<p><code>Nlvi</code> 可以说起源于正准备上班和刚上班工作不饱和(大雾。为了练习自己对语义化 HTML 理解和 CSS 的渐进式学习而诞生的，到现在已经 2 年了。</p><p>那个时候还用 iPad 画草图然后慢慢写起来，而且当时编程能力确实还挺弱，hexo 很多都弄不清楚。现在对 hexo 就熟悉很多了，设计稿也从随便画画变成了用 sketch，但也是杀鸡用牛刀。</p><p>过程中也是各种骚想法，比如用 Vue/React 改写啊；脱离 jQuery 啊；用 pjax 啊；用更复杂的动画啊……不过我现在想的是：新版本(我博客正在用的半成品)做完之后，就不想迭代了。</p><p>为什么？因为一旦工作太忙没时间，又想到这个东西，好累啊……</p><p>但，我的意思是，<strong>我不想维护 hexo 版本的 Nlvi 了</strong>，我的意思是，诶嘿嘿嘿嘿嘿！<br><a id="more"></a></p><p>所以 2.0 到 3.0 大概的改动会是：</p><ul><li>根据我对统一风格的想法，(又)变动部分设计风格</li><li>根据我对统一风格的想法，调整部分部件展示形式</li><li>根据我对统一风格的想法，对颜色变量重新管理</li><li>去掉以前的标签云，重写一个</li><li>去掉以前的搜索框，重写一个</li><li>变动部分不成熟动画，改动动画曲线</li><li><strong>加入渐变色的设定！(Maybe)</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Nlvi&lt;/code&gt; 可以说起源于正准备上班和刚上班工作不饱和(大雾。为了练习自己对语义化 HTML 理解和 CSS 的渐进式学习而诞生的，到现在已经 2 年了。&lt;/p&gt;
&lt;p&gt;那个时候还用 iPad 画草图然后慢慢写起来，而且当时编程能力确实还挺弱，hexo 很多都弄不清楚。现在对 hexo 就熟悉很多了，设计稿也从随便画画变成了用 sketch，但也是杀鸡用牛刀。&lt;/p&gt;
&lt;p&gt;过程中也是各种骚想法，比如用 Vue/React 改写啊；脱离 jQuery 啊；用 pjax 啊；用更复杂的动画啊……不过我现在想的是：新版本(我博客正在用的半成品)做完之后，就不想迭代了。&lt;/p&gt;
&lt;p&gt;为什么？因为一旦工作太忙没时间，又想到这个东西，好累啊……&lt;/p&gt;
&lt;p&gt;但，我的意思是，&lt;strong&gt;我不想维护 hexo 版本的 Nlvi 了&lt;/strong&gt;，我的意思是，诶嘿嘿嘿嘿嘿！&lt;br&gt;
    
    </summary>
    
      <category term="日常吐槽" scheme="https://colmugx.github.io/blog/categories/%E6%97%A5%E5%B8%B8%E5%90%90%E6%A7%BD/"/>
    
    
      <category term="nlvi" scheme="https://colmugx.github.io/blog/tags/nlvi/"/>
    
      <category term="colmugx" scheme="https://colmugx.github.io/blog/tags/colmugx/"/>
    
  </entry>
  
  <entry>
    <title>做不完的题目</title>
    <link href="https://colmugx.github.io/blog/2019/03/23/last-test-questions/"/>
    <id>https://colmugx.github.io/blog/2019/03/23/last-test-questions/</id>
    <published>2019-03-23T06:00:50.000Z</published>
    <updated>2019-03-26T15:48:18.322Z</updated>
    
    <content type="html"><![CDATA[<p>又在「杂乱的工作台上」完成文章……</p><p>没错又错过一个非常好的机会。与其说是因为时间不够做不完，还不如说是因为陷入斐波那契思考导致做不完。</p><p>不留遗憾，把它搞完。题源就不说了。<br><a id="more"></a></p><h3 id="1-现有-a-b-c-d-四个接口，找出最快的那个。异步用-setTimeout-模拟"><a href="#1-现有-a-b-c-d-四个接口，找出最快的那个。异步用-setTimeout-模拟" class="headerlink" title="1. 现有 /a, /b, /c, /d 四个接口，找出最快的那个。异步用 setTimeout 模拟"></a>1. 现有 /a, /b, /c, /d 四个接口，找出最快的那个。异步用 setTimeout 模拟</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requests: <span class="built_in">Promise</span>&lt;<span class="built_in">string</span>&gt;[]</span><br><span class="line">  = [<span class="string">'/a'</span>, <span class="string">'/b'</span>, <span class="string">'/c'</span>, <span class="string">'/d'</span>]</span><br><span class="line">  .map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">1000</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">`<span class="subst">$&#123;v&#125;</span> spent <span class="subst">$&#123;time&#125;</span>`</span>)</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race(requests).then(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又在「杂乱的工作台上」完成文章……&lt;/p&gt;
&lt;p&gt;没错又错过一个非常好的机会。与其说是因为时间不够做不完，还不如说是因为陷入斐波那契思考导致做不完。&lt;/p&gt;
&lt;p&gt;不留遗憾，把它搞完。题源就不说了。&lt;br&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="TypeScript" scheme="https://colmugx.github.io/blog/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Redux —— combineReducers</title>
    <link href="https://colmugx.github.io/blog/2019/03/08/combinereducers/"/>
    <id>https://colmugx.github.io/blog/2019/03/08/combinereducers/</id>
    <published>2019-03-08T06:49:12.000Z</published>
    <updated>2019-03-24T08:48:51.504Z</updated>
    
    <content type="html"><![CDATA[<p>事出有因，写 <code>rabbit</code> 的时候，一条单测出了问题</p><blockquote><p>Reducer _object returned undefined during initialization.</p></blockquote><p>想来必然是 <code>reducer</code> 缺少默认的 <code>state</code> 所致，<del>但是我的单测是从 <code>dva</code> 直接拿过来改改就用的，应该不会出现问题，所以一定是哪里出了差错。后面发现了，虽然 <code>dva</code> 可以接受 <code>reducers</code> 是空对象，但应用运行起来有一样问题。</del></p><p>主要是这个问题无伤大雅，<code>model</code> 不会出现只有 <code>reducers</code> 这种情况。我也给出了解决：构建 <code>reducer</code> 给一个默认 <code>state</code> 顶着（但我认为一个 <code>model</code> 应该强制存在 <code>state</code>）</p><p>显然这次并不想讲这个，而是想理解 <code>combineReducers</code><br><a id="more"></a><br><code>combineReducers</code> 一共有 4 个方法：</p><ul><li><code>getUndefinedStateErrorMessage</code></li><li><code>getUnexpectedStateShapeWarningMessage</code></li><li><code>assertReducerShape</code></li><li>(主要方法) <code>combineReducers</code></li></ul><h3 id="getUndefinedStateErrorMessage"><a href="#getUndefinedStateErrorMessage" class="headerlink" title="getUndefinedStateErrorMessage"></a>getUndefinedStateErrorMessage</h3><p>很明显，这是一个生成错误信息的方法。主要是限制 <code>reducer</code> 必须返回 <code>state</code></p><h3 id="assertReducerShape"><a href="#assertReducerShape" class="headerlink" title="assertReducerShape"></a>assertReducerShape</h3><p>这是一个检查 <code>reducer</code> 是否合规的方法。</p><p>首先接受一个集合所有 <code>reducer</code> 的对象进行遍历，每一个抽出来检验，做一次运行尝试，看是否能得到 <code>state</code>。如果得到的 <code>state</code> 为  <code>undefined</code> 则该 <code>reducer</code> 是非法的。</p><p>文中开头提到的问题正是由这里报出，因为我们给出的 <code>reducers</code> 为空对象，且 <code>state</code> 为 <code>undefined</code>，所以自然会报错。<code>dva</code> 的单测只检查 <code>model</code> 的合理性，且 <code>state</code> 允许任何内容和 <code>reducers</code> 允许空对象，并没有考虑一个 <code>model</code> 同时不存在这两者的情况，不过显然没意义，所以目前是不清楚 <code>dva</code> 团队是没想到还是也觉得无所谓。</p><h3 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h3><p>这是这组方法中的核心，该方法也作为默认方法导出。这组方法的目的是把一群 <code>reducer</code> 合并为一个方法供 <code>createStore</code> 使用。</p><p>上来是两组变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提取对象中所有字段名，一个 key 对应一个 reducer 方法</span></span><br><span class="line"><span class="keyword">const</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers)</span><br><span class="line"><span class="comment">// 由下面可得，该变量用来暂存基本合理（reducer 是一个方法）的 reducer 方法。</span></span><br><span class="line"><span class="keyword">const</span> finalReducers = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">'function'</span>) &#123;</span><br><span class="line">  finalReducers[key] = reducers[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果在非生产环境中，还会提示仅有 key 没有方法的值以方便我们修改调试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再把初步验证过的 reducer 取出</span></span><br><span class="line"><span class="keyword">const</span> finalReducerKeys = <span class="built_in">Object</span>.keys(finalReducers)</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> shapeAssertionError</span><br><span class="line"><span class="comment">// 放入刚刚用来验证 reducer 合规的方法进行第二次验证，并做错误处理</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  assertReducerShape(finalReducers)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  shapeAssertionError = e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是返回一个新的 <code>reducer</code>，并对所有传入的合规的 <code>reducer</code> 进行 diff。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个对比记录变量以及新 state</span></span><br><span class="line"><span class="keyword">let</span> hasChanged = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> nextState = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历刚刚验证完的 reducer key 数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> key = finalReducerKeys[i]</span><br><span class="line">  <span class="keyword">const</span> reducer = finalReducers[key]</span><br><span class="line">  <span class="comment">// 获取当前 state</span></span><br><span class="line">  <span class="keyword">const</span> previousStateForKey = state[key]</span><br><span class="line">  <span class="comment">// 通过执行 reducer 得到新的 state</span></span><br><span class="line">  <span class="keyword">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> nextStateForKey === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> errorMessage = getUndefinedStateErrorMessage(key, action)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(errorMessage)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 并将新 reducer 产物绑定到 nextState，key 不变。（方便对比）</span></span><br><span class="line">  nextState[key] = nextStateForKey</span><br><span class="line">  <span class="comment">// 右式第一个 hasChanged 表达：如果已经为 true 那么就肯定 true，没必要再去对比验证</span></span><br><span class="line">  hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回：有改变的返回新的，无改变返回原 state。</span></span><br><span class="line"><span class="keyword">return</span> hasChanged ? nextState : state</span><br></pre></td></tr></table></figure><p>所以这组方法目的就是把所有复杂的 <code>reducer</code> 和 <code>state</code> 组成新的状态树，统一管理。业务开发时可以根据需求拆分多个 <code>reducer</code> 和 <code>state</code>，便于开发和组织。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事出有因，写 &lt;code&gt;rabbit&lt;/code&gt; 的时候，一条单测出了问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Reducer _object returned undefined during initialization.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想来必然是 &lt;code&gt;reducer&lt;/code&gt; 缺少默认的 &lt;code&gt;state&lt;/code&gt; 所致，&lt;del&gt;但是我的单测是从 &lt;code&gt;dva&lt;/code&gt; 直接拿过来改改就用的，应该不会出现问题，所以一定是哪里出了差错。后面发现了，虽然 &lt;code&gt;dva&lt;/code&gt; 可以接受 &lt;code&gt;reducers&lt;/code&gt; 是空对象，但应用运行起来有一样问题。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;主要是这个问题无伤大雅，&lt;code&gt;model&lt;/code&gt; 不会出现只有 &lt;code&gt;reducers&lt;/code&gt; 这种情况。我也给出了解决：构建 &lt;code&gt;reducer&lt;/code&gt; 给一个默认 &lt;code&gt;state&lt;/code&gt; 顶着（但我认为一个 &lt;code&gt;model&lt;/code&gt; 应该强制存在 &lt;code&gt;state&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;显然这次并不想讲这个，而是想理解 &lt;code&gt;combineReducers&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="Redux" scheme="https://colmugx.github.io/blog/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>看过 Redux 之后，我写了一个不负责任的状态管理</title>
    <link href="https://colmugx.github.io/blog/2019/03/02/about-redux/"/>
    <id>https://colmugx.github.io/blog/2019/03/02/about-redux/</id>
    <published>2019-03-02T10:00:19.000Z</published>
    <updated>2019-03-25T06:39:45.803Z</updated>
    
    <content type="html"><![CDATA[<p>我们现在小程序需要使用状态管理，但因为项目体量实在很小又没必要使用 redux 或者 mobx。所以我打算不负责任的写一个。</p><h3 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h3><p>Redux 最核心的部分，提供基础的功能。<code>createStore</code>接受三个参数：<code>reducer</code>, <code>initialState</code>, <code>enhancer</code>。前两个比较好理解，<code>enhancer</code>主要用在接受中间件中。返回产物我们主要使用三个方法：<code>getState</code>, <code>dispatch</code>, <code>subscribe</code>。</p><ul><li><code>getState</code>：获取当前 state 值</li><li><code>subscribe</code>：接受监听，存入 <code>listeners</code> 池中</li><li><code>dispatch</code>：处理 <code>reducer</code> 操作，触发 <code>listeners</code> 方法<a id="more"></a>所有我们需要的东西都了解清楚了，其他的功能和边缘保护先不考虑，这也是为什么说是不负责任的状态管理(逃</li></ul><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">store</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currentState = state || &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> listeners = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; getState, dispatch, subscribe &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentState</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line">    listeners.push(listener)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    action.call(<span class="keyword">this</span>, currentState)</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">f</span> =&gt;</span> f.call(<span class="literal">null</span>))</span><br><span class="line">    <span class="keyword">return</span> currentState</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里修改了一些：订阅没有返回取消订阅操作。原因是懒。。<code>dispatch</code> 并不是接受一个纯函数进行数据更新，而是直接由业务修改状态然后通知更新，所以这其实不能算是一个 redux 产物，并且这很不可控。所以这更像是为了利用<code>react-redux</code>或者<code>taro-redux</code>而产生的一种状态保存方式。</p><p>原因还是业务比较简单，就是为了存几个不是很关键的数据但不想使用小程序的 <code>storage</code> 去管理而产生的方法。现在不仅满足业务，压缩后也只有 <code>270b</code> 左右，省点空间给小程序代码，有点赚的实际上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们现在小程序需要使用状态管理，但因为项目体量实在很小又没必要使用 redux 或者 mobx。所以我打算不负责任的写一个。&lt;/p&gt;
&lt;h3 id=&quot;createStore&quot;&gt;&lt;a href=&quot;#createStore&quot; class=&quot;headerlink&quot; title=&quot;createStore&quot;&gt;&lt;/a&gt;createStore&lt;/h3&gt;&lt;p&gt;Redux 最核心的部分，提供基础的功能。&lt;code&gt;createStore&lt;/code&gt;接受三个参数：&lt;code&gt;reducer&lt;/code&gt;, &lt;code&gt;initialState&lt;/code&gt;, &lt;code&gt;enhancer&lt;/code&gt;。前两个比较好理解，&lt;code&gt;enhancer&lt;/code&gt;主要用在接受中间件中。返回产物我们主要使用三个方法：&lt;code&gt;getState&lt;/code&gt;, &lt;code&gt;dispatch&lt;/code&gt;, &lt;code&gt;subscribe&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getState&lt;/code&gt;：获取当前 state 值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;subscribe&lt;/code&gt;：接受监听，存入 &lt;code&gt;listeners&lt;/code&gt; 池中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dispatch&lt;/code&gt;：处理 &lt;code&gt;reducer&lt;/code&gt; 操作，触发 &lt;code&gt;listeners&lt;/code&gt; 方法
    
    </summary>
    
      <category term="实践尝试" scheme="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>一位赌狗前端的自我修养</title>
    <link href="https://colmugx.github.io/blog/2018/11/19/gamble-fn/"/>
    <id>https://colmugx.github.io/blog/2018/11/19/gamble-fn/</id>
    <published>2018-11-19T09:57:59.000Z</published>
    <updated>2018-11-20T07:14:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>这两个月工作巨多，直到今天才有时间写点骚东西。</p><p>可是要写点什么比较好呢？这时候看到了隔壁桌面上放着一张福彩，我脑子里有画面了。（所以这位赌狗不是我，我不买彩票）</p><p>为了方便以后支持更多的彩票，直接搞个类</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Gamble &#123;</span><br><span class="line">    <span class="keyword">static</span> dualColor(red: <span class="built_in">number</span> = <span class="number">6</span>, blue: <span class="built_in">number</span> = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> reds: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">1</span>, <span class="number">33</span>];</span><br><span class="line">        <span class="keyword">const</span> blues: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">1</span>, <span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">this</span>.randomVal(reds, red), <span class="keyword">this</span>.randomVal(blues, blue)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> randomVal(</span><br><span class="line">        fromto: <span class="built_in">number</span>[],</span><br><span class="line">        total: <span class="built_in">number</span>,</span><br><span class="line">        temp: <span class="built_in">number</span>[] = [],</span><br><span class="line">    ): <span class="built_in">number</span>[] &#123;</span><br><span class="line">        <span class="keyword">const</span> [head, ...body] = (!temp.length</span><br><span class="line">            ? [...Array(fromto[<span class="number">1</span>]).keys()]</span><br><span class="line">                  .map(<span class="function"><span class="params">item</span> =&gt;</span> item + <span class="number">1</span>)</span><br><span class="line">                  .splice(fromto[<span class="number">0</span>] - <span class="number">1</span>)</span><br><span class="line">            : fromto</span><br><span class="line">        ).sort(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">return</span> !total</span><br><span class="line">            ? temp</span><br><span class="line">            : <span class="keyword">this</span>.randomVal(body, total - <span class="number">1</span>, temp.concat(head));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两个月工作巨多，直到今天才有时间写点骚东西。&lt;/p&gt;
&lt;p&gt;可是要写点什么比较好呢？这时候看到了隔壁桌面上放着一张福彩，我脑子里有画面了。（所以这位赌狗不是我，我不买彩票）&lt;/p&gt;
&lt;p&gt;为了方便以后支持更多的彩票，直接搞个类&lt;/p&gt;
&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="曲苑杂坛" scheme="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/"/>
    
    
      <category term="TypeScript" scheme="https://colmugx.github.io/blog/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>记在NPM抢空包名的经历</title>
    <link href="https://colmugx.github.io/blog/2018/07/12/kill-parentless-on-npm/"/>
    <id>https://colmugx.github.io/blog/2018/07/12/kill-parentless-on-npm/</id>
    <published>2018-07-12T07:10:23.000Z</published>
    <updated>2019-03-22T16:07:34.681Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>强烈谴责某些大厂，前端或者说 JavaScript 是一个极其依赖社区环境的语言，你们在招人之前能不能先调查一下准新人有没有在社区为非作歹？</p></blockquote><p>年前想搞定<code>React</code>的时候想了个骚操作：尝试用<code>React</code>的思路去做<code>Vue</code>的事情。又诞生了「Vue生态统一可以聚合」的骚想法，开始产生做<code>Ahri</code>的念头。想着那得搞个 npm 包吧，孤儿上线了。</p><p>嘛，在 npm 拿《英雄联盟》英雄名字抢注包名的做法都很弱智了，还“大义凛然”的在描述里写着：<code>League of Legends hero.</code></p><p>关于第一次遇到它的时候，我就想算了，重新找合适的名字吧，但后来因为其他原因就搁置了。现在重新回坑，依然遇到这个问题，这次我不忍了，我打算找 npm 肛他！</p><a id="more"></a><h3 id="寻找入口"><a href="#寻找入口" class="headerlink" title="寻找入口"></a>寻找入口</h3><p>首先看了<code>profile</code>页，发现没有举报入口。（从这里进了Twitter，让人感觉这是一个为了装逼而活着的人。</p><p>看看 npm 本身页面有没有什么入口，比如“联系我们”之类的邮箱总有吧，最后在最下面找到了<code>Reporting Abuse</code>。</p><p>不得不说 npm 连“因为名字打起来”的可能都想到了，那“因为孤儿操作”应该也会列入其中吧，果不其然。在骚扰举报一栏找到了控空包的情况：如果有用户注册无用空包，或者利用包进行乱七八糟的活动，可能有两种措施：ban 了这个用户；清除这些东西。</p><p>我一看到可以 ban 了他我就可兴奋了，于是，发邮件走起。</p><h3 id="采取行动"><a href="#采取行动" class="headerlink" title="采取行动"></a>采取行动</h3><p>操起我400分的4级水平英语，就开始写。</p><blockquote><p>hi,<br>here a profile page: xxxxxx.</p><p>this account keep a lot of empty packages which name as a role name in a game, it cause difficulty for me.</p><p>I NEED HELP! THANK YOU!</p></blockquote><p>过了一会收到回信：</p><blockquote><p>Our support hours are Monday through Friday, 9:00AM - 6:00PM PST, excluding US holidays.</p><p>Your request is being reviewed by our support staff and we’ll be responding soon.</p><p>To add additional comments, reply to this email.</p></blockquote><p>噢，没在工作时间还行。过了几秒又收到一封邮件：</p><blockquote><p>Hey there,</p><p>Thank you for reaching out. We hope you’re having a great week thus far, and are looking forward to responding to your request.</p><p>The npm support staff will be off on Wednesday, July 4th in observance of Independence Day. Due to this, you may experience some delay in expected reply times.</p><p>Thanks for your patience.</p></blockquote><p>狗屎还带放假的？美国员工真的舒服啊，不加班，节假日放满。像我们这种997节假日还放不满的简直受到了6把无尽的暴击。</p><p>等了几天发现不对，没理我，再按照第一封发了一次，这次过了半天多才回。这次差点就怕我气到了，大概的意思就是你上次的 ticket 还没解决，如果你没问题了我们就关了。。。美国人上班都这么摸的？</p><p>又过了半天收到一封邮件，这次是技术客服（邮件是有人名的大佬）发来的：</p><blockquote><p>Thanks for reaching out.</p><p>I was not able to find an account associated with (我发信的邮箱). Was there a specific one of these user’s package names you are interested in for a project?</p><p>If so, we may assist you with a transfer request or granting access to that package, depending on the package and contents.</p></blockquote><p>有点着急，看了第一句之后，下面没仔细看，就有点想搞他，我就回信了。信的内容大概是这样：谢谢你的回复。这是我的项目名字（发了<code>Ahri</code>的GitHub Repo），这是我的 npm 账号（意识到发信的账号不对）。我对<code>Ahri</code>有兴趣，但他是个空的而且被占用了，我没办法使用，对吧？还有这个 B 恶意占用了大量的空包（跟上孤儿账号），他是不是同时违反了规则，是不是应该有所动作？</p><p>第二天（有时差），收到了回信，说包名已经转移到我的账号上：</p><blockquote><p>Thanks for getting back to me with that information.</p><p>It’s all yours now, but you won’t be able to re-use any version numbers used by the previous author. In fact, I’d suggest publishing your first update as a major release, i.e., v1.0.0. Please publish an update to the package as soon as possible with your code.</p></blockquote><p>我上了我的 npm 看了一眼，惊了..这就拿到了..</p><p>但并没有解放其他的空包和 <strong>ban 了他</strong>，这点我有点失望。总之，要到想要的包，这才是想要的结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;强烈谴责某些大厂，前端或者说 JavaScript 是一个极其依赖社区环境的语言，你们在招人之前能不能先调查一下准新人有没有在社区为非作歹？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;年前想搞定&lt;code&gt;React&lt;/code&gt;的时候想了个骚操作：尝试用&lt;code&gt;React&lt;/code&gt;的思路去做&lt;code&gt;Vue&lt;/code&gt;的事情。又诞生了「Vue生态统一可以聚合」的骚想法，开始产生做&lt;code&gt;Ahri&lt;/code&gt;的念头。想着那得搞个 npm 包吧，孤儿上线了。&lt;/p&gt;
&lt;p&gt;嘛，在 npm 拿《英雄联盟》英雄名字抢注包名的做法都很弱智了，还“大义凛然”的在描述里写着：&lt;code&gt;League of Legends hero.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;关于第一次遇到它的时候，我就想算了，重新找合适的名字吧，但后来因为其他原因就搁置了。现在重新回坑，依然遇到这个问题，这次我不忍了，我打算找 npm 肛他！&lt;/p&gt;
    
    </summary>
    
      <category term="曲苑杂坛" scheme="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/"/>
    
    
      <category term="colmugx" scheme="https://colmugx.github.io/blog/tags/colmugx/"/>
    
  </entry>
  
  <entry>
    <title>我就写个方法，这么麻烦？</title>
    <link href="https://colmugx.github.io/blog/2018/07/04/different-function/"/>
    <id>https://colmugx.github.io/blog/2018/07/04/different-function/</id>
    <published>2018-07-04T07:06:43.000Z</published>
    <updated>2019-03-22T16:07:34.681Z</updated>
    
    <content type="html"><![CDATA[<p>最近想到一个问题：为什么JavaScript定义一个函数有那么多种形式，是历史残留还是为了装逼？研究了一下发现还是有区别的。</p><p>JavaScript中定义一个方法主要可以分成两种形式：</p><ul><li>函数声明</li><li>函数表达式</li></ul><a id="more"></a><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>声明体是最普通的，其他语言也相近的一种方式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>不过，毕竟是「函数就是爸爸」的JavaScript！它有一个特性：函数提升。</p><blockquote><p>函数提升：把所有函数提升到当前作用域上，从而做到了可以“未声明先调用”。</p></blockquote><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>这可能是目前用的最多的声明方式，因为可以搭配箭头函数假装自己用的是函数式编程。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数版本</span></span><br><span class="line"><span class="keyword">const</span> funcA = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>但变量受作用域影响，所以<code>const</code>和<code>let</code>并没有变量提升的能力。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">funcA(<span class="number">1</span>) <span class="comment">// ReferenceError: funcA is not defined</span></span><br><span class="line"><span class="keyword">const</span> funcA = <span class="function"><span class="params">a</span> =&gt;</span> a</span><br></pre></td></tr></table></figure></p><p>燃鹅，这才刚刚开始……</p><h3 id="匿名-amp-具名"><a href="#匿名-amp-具名" class="headerlink" title="匿名 &amp; 具名"></a>匿名 &amp; 具名</h3><p>匿名就是上面那种，具名就是给函数本体再起一个名字。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="keyword">function</span> <span class="title">funcName</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>这样有什么区别？后面那个名字又不能用！答案还是有区别的。</p><p>首先有一个函数名推断，比如上面这个函数，那么<code>func.name</code>会返回<code>funcName</code>。如果匿名函数的话<code>[fn].name</code>会返回<code>&#39;&#39;</code>。其次这个名字可以在函数内部使用。当然了指代的就是自己了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="keyword">function</span> <span class="title">funcName</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &lt; <span class="number">0</span> ? b : funcName(a+<span class="number">1</span>-b, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">431</span>, <span class="number">151</span>) <span class="comment">// 281</span></span><br><span class="line">funcName(<span class="number">431</span>, <span class="number">151</span>) <span class="comment">// ReferenceError: funcName is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(func.name) <span class="comment">// funcName</span></span><br><span class="line"><span class="keyword">typeof</span> funcName === <span class="string">'function'</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>所以这种方式最适合递归函数了。</p><h3 id="函数表达式依然是个常-变量"><a href="#函数表达式依然是个常-变量" class="headerlink" title="函数表达式依然是个常/变量"></a>函数表达式依然是个常/变量</h3><p>把它当做一个“方程”来看吧，关键词已经决定了这个“量”会以什么形式存在，比如<code>var</code>和<code>let</code>是变量，<code>const</code>是常量，并且<code>let</code>还有作用域范围。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> funcA = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'A'</span>)</span><br><span class="line">funcA() <span class="comment">// A</span></span><br><span class="line">funcA = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'AA'</span>) <span class="comment">// TypeError: Assignment to constant variable.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funcB = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'B'</span>)</span><br><span class="line">funcB() <span class="comment">// B</span></span><br><span class="line">funcB = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'BB'</span>)</span><br><span class="line">funcB() <span class="comment">// BB</span></span><br></pre></td></tr></table></figure></p><p>题外话：那么就有个老生常谈的问题了，函数表达式按道理来讲是“灵活的”，那么下面这个函数会是什么结果？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'B'</span>)</span><br><span class="line">&#125;</span><br><span class="line">funcB() <span class="comment">// BB</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'BB'</span>)</span><br><span class="line">&#125;</span><br><span class="line">funcB() <span class="comment">// BB</span></span><br></pre></td></tr></table></figure></p><p>为什么？还是那句话：JavaScript世界中，函数是你爹！</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>又到了大家最最喜欢的箭头函数环节，现在还有谁是不愿意写箭头函数的？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="params">a</span> =&gt;</span> b =&gt; a + b</span><br><span class="line">func(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>在这篇文章：<a href="/blog/2017/03/03/js-this/">《关于JavaScript的this》</a>已经被安排的明明白白了。</p><p>实际上现在看这篇文章也有点问题，年轻的时候牛批吹多了。总结箭头函数两个特点就是：</p><ul><li>不会创造上下文（自身无this）</li><li>必然是个匿名函数</li><li>没有 <code>arguments</code></li></ul><p>不是两个吗？怎么变成三个了？此时你可能会回去检查刚刚那句话，然后我现在悄悄告诉你，（第三点是送的）。</p><h3 id="计算属性函数名"><a href="#计算属性函数名" class="headerlink" title="计算属性函数名"></a>计算属性函数名</h3><p>这个应该是在“对象”的环境中存在，毕竟对象可以指代很多种只要是对象的情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;</span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'b'</span>](a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object.ab(<span class="number">1</span>, <span class="number">3</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>这就实现了“函数名可以暂时不知道是什么”的情况，通过计算来得到这个函数。</p><h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><h3 id="new-Function"><a href="#new-Function" class="headerlink" title="new Function"></a>new Function</h3><p>这是一个不知道哪里可以用得上但是就是可以用的方式：通过对象创建<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'return a + b'</span>)</span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><h3 id="函数参数初始值"><a href="#函数参数初始值" class="headerlink" title="函数参数初始值"></a>函数参数初始值</h3><p>可能有一定需求，但可能没有<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a = <span class="number">1</span>, b = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>可能我们更常用的有这些<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> funcA = <span class="function">(<span class="params">obj = &#123;&#125;</span>) =&gt;</span> obj</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> funcB = <span class="function">(<span class="params">arr = []</span>) =&gt;</span> arr</span><br></pre></td></tr></table></figure></p><p>但JavaScript毕竟是「函数是第一公民」的语言，有机会会写到很多高阶函数。所以<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function">(<span class="params">fn = (</span>) =&gt;</span> <span class="string">'💉💧🐮🍺'</span>) =&gt; fn.call(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure></p><p>凭什么函数作为参数就不能有初始值呢？当然是可以的呀！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近想到一个问题：为什么JavaScript定义一个函数有那么多种形式，是历史残留还是为了装逼？研究了一下发现还是有区别的。&lt;/p&gt;
&lt;p&gt;JavaScript中定义一个方法主要可以分成两种形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数声明&lt;/li&gt;
&lt;li&gt;函数表达式&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>关于四轴的踩坑指南</title>
    <link href="https://colmugx.github.io/blog/2018/03/12/dji-interview/"/>
    <id>https://colmugx.github.io/blog/2018/03/12/dji-interview/</id>
    <published>2018-03-12T02:39:13.000Z</published>
    <updated>2019-04-17T09:38:15.730Z</updated>
    
    <content type="html"><![CDATA[<p>怎么可能真的是四轴的踩坑指南，其实是大疆的受苦之旅。恼羞成怒下单了<code>mavic air</code>（所以dji还是赚了？）</p><p>怎么可能会让你回去还能等到通知，人家HR明明都告诉我面试入职一条龙了！算了本来就是自己的问题，能一路到看到四个大佬都是赚的。面试结束还送了架精灵还有一块工牌！（虽然是纸精灵和工牌套子。</p><p>总结一下印象深刻受苦的问题和答案，不过有一点想吐槽的…就<code>vue</code>和<code>react</code>之间的关系和选择，我看到了高一文理科分班的那种影子：人家都是哪科分高选哪科，我是选分低 + 主管臆想……<br><a id="more"></a></p><h3 id="html5-css3"><a href="#html5-css3" class="headerlink" title="html5 css3"></a>html5 css3</h3><p>css3：圆角，变形，线性渐变，阴影。后两个没答，另外阴影我一直以为是<code>css2</code>的。</p><p>html5: 算了挺多的…基本上用过的都说了一遍… 下次记得背一下（真的需要用到那么多？</p><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><h3 id="created-和-mounted-区别，ajax会在哪里操作"><a href="#created-和-mounted-区别，ajax会在哪里操作" class="headerlink" title="created 和 mounted 区别，ajax会在哪里操作"></a>created 和 mounted 区别，ajax会在哪里操作</h3><blockquote><p>放在 created，因为 mounted 的时候还没有渲染节点。</p></blockquote><p>虽然这个问题也有一些讨论，有些会在<code>created</code>就做了，有些是在<code>mounted</code>做。</p><p>有问题吗？还真有。因为我想到的是：在<code>created</code>过程把数据获取之后，从虚拟dom转为真实dom的时候可以顺便把数据带进去。而不需要一整个组件都创建完整之后再去加载数据。毕竟到<code>mounted</code>的时候实例都建立完了，这个时候再刷新数据不是会引起刷新/重绘？不过这个问题不应该是我没看源码的问题，而是有些问题没了解透彻，或者说，文章看太少。</p><p>恰好就坑这了，要的就是在<code>mounted</code>，因为这个时候已经有组件实例了，也就是<code>this.$el</code>已经有树了，如果<code>ajax</code>过来的内容是需要依赖<code>el</code>的话，那在<code>created</code>的时候还没有东西呢。</p><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue生命周期图示"></p><h3 id="深度-watcher"><a href="#深度-watcher" class="headerlink" title="深度 watcher"></a>深度 watcher</h3><p>去翻了一下文档，我发现翻车的是自己吧！<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c: &#123;</span><br><span class="line">  handler: <span class="function"><span class="keyword">function</span> (<span class="params">val, oldVal</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  deep: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>只需要给对象加个<code>deep</code>就行了,而<code>a.b</code>这种情况应不属于深度watch，这只是需要监听的数据在比较深处而已…</p><h3 id="vue-函数式组件"><a href="#vue-函数式组件" class="headerlink" title="vue 函数式组件"></a>vue 函数式组件</h3><p>这是一个补充问题，关于 什么时候可以使用函数式组件，我觉得确实没什么可以说的啊…</p><p>如果只是充当渲染任务，不需要持久化不需要状态，采用函数式组件可以减少开销。</p><p>总的来说，比较严重的问题还是出现在：表达能力有问题 + 理解框架不够深刻（但远不及原理） + 狗娘的英语表达。还有<code>css</code>过于依赖补全导致想口头表述语句的时候，单词中间那段想不起来所以说不出口导致的丢分。所以打算CSS部分关闭补全一段时间。</p><p>这属于机会完全被自己毁了（还不是技术层面问题），所以烦躁和不甘又有什么用呢…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;怎么可能真的是四轴的踩坑指南，其实是大疆的受苦之旅。恼羞成怒下单了&lt;code&gt;mavic air&lt;/code&gt;（所以dji还是赚了？）&lt;/p&gt;
&lt;p&gt;怎么可能会让你回去还能等到通知，人家HR明明都告诉我面试入职一条龙了！算了本来就是自己的问题，能一路到看到四个大佬都是赚的。面试结束还送了架精灵还有一块工牌！（虽然是纸精灵和工牌套子。&lt;/p&gt;
&lt;p&gt;总结一下印象深刻受苦的问题和答案，不过有一点想吐槽的…就&lt;code&gt;vue&lt;/code&gt;和&lt;code&gt;react&lt;/code&gt;之间的关系和选择，我看到了高一文理科分班的那种影子：人家都是哪科分高选哪科，我是选分低 + 主管臆想……&lt;br&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
      <category term="vue" scheme="https://colmugx.github.io/blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>promise链式调用</title>
    <link href="https://colmugx.github.io/blog/2018/02/28/promise-chaining/"/>
    <id>https://colmugx.github.io/blog/2018/02/28/promise-chaining/</id>
    <published>2018-02-28T02:16:22.000Z</published>
    <updated>2019-03-25T06:37:13.980Z</updated>
    
    <content type="html"><![CDATA[<p>学会了却不会活用是真的菜…</p><p>前几天面试，提到了回调地狱用<code>promise</code>，然后抛出个衍生问题：<code>promise</code>也会嵌套，怎么解决<code>promise</code>的回调地狱。</p><p>我想不到，直接问能不能用<code>ES8</code>，说行，然后我就想到了<code>const p2 = await Promise</code>这种做法。</p><p>可是，我记得我在若干天前才写了一篇关于「JS方法链式调用」。</p><blockquote><p>只要函数返回值是一个函数，就可以连着调用</p></blockquote><p>So,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1.then(<span class="function">(<span class="params">&#123; p2 &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p2</span><br><span class="line">&#125;).then(&#123; p3 &#125; =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学会了却不会活用是真的菜…&lt;/p&gt;
&lt;p&gt;前几天面试，提到了回调地狱用&lt;code&gt;promise&lt;/code&gt;，然后抛出个衍生问题：&lt;code&gt;promise&lt;/code&gt;也会嵌套，怎么解决&lt;code&gt;promise&lt;/code&gt;的回调地狱。&lt;/p&gt;
&lt;p&gt;我想不到，直接问
      
    
    </summary>
    
      <category term="曲苑杂坛" scheme="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>抛下不成熟，开始nvim</title>
    <link href="https://colmugx.github.io/blog/2018/02/13/new-life-nvim/"/>
    <id>https://colmugx.github.io/blog/2018/02/13/new-life-nvim/</id>
    <published>2018-02-13T03:02:00.000Z</published>
    <updated>2019-03-25T06:41:48.996Z</updated>
    
    <content type="html"><![CDATA[<p>想活得跟过去有些区别，活得更有效率该有的样子，而且我讨厌上一年的自己，不知道为什么会这么想。反正，放弃spacemacs开始使用vim了。</p><p>很简单，spacemacs有时候会卡一下，就像十年前的电脑，按了一长串需要等一下才会突突突突全显示出来。后来vscode + vim插件又出现了“不自觉按空格”的情况，就是写完按两下空格调插件。那既然这样的话，从零开始一个vim吧，把leader换成空格然后一些改不过来的习惯换过来就行了。</p><p>实际上，如果不是因为懒，早就该定制编辑器了。。不过我不会放弃vscode，因为还是有些残留。为什么不从零开始一个emacs？成本太高啊，又要vim模式又要改成leader键操作，而且逐渐能理解那个蚊香图是什么意思了。</p><h3 id="iterm2"><a href="#iterm2" class="headerlink" title="iterm2"></a>iterm2</h3><p>宿主用这个，原先很排斥在终端写东西（不能用鼠标），不过后来一手菜鸡操作<code>xj</code>, <code>xk</code>还有<code>wwwwwwww...</code>也能达到需求了，应该没问题了。<br><a id="more"></a><br>14px的<code>menlo nerd</code>，204x60 的<code>full-width top</code>，接近<code>40%</code>的透明度纯黑背景解决字体字符完整显示和启动时自动无边框全屏，还能看到窗后的情况。顺便把热键改成<code>cmd + return</code>（这操作懂得都懂…）</p><h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><p>oh-my-zsh一早就装了，用的<code>avit</code>主题，其他没动。对我来说<code>shell</code>就是<code>shell</code>。</p><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>从刚开始尝试MacVim到后面把这东西干掉，终端vim更新到vim8.0之后，vim一直充当着“顺手改改”的任务。这次因为要半主力编辑器，也不能全靠手打了…</p><p>对ycm印象极差，虽然deoplete支持vim8，弄了一阵子能用但是一出问题麻烦极多；找到了vim-lsp但是资源稀缺，还不会自启服务器！一气之下编译一手<code>neovim</code>，完美。毕竟我要有这脾气我就去从零开始space + emacs了（主要还可以直接抄大佬的配置）。</p><p>至于其他插件，因为还没有实战过还不知道缺哪些东西。先配好的是肯定会用上的，看情况再说。</p><p>另外求一个vim插件，vim有没有像<code>mmm-mode</code>的插件，就是同一个文件可以不同设置高亮或者补全的？用<code>mmm-mode</code>可以在同一文件同时采用<code>emmet-mode</code>和<code>js2-mode</code>，也因为这样解决我<code>vue</code>高亮补全问题…</p><p>然后就是看情况把在<code>spacemacs</code>的片段搬到<code>vim</code>了。</p><h3 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h3><p>其实<code>iterm2</code>也可以胡乱分屏，但是考虑到大佬墙裂推荐。用！</p><p>看到了<code>i3</code>的影子，配置窗口前后颜色，调整了状态栏左右宽度和配色。毕竟还不熟，随意的改成了和vim主题相近的低调配色并加上时钟（着手做电量）。不过我的终端毕竟不是全屏的，顶栏和dock还是会常驻屏幕，所以一堆东西也没什么用。对了，这一套有颜色的主题颜色都采用了<code>one</code>，atom家那个。</p><p>然后剩下的就是通过使用寻找问题了，现在第一个问题就是vim的主题怎么把背景也至少<code>30%</code>的透明，改了主题文件发现一点用都没有。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想活得跟过去有些区别，活得更有效率该有的样子，而且我讨厌上一年的自己，不知道为什么会这么想。反正，放弃spacemacs开始使用vim了。&lt;/p&gt;
&lt;p&gt;很简单，spacemacs有时候会卡一下，就像十年前的电脑，按了一长串需要等一下才会突突突突全显示出来。后来vscode + vim插件又出现了“不自觉按空格”的情况，就是写完按两下空格调插件。那既然这样的话，从零开始一个vim吧，把leader换成空格然后一些改不过来的习惯换过来就行了。&lt;/p&gt;
&lt;p&gt;实际上，如果不是因为懒，早就该定制编辑器了。。不过我不会放弃vscode，因为还是有些残留。为什么不从零开始一个emacs？成本太高啊，又要vim模式又要改成leader键操作，而且逐渐能理解那个蚊香图是什么意思了。&lt;/p&gt;
&lt;h3 id=&quot;iterm2&quot;&gt;&lt;a href=&quot;#iterm2&quot; class=&quot;headerlink&quot; title=&quot;iterm2&quot;&gt;&lt;/a&gt;iterm2&lt;/h3&gt;&lt;p&gt;宿主用这个，原先很排斥在终端写东西（不能用鼠标），不过后来一手菜鸡操作&lt;code&gt;xj&lt;/code&gt;, &lt;code&gt;xk&lt;/code&gt;还有&lt;code&gt;wwwwwwww...&lt;/code&gt;也能达到需求了，应该没问题了。&lt;br&gt;
    
    </summary>
    
      <category term="实践尝试" scheme="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="vim" scheme="https://colmugx.github.io/blog/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>vuex源码理解（二）</title>
    <link href="https://colmugx.github.io/blog/2018/01/30/vuex-study-2/"/>
    <id>https://colmugx.github.io/blog/2018/01/30/vuex-study-2/</id>
    <published>2018-01-30T02:34:11.000Z</published>
    <updated>2019-03-22T16:07:34.680Z</updated>
    
    <content type="html"><![CDATA[<p>继续，这次尝试逐行理解Store类的东西</p><p>然后关于这次，一些“工具函数”都集中在<code>util.js</code>的这种做法，已经够我学的了。这是个很受用的做法。</p><h3 id="一些简单的东西"><a href="#一些简单的东西" class="headerlink" title="一些简单的东西"></a>一些简单的东西</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  assert(Vue, <span class="string">`must call Vue.use(Vuex) before creating a store instance.`</span>)</span><br><span class="line">  assert(<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>, <span class="string">`vuex requires a Promise polyfill in this browser.`</span>)</span><br><span class="line">  assert(<span class="keyword">this</span> <span class="keyword">instanceof</span> Store, <span class="string">`Store must be called with the new operator.`</span>)</span><br><span class="line">&#125; <span class="comment">// 断言函数在util，如果不满足前面的情况，后面以error 排出来</span></span><br><span class="line"><span class="comment">// （实际上就是想看有没有在vue环境中和有没有正确安装）</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  plugins = [],</span><br><span class="line">  strict = <span class="literal">false</span></span><br><span class="line">&#125; = options <span class="comment">// 定义两个变量，在传入的对象中把这两个东西拿出来，字面意思</span></span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里可能是会把整个vuex所有的内容都会规整到这些中</span></span><br><span class="line"><span class="comment">// store internal state</span></span><br><span class="line"><span class="keyword">this</span>._committing = <span class="literal">false</span>  <span class="comment">// commit switch（ -&gt; mutations）</span></span><br><span class="line"><span class="keyword">this</span>._actions = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// actions</span></span><br><span class="line"><span class="keyword">this</span>._actionSubscribers = [] <span class="comment">// 应该像在dva中看到的订阅，没用过也没弄清楚应该怎么用</span></span><br><span class="line"><span class="keyword">this</span>._mutations = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// mutations</span></span><br><span class="line"><span class="keyword">this</span>._wrappedGetters = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// getters</span></span><br><span class="line"><span class="keyword">this</span>._modules = <span class="keyword">new</span> ModuleCollection(options) <span class="comment">// 分模块得到一个类</span></span><br><span class="line"><span class="keyword">this</span>._modulesNamespaceMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>)  <span class="comment">// 命名空间，上一次有讲到</span></span><br><span class="line"><span class="keyword">this</span>._subscribers = [] <span class="comment">// 所有订阅者</span></span><br><span class="line"><span class="keyword">this</span>._watcherVM = <span class="keyword">new</span> Vue() <span class="comment">//watcher??应该跟vue的watcher有关？</span></span><br></pre></td></tr></table></figure><h3 id="开始跳着理解"><a href="#开始跳着理解" class="headerlink" title="开始跳着理解"></a>开始跳着理解</h3><h3 id="store-与-操作绑定"><a href="#store-与-操作绑定" class="headerlink" title="store 与 操作绑定"></a>store 与 操作绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind commit and dispatch to self</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">this</span> <span class="comment">// 把store 是指向 this 的</span></span><br><span class="line"><span class="keyword">const</span> &#123; dispatch, commit &#125; = <span class="keyword">this</span> <span class="comment">// 所以 &#123; dispatch, commit &#125; = store ?</span></span><br><span class="line"><span class="keyword">this</span>.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">boundDispatch</span> (<span class="params">type, payload</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dispatch.call(store, type, payload)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.commit = <span class="function"><span class="keyword">function</span> <span class="title">boundCommit</span> (<span class="params">type, payload, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> commit.call(store, type, payload, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然有注释，就是把 commit, dispatch 和store绑定到<code>this</code>上，然后<code>{ dispatch, commit } = store</code>了。接着class中的<code>dispatch</code>指向刚刚对象中<code>dispatch</code>的方法，通过<code>call</code>用法改变作用域调用。我们用到的<code>this.$store.dispatch</code>应该来源这里，下面同理</p><h3 id="ModuleCollection"><a href="#ModuleCollection" class="headerlink" title="ModuleCollection"></a>ModuleCollection</h3><p>这里感觉很有意思，因为我这是第一次关注vuex的代码，我也不清楚命名空间等这些东西是什么时候加进去的，但我猜测应该是vue2.5之后的内容因为之前没在文档里见过这些东西。</p><p>字面意思，模块收集器。由于现在复杂度的关系，这部分应该先处理一下。把从vue的vuex得到的options，直接传入这个类，然后再进入<code>register</code>方法，接下来的工作就是不断的尾递归（？）得到整棵树。因为现在还有命名空间什么的，所以还有关于命名空间的判断和结合。</p><p>然后还有一些其他方法，比如热更什么的。</p><h3 id="installModule"><a href="#installModule" class="headerlink" title="installModule"></a>installModule</h3><p>使用到的位置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">installModule(<span class="keyword">this</span>, state, [], <span class="keyword">this</span>._modules.root)</span><br></pre></td></tr></table></figure></p><p>Store开始初始化的其中第一个方法。</p><p>这个方法，字面含义就是安装模块，猜测应该是把store相关的东西先配置下来。</p><p>这里有一个点（函数太长了不浪费篇幅了）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isRoot = !path.length</span><br></pre></td></tr></table></figure></p><p>判断是否是根是通过<code>path</code>的长度来做的，如果没长度就是<code>/</code>了，很有意思，对于还没什么经验的我受益匪浅。</p><p>这个函数，需要5个参数，<code>store</code>, <code>rootState</code>, <code>path</code>, <code>module</code>, <code>hot</code>。最后一个应该也跟更新有关系吧？</p><p><code>this</code>在<code>class</code>中，所以指向是<code>class Store</code>的；<code>state</code>是<code>const state = this._modules.root.state</code>得到，而<code>_modules</code>就上面提到的定义了；因为还在根所以没有<code>path</code>，最后传入刚刚各种尾递归得到的树。</p><p>接下来注册命名空间，也就是判断这次的store有没有用到命名空间，有就分成一张张网，摊开处理。</p><p>接下来会遇到一个函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNestedState</span> (<span class="params">state, path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.length</span><br><span class="line">    ? path.reduce(<span class="function">(<span class="params">state, key</span>) =&gt;</span> state[key], state)</span><br><span class="line">    : state</span><br><span class="line">&#125; <span class="comment">// 如果不是根的话会被分配到这里，看需不需要拼凑state，就“三光属性”</span></span><br></pre></td></tr></table></figure></p><p>非根注册应该是文档的<a href="https://vuex.vuejs.org/zh-cn/modules.html" target="_blank" rel="noopener">这里</a>吧，这里提到了模块可以只是局部注册，我们一般都直接在<code>main.js</code>完事儿了。</p><p>然后就是三种操作的模块遍历注册，用到的方法存在<code>module.js</code>，实则还是用到了<code>util.js</code>的遍历方法（通过回调函数返回回去，再次赞叹）</p><p>而注册的方法<code>registerMutation</code> &amp;&amp; <code>registerAction</code> &amp;&amp; <code>registerGetter</code> 就是我们用到的那些例如<code>store.commit(type, payload)</code>的方法。</p><p>然<code>registerAction</code>的方法比其他的复杂得多，它要求<code>handler</code>传入<code>dispatch</code>, <code>commit</code>, <code>getter</code>, <code>state</code>等。显然他命中注定要干一些“脏乱差”的工作。由此也可以得到为什么<code>actions</code>的方法，第一个参数(type)可以传入<code>{dispatch, commit, state}</code>…的东西了。</p><p>题外话：之前在某个论坛看到一个问题，问在vuex中的actions为什么可以取到state，不会造成什么乱七八糟的问题么？我也不知道，问题的答案先留着。不过因为可以得到state，所以我们可以通过现有的state来判断或者操作，这不是更方便了么？</p><h3 id="resetStoreVM"><a href="#resetStoreVM" class="headerlink" title="resetStoreVM"></a>resetStoreVM</h3><p>当一切都准备好了之后，怼进实例。</p><p>实际上前面也有提到，vuex是被vue当做专属插件进行安装的，在Vue实例环境中就可以通过<code>this.$store</code>摸到vuex。然后vuex就可以通过数据的改变来重新得到新的组件或者新的去促进生成得到新的dom。然后在上一篇有讲到那一堆辅助函数，实际上就是控制或者约束操作，但实质就是<code>Vue.$store.dispatch</code>等等等。</p><p>先是从store拿到vm作为旧的vm以作备份（当然如果不存在就不存在备份了），然后让<code>Vue</code>把这段操作定义为静默操作。</p><p>接着生成通过<code>new Vue</code>生成新的vm（假如有旧的也备份了，不会影响），恢复取消静默操作。（意思就是偷偷替换了vm）</p><p>至此新的视图已经更新完成，没有出意外的话，存在的刚刚备份过的旧vm就可以干掉的，执行销毁</p><h3 id="withCommit"><a href="#withCommit" class="headerlink" title="_withCommit()"></a>_withCommit()</h3><p>通篇是没有提到这个函数的，到这里提一下是因为，至此这个函数用了两次，最后一次是发生在刚刚<code>resetStoreVM</code>的最后，如果存在热更的情况下那里。篇幅不长，拿出来看一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_withCommit (fn) &#123;</span><br><span class="line">  <span class="keyword">const</span> committing = <span class="keyword">this</span>._committing</span><br><span class="line">  <span class="keyword">this</span>._committing = <span class="literal">true</span></span><br><span class="line">  fn()</span><br><span class="line">  <span class="keyword">this</span>._committing = committing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>毕竟状态管理，如果谁都能理这个状态，还需要管理干什么。这里的理解可以套入<code>reducer</code>协助理解，<code>state</code>有且仅有<code>reducer</code>可以修改，而vuex的<code>mutations</code>也就是做这份工作的地方。然后<code>_withCommit</code>的话，是个代理来的。</p><p>还是刚刚备份旧vm那个样子，先备份当前状态，然后把该状态转为<code>true</code>，据说是如果不暂时改变状态，严格<code>vuex</code>会认为这是非法操作，是禁止的。</p><p>封印解除之后，执行一下回调（各种需要破例更新的数据），然后再固着。</p><p>为什么这里需要备份状态换回去，而且这里是<code>boolean</code>，非黑即白的。实际上如果这个所谓的开关，在执行这里之前就是关闭的，那道理通过。如果在这之前，开关本来开着，这样你执行一次这里，就又把开关关回去的话，会影响到其他地方的正常工作，这不是一个“合格的秘书”。</p><p>刚刚最后那里的操作<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  oldVm._data.$$state = <span class="literal">null</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>就是假如这里是<code>hot</code>的话，就把旧vm的状态改成<code>null</code>，然后跟这个vm有关的watcher和计算都会被强行触发更新。通过这样让页面不刷新然后刷新dom。</p><p>最后一个问题：为什么明明<code>this</code>指向的是本体(Store)，初始化的时候需要<code>const store = this</code></p><p>回答：JavaScript那么牛逼的<code>this</code>，墙头草属性的，不找个需要固定的位置固定下来肯定会有机会被带偏的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续，这次尝试逐行理解Store类的东西&lt;/p&gt;
&lt;p&gt;然后关于这次，一些“工具函数”都集中在&lt;code&gt;util.js&lt;/code&gt;的这种做法，已经够我学的了。这是个很受用的做法。&lt;/p&gt;
&lt;h3 id=&quot;一些简单的东西&quot;&gt;&lt;a href=&quot;#一些简单的东西&quot; class=&quot;headerlink&quot; title=&quot;一些简单的东西&quot;&gt;&lt;/a&gt;一些简单的东西&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (process.env.NODE_ENV !== &lt;span class=&quot;string&quot;&gt;&#39;production&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  assert(Vue, &lt;span class=&quot;string&quot;&gt;`must call Vue.use(Vuex) before creating a store instance.`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  assert(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt; !== &lt;span class=&quot;string&quot;&gt;&#39;undefined&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;`vuex requires a Promise polyfill in this browser.`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  assert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; Store, &lt;span class=&quot;string&quot;&gt;`Store must be called with the new operator.`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;comment&quot;&gt;// 断言函数在util，如果不满足前面的情况，后面以error 排出来&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// （实际上就是想看有没有在vue环境中和有没有正确安装）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  plugins = [],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  strict = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; = options &lt;span class=&quot;comment&quot;&gt;// 定义两个变量，在传入的对象中把这两个东西拿出来，字面意思&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="vue" scheme="https://colmugx.github.io/blog/tags/vue/"/>
    
      <category term="vuex" scheme="https://colmugx.github.io/blog/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>vuex源码理解（一）</title>
    <link href="https://colmugx.github.io/blog/2018/01/25/vuex-study-1/"/>
    <id>https://colmugx.github.io/blog/2018/01/25/vuex-study-1/</id>
    <published>2018-01-25T15:39:58.000Z</published>
    <updated>2019-03-22T16:07:34.680Z</updated>
    
    <content type="html"><![CDATA[<p>看个代码代价很高，我边读边转笔，然后一个失手把手挑了个滴血不止…（笔头挑掉了一层手皮）</p><p>vuex和dva的源码都想看，不然没办法知道相性在哪。</p><h3 id="由口而入"><a href="#由口而入" class="headerlink" title="由口而入"></a>由口而入</h3><p>这都暴露干净了…<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  Store,</span><br><span class="line">  install,</span><br><span class="line">  version: <span class="string">'__VERSION__'</span>,</span><br><span class="line">  mapState,</span><br><span class="line">  mapMutations,</span><br><span class="line">  mapGetters,</span><br><span class="line">  mapActions,</span><br><span class="line">  createNamespacedHelpers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>install</code>肯定是Vue老套路，想把东西当插件用肯定要暴露这个方法。这个之前写组件经常需要碰到，弃之！</p><p>这次就先读暴露出来的四个方法吧</p><a id="more"></a><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><h3 id="normalizeNamespace"><a href="#normalizeNamespace" class="headerlink" title="normalizeNamespace"></a>normalizeNamespace</h3><p>这个东西可能要先讲，因为你看到<code>mapState</code>的第一眼你就会看到他，虽然不重要。</p><p>这应该是一个初始化或者标准化命名空间的方法，之前”尝试用dva的理解对处理数据”有遇到使用命名空间的情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(<span class="string">'spacename'</span>, &#123;</span><br><span class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.count</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下实现方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeNamespace</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">namespace, map</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> namespace !== <span class="string">'string'</span>) &#123;</span><br><span class="line">      map = namespace</span><br><span class="line">      namespace = <span class="string">''</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (namespace.charAt(namespace.length - <span class="number">1</span>) !== <span class="string">'/'</span>) &#123;</span><br><span class="line">      namespace += <span class="string">'/'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn(namespace, map)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>映入眼帘就是一个柯里了，大致意思就是命名空间需要处理，如果进来的函数第一个不是空间名称那么肯定直接是对象了，因为我们也不是必须使用命名空间，比如最普通的这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.count</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有命名空间的话，就根据层数用<code>/</code>分开，比如<code>app/save</code></p><h3 id="normalizeMap"><a href="#normalizeMap" class="headerlink" title="normalizeMap"></a>normalizeMap</h3><p>对不起还是不能讲到<code>mapState</code>，毕竟通用的函数理解完了之后，游戏也就结束了。（要不怎么说是辅助函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Normalize the map</span></span><br><span class="line"><span class="comment"> * normalizeMap([1, 2, 3]) =&gt; [ &#123; key: 1, val: 1 &#125;, &#123; key: 2, val: 2 &#125;, &#123; key: 3, val: 3 &#125; ]</span></span><br><span class="line"><span class="comment"> * normalizeMap(&#123;a: 1, b: 2, c: 3&#125;) =&gt; [ &#123; key: 'a', val: 1 &#125;, &#123; key: 'b', val: 2 &#125;, &#123; key: 'c', val: 3 &#125; ]</span></span><br><span class="line"><span class="comment"> * @param &#123;Array|Object&#125; map</span></span><br><span class="line"><span class="comment"> * @return &#123;Object&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeMap</span> (<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(map)</span><br><span class="line">    ? map.map(<span class="function"><span class="params">key</span> =&gt;</span> (&#123; key, <span class="attr">val</span>: key &#125;))</span><br><span class="line">    : <span class="built_in">Object</span>.keys(map).map(<span class="function"><span class="params">key</span> =&gt;</span> (&#123; key, <span class="attr">val</span>: map[key] &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释都直接告诉你了！对的实际上组件对<code>vuex</code>的访问可以有两种，对象或者数组。对象的情况上面已经有了，还有一种数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(<span class="string">'spacename'</span>, [</span><br><span class="line">    <span class="string">'count'</span></span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种是，如果组件的参数跟vuex设定一样，那么就直接传入数组匹配，相当于<code>this.count</code>指向<code>this.$store.state.count</code></p><h3 id="mapState-mapMutations-mapGetters-mapActions"><a href="#mapState-mapMutations-mapGetters-mapActions" class="headerlink" title="mapState, mapMutations, mapGetters, mapActions"></a>mapState, mapMutations, mapGetters, mapActions</h3><p>剩下的就真的是“拼装术”的事情了，通过暴露出去的辅助函数所接收到的数据进行转换并连接<code>vuex</code>。</p><p>相当于<code>redux</code>本身只提供了状态管理，便捷操作需要接触各类型插件。而<code>vuex</code>作为<code>vue</code>专属状态管理，已经提供了最适合<code>vue</code>的操作。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>由于辅助函数做的工作就是提供在组件中对<code>vuex</code>连接操作的工作，而函数中的转换结果都会是<code>this.$store</code>。在注入<code>vue</code>的环境中，<code>this</code>不出意外的话是指向<code>vue</code>原型上的，这也就意味着，<code>vuex</code>实际上也是作为插件附着在<code>vue</code>原型中。</p><p>不过关于这一点，在一开始就有提到，<code>vuex</code>是通过暴露自己的安装函数让<code>vue</code>可以直接<code>use()</code>。而且我们在<code>main.js</code>绑定时也默认使用<code>store</code>这个key。</p><p>这样的话，只要是能访问到<code>vue</code>的地方就可以访问到<code>$store</code>了，包括组件。<strong>从而可以做到不需要什么辅助函数也不需要<code>actions</code>直接对状态管理动手动脚。</strong>这不仅是react的使用者感觉到的诧异或者反感了吧。</p><p>不过团队是知道这种情况的存在的，所以他们是<strong>推荐在组件中使用辅助函数，请不要直接操作</strong>。</p><p>（不过这个注释最多也就说说而已，懂道理的人都会这么做；不懂道理的，只存留“我只要解决问题就行了”的某些人是不会这么做的。）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看个代码代价很高，我边读边转笔，然后一个失手把手挑了个滴血不止…（笔头挑掉了一层手皮）&lt;/p&gt;
&lt;p&gt;vuex和dva的源码都想看，不然没办法知道相性在哪。&lt;/p&gt;
&lt;h3 id=&quot;由口而入&quot;&gt;&lt;a href=&quot;#由口而入&quot; class=&quot;headerlink&quot; title=&quot;由口而入&quot;&gt;&lt;/a&gt;由口而入&lt;/h3&gt;&lt;p&gt;这都暴露干净了…&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Store,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  install,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  version: &lt;span class=&quot;string&quot;&gt;&#39;__VERSION__&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  mapState,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  mapMutations,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  mapGetters,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  mapActions,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  createNamespacedHelpers&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;install&lt;/code&gt;肯定是Vue老套路，想把东西当插件用肯定要暴露这个方法。这个之前写组件经常需要碰到，弃之！&lt;/p&gt;
&lt;p&gt;这次就先读暴露出来的四个方法吧&lt;/p&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="vue" scheme="https://colmugx.github.io/blog/tags/vue/"/>
    
      <category term="vuex" scheme="https://colmugx.github.io/blog/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>通过dva得到的思考 —— “滥用”VUEX</title>
    <link href="https://colmugx.github.io/blog/2018/01/22/vuex-dva/"/>
    <id>https://colmugx.github.io/blog/2018/01/22/vuex-dva/</id>
    <published>2018-01-22T15:35:15.000Z</published>
    <updated>2019-03-25T06:43:19.149Z</updated>
    
    <content type="html"><![CDATA[<p>首先这一手骚操作要感谢@ahonn，确实这几天学习dva，我自己都觉得自己有点烦了。但是老哥好耐心，真心感谢。</p><p>直接上正题吧不磨磨唧唧的了！</p><h3 id="dva是什么"><a href="#dva是什么" class="headerlink" title="dva是什么"></a>dva是什么</h3><p>这还用说吗，坦克啊！双命特性，大招是通过机甲自爆产生大范围爆炸，本体只有100血，可以反…啊！！！别打我啊！</p><p>好吧可能阿里的工程师也喜欢玩守望先锋，而且我清晰记得dva这个框架就是守望大火的时候诞生的，而且还有一个协同工具叫路霸吧。（看来阿里的工程师都不喜欢当C…）</p><a id="more"></a><p><code>dva</code>是针对<code>react</code>的框架，实际上就是关于<code>redux</code>的一个封装。首先是让本来很难理解和使用的redux变得相对容易理解和操作。另外一个就是因为数据集中管理，并且推荐使用无状态组件，操作者只需要关心数据的走向。</p><h3 id="从dva得到了启示"><a href="#从dva得到了启示" class="headerlink" title="从dva得到了启示"></a>从dva得到了启示</h3><p>毕竟阿里前端工程师，Ahonn是真的喜欢阿里的东西…最近跟他聊天也比较深入了解“为什么我们需要dva”。</p><p>后来我一个闪念：<code>dva</code>会不会就是一个数据库模型，实际上redux对我们来说就是一个数据库，前端没有状态，不干涉数据，实际上就是我们常说的只关心增删改查？</p><p>那么dva实际上还是对<code>redux</code>，<code>redux-saga</code>，<code>redux-thunk</code>的封装，但对于vue来说简直就是先天优势，因为对于vuex来说已经相当于redux + redux-saga了。从这里也直接萌生了一个想法：vuex + stateless component = 1/2 dva ？</p><h3 id="对启示更清晰的思考"><a href="#对启示更清晰的思考" class="headerlink" title="对启示更清晰的思考"></a>对启示更清晰的思考</h3><p>首先现在的dva，把数据都封装在<code>model</code>中，一个<code>model</code>对应一个redux，<code>state</code>, <code>reducer</code>概念得以保留，引入<code>effect</code>和<code>subscriptions</code>概念。</p><p>首先副作用的目的是，通过异步操作例如网络请求或者一些需要异同步配合的操作，然后去驱使<code>reducer</code>更新<code>state</code>，因为在流中，只有<code>reducer</code>有权利去动<code>state</code>。<code>subscriptions</code>就是一个订阅的概念，在我看来就是一个初始化，或者说是一个接受状态的概念。</p><p>那么为什么说vuex有先天优势？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dva model</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespace: <span class="string">"users"</span>,</span><br><span class="line">  state: &#123;&#125;,</span><br><span class="line">  reducers: &#123;&#125;,</span><br><span class="line">  effects: &#123;&#125;,</span><br><span class="line">  subscriptions: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vuex</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    users: &#123;</span><br><span class="line">      namespaced: <span class="literal">true</span>,</span><br><span class="line">      state: &#123;&#125;,</span><br><span class="line">      mutations: &#123;&#125;,</span><br><span class="line">      actions: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果你要无限逼近dva是什么感觉？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// users.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespaced: <span class="literal">true</span>,</span><br><span class="line">  state: &#123;&#125;,</span><br><span class="line">  mutations: &#123;&#125;,</span><br><span class="line">  actions: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//store.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    users</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于 vue/vuex 对于规则还是相对宽松，但理是理法是法，约定俗成<code>mutations</code>是用来做同步的工作，可以用来操作<code>state</code>；<code>actions</code>用来做异步工作，通知<code>mutations</code>去操作<code>state</code>。所以这里是不是就有一种新的概念？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">state &lt;=&gt; state</span><br><span class="line">mutation &lt;=&gt; reducer</span><br><span class="line">action &lt;=&gt; effect</span><br><span class="line"></span><br><span class="line">_ &lt;=&gt; subscription</span><br></pre></td></tr></table></figure><p>对没错，订阅怎么办？</p><p>在dva的例子中，看一下示例的订阅是做了什么工作？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">subscriptions: &#123;</span><br><span class="line">  setup(&#123; dispatch, history &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> history.listen(<span class="function">(<span class="params">&#123; pathname, query &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (pathname === <span class="string">'/users'</span>) &#123;</span><br><span class="line">        dispatch(&#123; <span class="attr">type</span>: <span class="string">'fetch'</span>, <span class="attr">payload</span>: query &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以关于这个简单订阅，我们完全可以直接用<code>vue-router</code>，而其中刚好有一个概念我们可以直接使用 —— 导航守卫</p><h3 id="针对vue的操作"><a href="#针对vue的操作" class="headerlink" title="针对vue的操作"></a>针对vue的操作</h3><p>老样子，我们是怎么理解dva的<code>model</code>，就怎么理解vuex的<code>store</code>。首先<code>state</code>和<code>reducer</code>跟vuex的定义是完全对等的，不需要多理解。<code>effects</code>是使用<code>generator</code>函数来解决异同步问题的，那好办啊，都2018年了，我们直接用async/await就行了。而且我们之前关于api都是使用<code>promise</code>，而且用的也是<code>axios</code>，所以这部分可以说是无缝切换。</p><p>那么关于订阅，直接使用<code>vue-router</code>的导航守卫对路由监控，另外在必要的时候还能使用<code>meta</code>。当然导航守卫并不是只能用在全局上，也可以注入到组件中，所以我们注入到页面组件即可。</p><p>接下来就是无状态组件问题了，vue默认是状态组件，而且无状态组件也没有react来的方便。</p><p>react想要无状态组件，无非就是一个函数就结束战斗了。vue也有一个概念叫函数式组件，也就是无状态，这种组件在使用上就已经不是很方便了。</p><p>vue的函数式组件就必须使用<code>render</code>函数不能用<code>template</code>模板，一直到vue2.5才可以在<code>&lt;template functional&gt;</code>使用。但我尝试了一下，手感并不好，所以还是只能用 jsx + vue 这种搭配来操作。不过vue的无状态组件也不像react那么好理解，它依然是一个Object</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  functional: <span class="literal">true</span>， <span class="comment">// 你只不过是通过这个开关来切换组件状态</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions(<span class="string">'spacename'</span>, &#123;</span><br><span class="line">      add: <span class="string">'create'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;props.msg&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且在实际使用中，实际上因为vue的概念，你还是没办法在所有组件完全不使用无状态组件（已经除去表单组件）。不过也无伤大雅了。</p><p>所以通过这个操作，也能近似的得到了dva的那种感觉。前端的工作只需要直观的反馈你的数据动向和状态，要那么复杂干什么？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先这一手骚操作要感谢@ahonn，确实这几天学习dva，我自己都觉得自己有点烦了。但是老哥好耐心，真心感谢。&lt;/p&gt;
&lt;p&gt;直接上正题吧不磨磨唧唧的了！&lt;/p&gt;
&lt;h3 id=&quot;dva是什么&quot;&gt;&lt;a href=&quot;#dva是什么&quot; class=&quot;headerlink&quot; title=&quot;dva是什么&quot;&gt;&lt;/a&gt;dva是什么&lt;/h3&gt;&lt;p&gt;这还用说吗，坦克啊！双命特性，大招是通过机甲自爆产生大范围爆炸，本体只有100血，可以反…啊！！！别打我啊！&lt;/p&gt;
&lt;p&gt;好吧可能阿里的工程师也喜欢玩守望先锋，而且我清晰记得dva这个框架就是守望大火的时候诞生的，而且还有一个协同工具叫路霸吧。（看来阿里的工程师都不喜欢当C…）&lt;/p&gt;
    
    </summary>
    
      <category term="实践尝试" scheme="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="vue" scheme="https://colmugx.github.io/blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer —— 替换空格</title>
    <link href="https://colmugx.github.io/blog/2018/01/04/replace-space/"/>
    <id>https://colmugx.github.io/blog/2018/01/04/replace-space/</id>
    <published>2018-01-03T16:03:46.000Z</published>
    <updated>2018-01-03T16:06:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>以后博客专职曲苑杂坛算了…</p><p>刚刚看到一题</p><blockquote><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></blockquote><p>我想这什么腿？然后什么都没想，直接就</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> str.replace(<span class="regexp">/\ /g</span>, <span class="string">'%20'</span>)</span><br></pre></td></tr></table></figure><p>然后过了……虽然100多毫秒</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以后博客专职曲苑杂坛算了…&lt;/p&gt;
&lt;p&gt;刚刚看到一题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
      <category term="曲苑杂坛" scheme="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>有意思的monad记录</title>
    <link href="https://colmugx.github.io/blog/2017/12/27/funny-monad/"/>
    <id>https://colmugx.github.io/blog/2017/12/27/funny-monad/</id>
    <published>2017-12-27T15:24:58.000Z</published>
    <updated>2018-01-01T14:11:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看到monad我的第一反应竟然是莫纳德…</p></blockquote><p>最近学习haskell的时候（意外的觉得入门不难），接触到函数式编程一个新的思想——Monad</p><p>之前在知乎看到轮子哥说：学习haskell是好事，但最好就是学到monad就停下来，然后去学别的。对别的语言帮助很大。</p><p>然后在知乎看了一些monad的答案，找了点关于monad的博客看，没看懂。英文的话更不可能了！直接看paper的话我会脆死的。</p><p>后来偶然找到一篇文章：<a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="noopener">Functors, Applicatives, And Monads In Pictures - adit.io</a></p><p>当然有中文版：<a href="http://jiyinyiyong.github.io/monads-in-pictures/" target="_blank" rel="noopener">Functors, Applicatives, And Monads In Pictures - adit.io</a>，<br><a href="http://www.ruanyifeng.com/blog/2015/07/monad.html" target="_blank" rel="noopener">图解 Monad - 阮一峰的网络日志</a></p><p>全程特别轻松，我以后写博客也要按照这个节奏来写！很有意思！<br>（那个抽东西的手直接戳爆了我的笑点…特别是解构传入胶水函数的时候）</p><p>关于理解的话，挖个坑以后总结~</p><p>但有一点是：我用 Vue-jsx 的时候，几乎全是Monad</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;看到monad我的第一反应竟然是莫纳德…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近学习haskell的时候（意外的觉得入门不难），接触到函数式编程一个新的思想——Monad&lt;/p&gt;
&lt;p&gt;之前在知乎看到轮子哥说：学习haskell是好事，但最
      
    
    </summary>
    
      <category term="曲苑杂坛" scheme="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/"/>
    
    
      <category term="Functional Programming" scheme="https://colmugx.github.io/blog/tags/Functional-Programming/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript链式方法</title>
    <link href="https://colmugx.github.io/blog/2017/12/23/js-method-chaining/"/>
    <id>https://colmugx.github.io/blog/2017/12/23/js-method-chaining/</id>
    <published>2017-12-23T10:05:54.000Z</published>
    <updated>2019-03-22T16:07:34.680Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>著名框架<code>jQuery</code>所使用的设计模式——“虾扯蛋”</p></blockquote><p>之前在知乎回答过一个问题：2018的前端应该学什么。</p><p>我回答了：就算前端再复杂，jQuery依然是最流行的那个。</p><p>这答案怎么样呢？废话！肯定没人点赞了！</p><p>人性就是如此！一旦接受了更<del>装逼</del>新的思路，就会觉得以前见过的东西都太弱了！</p><p>新项目想用什么就用什么，什么技术栈健全就用什么。可是老项目并没办法想干什么干什么，时间和精力不允许他去重构。金蝶还在卖VB呢，他们肯定也想过VB已经不行了。</p><p>好了题外话，我还是很有兴趣实现一个塞进<code>nlvi</code>的类jq的。</p><a id="more"></a><h3 id="怎么来的链式操作"><a href="#怎么来的链式操作" class="headerlink" title="怎么来的链式操作"></a>怎么来的链式操作</h3><blockquote><p>如果不用链式调用，jQuery没有性能可言 ——鲁迅</p></blockquote><p>鲁迅：我不是！我没有！别乱说啊！</p><p>我记得有人测试过，<code>$(&#39;#ele&#39;)</code>会比<code>document.getElementById(&#39;ele&#39;)</code>慢很多。如果是按行操作dom而不是用专属的链式调用，效率会更差。</p><p>但这次不是来讨论jQuery的效率的。链式方法也是一种设计模式，有必要了解一下。就算ES6常使用的<code>Promise</code>，也用到了链式调用。</p><p><code>JavaScript</code>能够函数式编程，还是因为它是个“函数为第一公民”的语言，但它并没有<code>pure function</code>是因为它的设计其实是多范式的。而ES6把构造函数和<code>classes</code>加进去之后更是证明了这一点。</p><h3 id="我用过的JavaScript"><a href="#我用过的JavaScript" class="headerlink" title="我用过的JavaScript"></a>我用过的JavaScript</h3><p>关于这部分，我觉得我想分享的东西有点超篇幅，所以移步到另外一篇分享吧：<a href="/PersonalBlog/2017/12/26/my-known-javascript/">我所认识的JavaScript</a></p><p>大致上就是<code>JavaScript</code>之所以能这么玩是因为它会把任何东西都看做“函数”来看待，并且以它的理解就是：我能且只能掌控函数，函数必有返回值。并且每产生一个函数就会有一个“我”的含义：<code>function</code>会自然而然的产生<code>this</code>并指向自己。而链式操作就是利用了这点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是浏览器的话，在没有对象的情况下，父级应该就是<code>window</code>了。而函数返回<code>this</code>相当于把自己返回到操作空间中，而操作空间属于父级。也就是说，只要是同一级别的函数，通过返回<code>this</code>把操作权交还到父级手中从而达到继续调用同级函数的技能。还不清楚？反正我不画图。</p><h3 id="简单链式操作"><a href="#简单链式操作" class="headerlink" title="简单链式操作"></a>简单链式操作</h3><p>在此我们以著名歌唱家“雷军”举个例子。雷军可以说是目前最强悍的企业家了，写得了软件造得了手机，能唱一首好歌能吹一手好B。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 雷军（人为对象，构造成立）</span></span><br><span class="line"><span class="keyword">var</span> LeiJun = &#123;</span><br><span class="line">  hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello, '</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="comment">// -&gt; LeiJun</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  thank: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'thank you, '</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="comment">// -&gt; LeiJun</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  thanks: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'thank you very much, '</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="comment">// -&gt; LeiJun</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱使对象雷军唱出《Are you ok》前三句</span></span><br><span class="line">leijun</span><br><span class="line">  .hello()</span><br><span class="line">  .thank()</span><br><span class="line">  .thanks()</span><br></pre></td></tr></table></figure><p>如果按字面意思可能永远都理解不来，从而产生哲学三连：我是谁？我在哪？我在干什么？所以又有一句话得以解释：从哪里来，回哪里去。</p><h3 id="为什么用链式操作"><a href="#为什么用链式操作" class="headerlink" title="为什么用链式操作"></a>为什么用链式操作</h3><blockquote><p>新手村的Monad？</p></blockquote><p>所以作用很明显了，一种工厂流水线式的操作，流的形式完成任务。所以我要把这种设计模式归入函数式编程也是因为，函数式思想本来就是让数据经过所有“函数流”最后得到产物并返回。数据不变，不额外干涉操作。</p><p>不同的是，常规FP中，不管是单函数单返回走流，还是柯里化，它都是一种“一进一出”的思想——出来的产物继续传入下一道“工序”进行加工，一直到最后一个加工函数为止。</p><p>然而链式操作并不是这种哲学，它是一种“从第一次进入就买定离手”的操作——只要一开头传入参数，流不结束不会见到半成品。数据经过一层函数之后，可能经过加工处理结束后，又会被打包/压缩/处理到‘this’中并继续接下来的工作。</p><p>链式操作相对于柯里化来说，起码它做到了：</p><ul><li>可阅读</li><li>少占用</li><li>减少代码重复性（都有）</li><li>代码简洁（都有）</li></ul><p>柯里化最明显的优点就是阅读性差（？？？），假设有个方法叫<code>leijun</code>,那么调用方法的画风就大不相同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leijun()()()</span><br></pre></td></tr></table></figure><p>鬼才知道他想唱的是“Are you ok”还是“Indian Mi Fans”呢……</p><p>还有就是，因为流操作可以异步。JS也是患有懒癌很多年了，必须靠事件驱动才能工作，所以注定它是不能异步编程的。</p><p>所以jQuery还是很强大的框架，在ES5什么都没有就靠三种规范的语法，已经要实现那么多东西了。让JS支持异步编程也就两种操作吧：函数内回调函数、链式操作函数。这框架两种都用上了。而说NodeJS速度快，一方面也是因为目前两个服务器框架都是异步（一堆回调函数）得到的结果吧。</p><h3 id="不止JavaScript能用"><a href="#不止JavaScript能用" class="headerlink" title="不止JavaScript能用"></a>不止JavaScript能用</h3><p>实际上本质就是，把执行权交给函数之后，函数执行完自己的工作之后，还可以吧执行权重新交回父级手中，让父级自行处理接下来的工作。</p><p>所以强化函数式编程的语言或者说能返回自身的语言应该都可以支持该模式，在这之后我只接触过<code>Golang</code>有这种操作，不过那当时哪来的Go啊…</p><p>这个世界本来就先有的FP，因为概念不够清晰才出现了OOP。现在业务量复杂到OOP已经不好解决了，这个时候人们又想起了凉了的FP。2018年如果前端继续发展下去，可能又会回到一个FP的年代（然后我要放弃FP看着它火了？不！这次看到希望不会撒手了！）</p><p>在我在无脑吹FP的时候（懂得概念不懂得实践），我看到了swift的出现，JAVA8强化λ，go的出现，TypeScript的出现（乱入，它强调OOP）。前几天看到了<code>haskell-react</code>，以后还会有什么？</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;著名框架&lt;code&gt;jQuery&lt;/code&gt;所使用的设计模式——“虾扯蛋”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前在知乎回答过一个问题：2018的前端应该学什么。&lt;/p&gt;
&lt;p&gt;我回答了：就算前端再复杂，jQuery依然是最流行的那个。&lt;/p&gt;
&lt;p&gt;这答案怎么样呢？废话！肯定没人点赞了！&lt;/p&gt;
&lt;p&gt;人性就是如此！一旦接受了更&lt;del&gt;装逼&lt;/del&gt;新的思路，就会觉得以前见过的东西都太弱了！&lt;/p&gt;
&lt;p&gt;新项目想用什么就用什么，什么技术栈健全就用什么。可是老项目并没办法想干什么干什么，时间和精力不允许他去重构。金蝶还在卖VB呢，他们肯定也想过VB已经不行了。&lt;/p&gt;
&lt;p&gt;好了题外话，我还是很有兴趣实现一个塞进&lt;code&gt;nlvi&lt;/code&gt;的类jq的。&lt;/p&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序的骚思路</title>
    <link href="https://colmugx.github.io/blog/2017/12/20/exchange_number/"/>
    <id>https://colmugx.github.io/blog/2017/12/20/exchange_number/</id>
    <published>2017-12-20T06:46:41.000Z</published>
    <updated>2017-12-22T02:59:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>想起以前很容易就会被问到一个问题</p><blockquote><p>如何把两个数值进行交换？</p></blockquote><p>教科书式的编程怎么做？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k = i;</span><br><span class="line"></span><br><span class="line">i = j;</span><br><span class="line">j = k;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个数值，把其中一个寄存起来，然后再两次赋值。</span></span><br></pre></td></tr></table></figure><p>以前去写代码的社团，当时我巨活跃，有个师兄就过来说：看你资质不错，我打算亲自培养你，先问你一个问题吧：你如何把两个数值进行交换？写不出代码没关系，我只是要听思路。</p><p>我：什么跟什么交换？</p><p>师兄：随便你。</p><p>于是我打开了<code>sublime text</code>写下这么些东西</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">i += j;</span><br><span class="line">j = i - j;</span><br><span class="line">i -= j;</span><br></pre></td></tr></table></figure><p>然后师兄就懵了，你这个B不按套路出牌？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想起以前很容易就会被问到一个问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何把两个数值进行交换？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;教科书式的编程怎么做？&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="曲苑杂坛" scheme="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
</feed>
