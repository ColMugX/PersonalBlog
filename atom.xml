<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Colmugx &#39;s Blog</title>
  
  <subtitle>让一切充满想象力</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://colmugx.github.io/blog/"/>
  <updated>2020-03-29T10:32:04.990Z</updated>
  <id>https://colmugx.github.io/blog/</id>
  
  <author>
    <name>colmugx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker 容器内通信</title>
    <link href="https://colmugx.github.io/blog/2020/03/29/docker-container-bridge/"/>
    <id>https://colmugx.github.io/blog/2020/03/29/docker-container-bridge/</id>
    <published>2020-03-29T10:00:28.000Z</published>
    <updated>2020-03-29T10:32:04.990Z</updated>
    
    <content type="html"><![CDATA[<p>除了正常工作（特殊时期太搞人了，虽然我一直在 remote..），最近也在准备一个专栏，同时也在找文本存储或者说自己喜欢的笔记方案。我对数据的掌控性有些洁癖，不是很想用 Bear 这类东西，也摸不着头脑所以退而求其次有一段时间依赖 iCloud</p><p>最后整了一个本地 webdav 😆</p><p>当然商业网盘支持 WebDav 国内公司也有的，就曾四处安利过的坚果云</p><p>docker 好东西啊，一个宿主，一堆容器，互相隔离又互相吸引。自然 nextcloud 和数据库理所当然的处于两个容器。既然同 host 下，那容器应该内网连接就行了，这么一来人懵了</p><p><strong>两个容器不在一个网段内…</strong>因为有一个容器是处于一个 stack 内的</p><p>所以，水一篇文，单纯记录一下<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>用 <code>--link</code> 参数确实可以让容器联系到一次，但想着就觉得可能会出现无法维护的情况。而且 docker 是有 <code>network</code> 的，最好还是通过创建不同的「内网」使容器可以在「正确的网路」内相互通信</p><h4 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h4><p>这类操作要的只是一个网桥，所以创建一个桥叫做<code>my-bridge</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge my-bridge</span><br></pre></td></tr></table></figure><h4 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h4><p>家庭服务我是上了 <code>dashboard(portianer)</code> 的，所以两个容器在 <code>network</code> 区分别下拉拿到网桥点击添加就完事了，谁愿意写命令啊毕竟在家装b没人看（X</p><p>用命令行的话也就是把控制台自动做的繁琐操作手动做了一遍 —— 关掉容器然后添加 <code>--network</code> 运行容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --network my_bridge [...]</span><br></pre></td></tr></table></figure><p>吐槽一下自己的文章分类，是时候应该整理一下了，或者好几年前开个文章编辑器坑要填上了……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;除了正常工作（特殊时期太搞人了，虽然我一直在 remote..），最近也在准备一个专栏，同时也在找文本存储或者说自己喜欢的笔记方案。我对数据的掌控性有些洁癖，不是很想用 Bear 这类东西，也摸不着头脑所以退而求其次有一段时间依赖 iCloud&lt;/p&gt;
&lt;p&gt;最后整了一个本地 webdav 😆&lt;/p&gt;
&lt;p&gt;当然商业网盘支持 WebDav 国内公司也有的，就曾四处安利过的坚果云&lt;/p&gt;
&lt;p&gt;docker 好东西啊，一个宿主，一堆容器，互相隔离又互相吸引。自然 nextcloud 和数据库理所当然的处于两个容器。既然同 host 下，那容器应该内网连接就行了，这么一来人懵了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两个容器不在一个网段内…&lt;/strong&gt;因为有一个容器是处于一个 stack 内的&lt;/p&gt;
&lt;p&gt;所以，水一篇文，单纯记录一下&lt;br&gt;
    
    </summary>
    
      <category term="曲苑杂坛" scheme="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/"/>
    
    
      <category term="docker" scheme="https://colmugx.github.io/blog/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>利用 Context 传递多语言文本</title>
    <link href="https://colmugx.github.io/blog/2020/01/31/react-translate/"/>
    <id>https://colmugx.github.io/blog/2020/01/31/react-translate/</id>
    <published>2020-01-31T06:38:39.000Z</published>
    <updated>2020-01-31T07:50:15.423Z</updated>
    
    <content type="html"><![CDATA[<p>Gatsby 比 Hexo 更像一个通用框架，关于博客的工具真是全靠社区衬托。Nlvi 迁移遇到了标签云和分类等各种问题，还有一个多语言问题…</p><p>找了一圈插件，i18n 大多数方案都是「一个站点同时多语言」，这对一个博客来说没必要啊（相对来说我博文是不是也得写个几份..），想了一圈好像也没必要上<code>react-intl</code>，直接手作一个吧 —— 按照<strong>「好看的皮囊千篇一律」</strong>写一个</p><p>但是主题毕竟是要开源的，所以如果有好兄弟萌觉得 i18n 处理不行，自行替换成 <code>gatsby-plugin-i18n</code> 或者 <code>react-intl</code> 就可以了<br><a id="more"></a></p><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>直接从 react 分出 <code>createContext</code> 方法，直接用<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> langContext = createContext(&#123;&#125; <span class="keyword">as</span> ContextInterface)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建上下文后输出 Provider 和 Consumer 还是要的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Provider = langContext.Provider</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Consumer = langContext.Consumer</span><br><span class="line"></span><br><span class="line"><span class="comment">// ps: 其实 Consumer 用不上...</span></span><br></pre></td></tr></table></figure></p><h3 id="生成翻译"><a href="#生成翻译" class="headerlink" title="生成翻译"></a>生成翻译</h3><p>hexo 版 nlvi 已经有语言文件，所以直接拿过来放到<code>lang</code>文件夹下，然后每个文件通过 yaml2json 转成<code>json</code>，简单一点就不上 yaml 了</p><p>大概思路就是：</p><ul><li>设定是通过主题的 <code>options</code> 传入 <code>lang</code> 属性，然后 <code>lang</code> 写到 <code>siteMetadata</code> 中</li><li>由 <code>layout</code> 读取语言，传入翻译生成文本，传入 <code>Provider</code></li><li>使用的地方使用 <code>formatMessage</code> 去接</li></ul><p>所以也就是接地气且极其简化啥都不考虑保证数据存在版的<code>react-intl</code>。方法可以这么写<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> genTranslate = <span class="function">(<span class="params">lang: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> _message = <span class="built_in">require</span>(<span class="string">`@/lang/<span class="subst">$&#123;lang&#125;</span>.json`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!_message) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;lang&#125;</span> language json was not found.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> formatMessage = (&#123; id, defaultMsg &#125;: FormatMessageType): <span class="function"><span class="params">string</span> =&gt;</span></span><br><span class="line">    <span class="comment">// _get 来自 lodash</span></span><br><span class="line">    _get(_message, id) || defaultMsg || <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> formatter = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; formatMessage, _message &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> formatter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用翻译"><a href="#使用翻译" class="headerlink" title="使用翻译"></a>使用翻译</h3><p>直接用 <code>useContext</code> 去接，2020年该跟风用 hooks 了（大雾<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useIntl = (): <span class="function"><span class="params">ContextInterface</span> =&gt;</span> useContext(langContext)</span><br></pre></td></tr></table></figure></p><p>所以这么写的话，只要在 <code>layout</code> 下的组件都可以用这个方式拿到翻译<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; formatMessage: t &#125; = useIntl()</span><br></pre></td></tr></table></figure></p><p>这样一来其实跟使用 <code>react-intl</code> 是差不多的，就算日后要改也应该不用动业务代码</p><p>所以刚刚那句话还差一半来着？另一半应该是<strong>「糜烂的灵魂（?）凑合对付」</strong>！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Gatsby 比 Hexo 更像一个通用框架，关于博客的工具真是全靠社区衬托。Nlvi 迁移遇到了标签云和分类等各种问题，还有一个多语言问题…&lt;/p&gt;
&lt;p&gt;找了一圈插件，i18n 大多数方案都是「一个站点同时多语言」，这对一个博客来说没必要啊（相对来说我博文是不是也得写个几份..），想了一圈好像也没必要上&lt;code&gt;react-intl&lt;/code&gt;，直接手作一个吧 —— 按照&lt;strong&gt;「好看的皮囊千篇一律」&lt;/strong&gt;写一个&lt;/p&gt;
&lt;p&gt;但是主题毕竟是要开源的，所以如果有好兄弟萌觉得 i18n 处理不行，自行替换成 &lt;code&gt;gatsby-plugin-i18n&lt;/code&gt; 或者 &lt;code&gt;react-intl&lt;/code&gt; 就可以了&lt;br&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="react" scheme="https://colmugx.github.io/blog/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>创建一个 rust web server</title>
    <link href="https://colmugx.github.io/blog/2019/12/29/try-actix/"/>
    <id>https://colmugx.github.io/blog/2019/12/29/try-actix/</id>
    <published>2019-12-29T04:29:34.000Z</published>
    <updated>2020-01-04T15:07:03.382Z</updated>
    
    <content type="html"><![CDATA[<p>玩了一段时间 Vapor，想不明白谁家会用 swift 跑生产，可能也就 <code>perfect</code> 维护者背后的公司会用，至少在拆哪应该还是要快(la)准(man)狠(kpi)的。<br>rust 社区中关注了 <code>rocket</code> 一段时间，后面发现 <code>actix-web</code> 在各方面更有优势，加上要好好点 rust 技能树，所以就选定这个了。</p><p>这里会以重构我的闹钟后端作为蓝本，逐步做个记录。</p><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul><li>直接用 <code>cargo</code> 创建应用</li><li>装载 <code>actix-web</code></li><li>写一个 api</li></ul><a id="more"></a><h2 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h2><p>官方没有开箱即用的模板，所以还是从<code>cargo new</code>开始，这里定义了默认使用<code>git</code>作为版本控制</p><blockquote><p>> cargo new –vcs git actix-demo</p></blockquote><p>在<code>Cargo.toml</code>中添加这些<br><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">actix-web</span> = <span class="string">"2.0"</span></span><br><span class="line"><span class="attr">actix-rt</span> = <span class="string">"1.0"</span></span><br><span class="line"><span class="comment"># env</span></span><br><span class="line"><span class="attr">dotenv</span> = <span class="string">"0.15.0"</span></span><br><span class="line"><span class="attr">log</span> = <span class="string">"0.4.8"</span></span><br><span class="line"><span class="attr">env_logger</span> = <span class="string">"0.7.1"</span></span><br></pre></td></tr></table></figure></p><p>然后在<code>main.rs</code>创建启动函数<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> actix_web::&#123;App, HttpServer, get&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[get(<span class="meta-string">"/"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">index</span></span>() -&gt; HttpResponse &#123;</span><br><span class="line">    HttpResponse::<span class="literal">Ok</span>().body(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[actix_rt::main]</span></span><br><span class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> app = || App::new().service(index);</span><br><span class="line"></span><br><span class="line">    info!(<span class="string">"serving on localhost:7001"</span>);</span><br><span class="line"></span><br><span class="line">    HttpServer::new(app)</span><br><span class="line">        .bind(<span class="string">"localhost:7001"</span>)?</span><br><span class="line">        .run()</span><br><span class="line">        .await</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一般来说这样就可以运行了</p><h2 id="配置应用"><a href="#配置应用" class="headerlink" title="配置应用"></a>配置应用</h2><p>按照习惯，工程结构还是愿意设置成这样：</p><ul><li>controller</li><li>services</li><li>models</li><li>middleware</li></ul><p>所以目录先确定下来：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-- src</span><br><span class="line">| +-- controller</span><br><span class="line">| | +-- mod.rs</span><br><span class="line">| +-- services</span><br><span class="line">| | +-- mod.rs</span><br><span class="line">| +-- models</span><br><span class="line">| | +-- mod.rs</span><br><span class="line">| +-- middleware</span><br><span class="line">| | +-- mod.rs</span><br></pre></td></tr></table></figure></p><p>为什么每个目录下都需要<code>mod.rs</code>？原因是人家<code>rust</code>对模块就是这么处理的啊！</p><p>接着，<code>Cargo.toml</code>需要加点东西，比如<code>json</code>的支持（可是你用的不是 GraphQL 吗！）<br><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="comment"># serde</span></span><br><span class="line"><span class="attr">serde</span> = <span class="string">"1.0.104"</span></span><br><span class="line"><span class="attr">serde_derive</span> = <span class="string">"1.0.104"</span></span><br><span class="line"><span class="attr">serde_json</span> = <span class="string">"1.0.44"</span></span><br><span class="line"><span class="attr">json</span> = <span class="string">"0.12.0"</span></span><br></pre></td></tr></table></figure></p><p>接下来对代码作出一些改动，首先是一个通用的<code>json</code>结构体，创建 <code>models/payload</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> serde_derive::&#123;Serialize, Deserialize&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Serialize, Deserialize, Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Payload</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> code: <span class="built_in">isize</span>,</span><br><span class="line">    <span class="keyword">pub</span> message: <span class="built_in">String</span>,</span><br><span class="line">    <span class="meta">#[serde(skip_serializing_if = <span class="meta-string">"Option::is_none"</span>, default)]</span></span><br><span class="line">    <span class="keyword">pub</span> payload: <span class="built_in">Option</span>&lt;T&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，从<code>controller/index</code>开始</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Deserialize)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Info</span></span> &#123;</span><br><span class="line">    message: <span class="built_in">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[get(<span class="meta-string">"/"</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> async <span class="function"><span class="keyword">fn</span> <span class="title">index</span></span>(query: web::Query&lt;Info&gt;) -&gt; <span class="built_in">Result</span>&lt;HttpResponse, Error&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Query拿到与 Info 结构一样的参数</span></span><br><span class="line">    <span class="comment">// 如果你这么写，那么如果调用时如果不传 query 会报错，param 同理</span></span><br><span class="line">    <span class="comment">// rust 真严格..</span></span><br><span class="line">    <span class="keyword">let</span> result = crate::services::index::get_helloworld(query.message.clone());</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(HttpResponse::<span class="literal">Ok</span>().json(result))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，<code>services/index</code>，暂时不用<code>middleware</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::models::payload::Payload;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单写一个服务</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_helloworld</span></span>(msg: <span class="built_in">String</span>) -&gt; Payload&lt;()&gt; &#123;</span><br><span class="line">    Payload &#123;</span><br><span class="line">        code: <span class="number">0</span>,</span><br><span class="line">        message: msg.to_string(),</span><br><span class="line">        payload: <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后改一下<code>main.rs</code><br><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+mod controllers;</span></span><br><span class="line"><span class="addition">+mod models;</span></span><br><span class="line"><span class="addition">+mod services;</span></span><br><span class="line"></span><br><span class="line">#[actix_rt::main]</span><br><span class="line">async fn main() -&gt; io::Result&lt;()&gt; &#123;</span><br><span class="line"></span><br><span class="line">    let app = || App::new()</span><br><span class="line"><span class="deletion">-        .service(index);</span></span><br><span class="line"><span class="addition">+        .service(controllers::index::index);</span></span><br><span class="line"></span><br><span class="line">    info!("serving on localhost:7001");</span><br><span class="line"></span><br><span class="line">    HttpServer::new(app)</span><br><span class="line">        .bind("localhost:7001")?</span><br><span class="line">        .run()</span><br><span class="line">        .await</span><br></pre></td></tr></table></figure></p><p>测试一下，调用 <code>localhost:7001?message=helloworld</code>，就可以看到回复了！<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"helloworld"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码里我其实还用这些：</p><ul><li><code>router</code></li><li>写了一个配置的结构体用来封装 HOST, PORT 和数据库地址</li><li>环境变量配置</li></ul><p>文章就不写了，大概就那样。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul><li>建议用 CLion，VSCode 和 VIM 实在是太… IDE 也好，数据库分步调试什么的很方便</li><li>没 key 怎么办，找一个长期维护的开源项目，嫖就完事儿了</li><li>前端本来也想用<code>rust(yew)</code>的，可是在<code>raspbian</code>运行，不清楚结果。也不清楚其他选型，所以只能继续<code>electron + react</code>了，可能会去掉<code>umi</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;玩了一段时间 Vapor，想不明白谁家会用 swift 跑生产，可能也就 &lt;code&gt;perfect&lt;/code&gt; 维护者背后的公司会用，至少在拆哪应该还是要快(la)准(man)狠(kpi)的。&lt;br&gt;rust 社区中关注了 &lt;code&gt;rocket&lt;/code&gt; 一段时间，后面发现 &lt;code&gt;actix-web&lt;/code&gt; 在各方面更有优势，加上要好好点 rust 技能树，所以就选定这个了。&lt;/p&gt;
&lt;p&gt;这里会以重构我的闹钟后端作为蓝本，逐步做个记录。&lt;/p&gt;
&lt;h2 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;直接用 &lt;code&gt;cargo&lt;/code&gt; 创建应用&lt;/li&gt;
&lt;li&gt;装载 &lt;code&gt;actix-web&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;写一个 api&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="实践尝试" scheme="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="rust" scheme="https://colmugx.github.io/blog/tags/rust/"/>
    
      <category term="actix" scheme="https://colmugx.github.io/blog/tags/actix/"/>
    
  </entry>
  
  <entry>
    <title>如果我把 Rust 用在网页呢</title>
    <link href="https://colmugx.github.io/blog/2019/10/13/try-wasm/"/>
    <id>https://colmugx.github.io/blog/2019/10/13/try-wasm/</id>
    <published>2019-10-13T15:47:21.000Z</published>
    <updated>2019-12-29T04:31:21.412Z</updated>
    
    <content type="html"><![CDATA[<p>已知<code>Rust</code>是个很硬核的编程语言</p><p>又已知<code>JavaScript</code>或者说在浏览器上的<code>JavaScript</code>在某种情况无法胜任工作。</p><p>So？</p><blockquote><p>🦀 Rust + 🕸 Wasm = ❤</p></blockquote><p>但是，单纯把教程或者 tutorial 拿出来复述是没意思的。So，搞点事情</p><p>那么前提是，你已经弄清楚了 <code>wasm-pack</code> 是怎么回事了<br><a id="more"></a></p><h3 id="题干？"><a href="#题干？" class="headerlink" title="题干？"></a>题干？</h3><p>最近着手一个项目，使用浏览器的<code>crypto</code>实现了加解密，加解密都需要在浏览器处理。但毕竟解释型，最多只是混淆。即使我在编写时已经使用了花里胡哨的东西，就差整上钓鱼的那套手段了。不过，毕竟二进制的东西，总比混淆型更不容易肉眼解析，人脑编译</p><p>这里倒是可以交代，我用到了<code>aes-256-cfb</code>，所以我们大概需要这些东西</p><h3 id="板条箱？"><a href="#板条箱？" class="headerlink" title="板条箱？"></a>板条箱？</h3><p>毕竟是 Rust，注定是“简陋”的，所以我决定直接去找现有的密码学类库。目前已经亲测的密码学库有：</p><ul><li><a href="https://github.com/DaGenix/rust-crypto" target="_blank" rel="noopener">DaGenix/rust-crypto</a></li><li><a href="https://github.com/RustCrypto" target="_blank" rel="noopener">RustCrypto 系列</a></li></ul><p>如果运行在 <code>wasm</code>，第一个库需要使用另外一个有针对适应的</p><ul><li><a href="https://github.com/buttercup/rust-crypto-wasm" target="_blank" rel="noopener">buttercup/rust-crypto-wasm</a></li></ul><p>在写文章前我已经都“绕”过一遍了…在这之间反复横跳。刚开始以为这些库无法适用<code>wasm</code>（报错无法定位），后来觉得用起来好难（写得很绕），再后来发现是我写错了…</p><p>接着，可能需要一个随机数库，只能是<code>rand</code>了，而且也是<code>crates.io</code>下载量最多的（为什么…）</p><h3 id="创建？"><a href="#创建？" class="headerlink" title="创建？"></a>创建？</h3><blockquote><p>> cargo generate –git <a href="https://github.com/rustwasm/wasm-pack-template" target="_blank" rel="noopener">https://github.com/rustwasm/wasm-pack-template</a></p></blockquote><p>接着，安排上依赖<br><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">wasm-bindgen</span> = <span class="string">"0.2"</span> <span class="comment"># 核心</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">"0.7.2"</span> <span class="comment"># 但接下来用不上</span></span><br><span class="line"><span class="attr">aes</span> = <span class="string">"0.3.2"</span> <span class="comment"># 添加这个只是为了分组依赖与类型</span></span><br><span class="line"><span class="attr">cfb-mode</span> = <span class="string">"0.3.2"</span> <span class="comment"># 这个才是加密核心</span></span><br></pre></td></tr></table></figure></p><p>然后运行一遍<code>cargo build</code>或者<code>wasm-pack build</code>，因为<code>rust</code>在编译时会检查依赖情况，所以索性我就直接通过这种方式安装依赖了，就像写<code>swift</code>随手<code>cmd + b</code></p><h3 id="食用？"><a href="#食用？" class="headerlink" title="食用？"></a>食用？</h3><h4 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h4><ol><li><p>加载 crate（上板条！）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> aes;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> cfb_mode;</span><br></pre></td></tr></table></figure></li><li><p>声明依赖，或者说<code>import</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> aes::Aes256; <span class="comment">// 使用 256</span></span><br><span class="line"><span class="keyword">use</span> cfb_mode::stream_cipher::&#123;NewStreamCipher, StreamCipher&#125;; <span class="comment">// cfb是基于流加密其中一种</span></span><br><span class="line"><span class="keyword">use</span> cfb_mode::Cfb; <span class="comment">// 需要用这个结构体</span></span><br></pre></td></tr></table></figure></li><li><p>声明一个类型别名，方便使用<br>Rust 可以声明类型别名。为了后面方便实用，定义一个</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Cfb 结构体作为加密类型，Cfb 本身又需要一个类型…使用 Aes256 结构体声明长度</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">AesCfb</span></span> = Cfb&lt;Aes256&gt;;</span><br></pre></td></tr></table></figure></li><li><p>随便写个加密</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[wasm_bindgen]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">test</span></span>() -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> key: &amp;[<span class="built_in">u8</span>; <span class="number">32</span>] = b"nashizhendeniup,,nashizhendeniup<span class="string">";</span></span><br><span class="line"><span class="string">  let iv: &amp;[u8; 16]  = b"</span>unique,un,unique<span class="string">";</span></span><br><span class="line"><span class="string">  let msg = "</span>那你是真的牛皮<span class="string">";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  let mut buffer = msg.as_bytes().to_vec();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  AesCfb::new_var(key, iv).unwrap().encrypt(&amp;mut buffer);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  buffer</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="到前端使用"><a href="#到前端使用" class="headerlink" title="到前端使用"></a>到前端使用</h4><p>经过编译<code>wasm-pack build</code>，可以得到一个<code>pkg</code>目录。目录下的文件就很熟悉了！</p><ul><li>package.json</li><li>&lt;xxx>.wasm</li><li>&lt;xxx>.d.ts</li><li>……</li></ul><p>你甚至可以直接把这个包上到<code>npm</code>，让更多人可以使用。这里我们就只是<code>yarn link</code>，然后创建一个前端项目</p><blockquote><p>> npm init wasm-app www</p></blockquote><p>接着，有着 50 年前端经验的老前端应该都会接下来的步骤了：<code>yarn</code> -&gt; <code>yarn link &lt;xxx&gt;</code></p><p>然后，把<code>JavaScript</code>的代码改改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;test&#125; <span class="keyword">from</span> <span class="string">'crypto-test'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test())</span><br></pre></td></tr></table></figure><p>因为 <code>Rust</code> 是强类型的语言，所以在类型推断不会有太多麻烦。同时，在通过工具编译到<code>wasm</code>时会多编译一个<code>d.ts</code>文件。这样，就算暴露给<code>JavaScript</code>的代码再复杂，只要使用 VSCode 或者支持 TS 的 Language Server 也没有太大压力</p><p>所以这样我就得到一个加密数据集合，<code>Vec&lt;u8&gt;</code>到<code>JavaScript</code>那边会直接变成<code>UTF8</code>类型数组，所以我们会打印出这东西<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uint8Array(21) [230, 156, 59, 211, 78, 162, 142, 118, 193, 154, 45, 255, 203, 56, 123, 8, 143, 173, 46, 120, 25]</span><br></pre></td></tr></table></figure></p><p>用<code>node</code>的话，一般会把加密数据转成字符串保存（比如我提到的我在做的项目），这里就先裸着吧</p><p>那<code>wasm</code>画风是怎样的呢？给个节选参考一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  get_local $p0</span><br><span class="line">  i32.load</span><br><span class="line">  get_local $p1</span><br><span class="line">  call $core::fmt::Write::write_char::h90a3bac002e2aa8d)</span><br><span class="line">(func $&lt;&amp;T_as_core::fmt::Debug&gt;::fmt::h110ce52a73dd639b (type $t6) (param $p0 i32) (param $p1 i32) (result i32)</span><br><span class="line">  get_local $p0</span><br><span class="line">  i32.load</span><br><span class="line">  get_local $p1</span><br><span class="line">  call $core::fmt::num::&lt;impl_core::fmt::Debug_for_usize&gt;::fmt::hf84d386a4f5a1afb)</span><br><span class="line">(func $__rdl_dealloc (type $t7) (param $p0 i32) (param $p1 i32) (param $p2 i32)</span><br><span class="line">  i32.const 1056732</span><br><span class="line">  get_local $p0</span><br></pre></td></tr></table></figure></p><p>看得我都有女装的冲动了（大雾</p><h3 id="结束？"><a href="#结束？" class="headerlink" title="结束？"></a>结束？</h3><p>文章的目标只有两个：</p><ul><li>体验<code>rust + wasm</code></li><li>干一手加密，看看是否能取代浏览器的<code>crypto</code>，不考虑性能</li></ul><p>因为<code>Rust</code>的发展快接近完整了，这个时候入坑应该挺合适。所以接下来我就指望靠这个语言接近计科的世界了</p><p>最后，有一点需要注意，所选择的<code>AES</code>长度不同，会影响你需要的秘钥长度。所以，这个时候可以唠唠加密？</p><h3 id="（附加资料）加密？"><a href="#（附加资料）加密？" class="headerlink" title="（附加资料）加密？"></a>（附加资料）加密？</h3><h4 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h4><p>分组密码将明文分成多个等长的模块（block），使用确定的算法和对称密钥对每组分别加密解密。所以，这种加密方式带来的问题就是：对越长的字符串进行加密，代价越大</p><h4 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h4><p>对称加密的一种（对称加密就不解释了），也是目前最流行的对称加密算法之一。该算法属于分组加密算法。</p><p>AES的区块长度固定为128比特，密钥长度则可以是128，192或256比特。</p><p>加密方式也有很多模式：ecb, cfb, gcm, cbc。其中 ecb 没有 iv</p><p>我们在使用密码库的时候，都会接触到 <code>key</code>, <code>iv</code> 还有可能需要<code>padding</code></p><h5 id="iv"><a href="#iv" class="headerlink" title="iv?"></a>iv?</h5><p>初始化向量（IV，Initialization Vector）是许多任务作模式中用于将加密随机化的一个位块，由此即使同样的明文被多次加密也会产生不同的密文，避免了较慢的重新产生密钥的过程。</p><p>在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个IV。对于CBC和CFB，重用IV会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。对于OFB和CTR而言，重用IV会导致完全失去安全性。</p><p>一般来说，向量用于分组加密中其中第一个块的加密，其他块均为自动生成（就是提供向量）</p><h5 id="key"><a href="#key" class="headerlink" title="key?"></a>key?</h5><p>加密密钥，对于 aes 来说就是每个块使用到的加密密钥</p><h5 id="padding"><a href="#padding" class="headerlink" title="padding?"></a>padding?</h5><p>padding 是用来填充最后一块使得变成一整块，所以对于加密解密两端需要使用同一的 PADDING 模式，大部分 PADDING 模式为PKCS5, PKCS7, NOPADDING。</p><h4 id="AES256-128"><a href="#AES256-128" class="headerlink" title="AES256? 128?"></a>AES256? 128?</h4><p>其中，<code>iv</code>肯定是 16 位。因为加密块的长度就是这么限制的</p><p>区别在于密钥长度，<code>Aes128</code> 的密钥长度需要 16 位，而 <code>Aes256</code> 需要的密钥长度是 32 位</p><p>为什么呢？算一下不就知道了</p><h4 id="AES256CFB"><a href="#AES256CFB" class="headerlink" title="AES256CFB?"></a>AES256CFB?</h4><p>就是使用 aes，长度 256，那么 cfb 呢？</p><p>密文反馈（CFB，Cipher feedback），可以理解是反向 CBC，因为 CFB 的解密过程几乎就是颠倒的CBC的加密过程</p><p>那，也不用想太多，就是使用 AES 加密，长度使用 256，模式使用 cfb</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已知&lt;code&gt;Rust&lt;/code&gt;是个很硬核的编程语言&lt;/p&gt;
&lt;p&gt;又已知&lt;code&gt;JavaScript&lt;/code&gt;或者说在浏览器上的&lt;code&gt;JavaScript&lt;/code&gt;在某种情况无法胜任工作。&lt;/p&gt;
&lt;p&gt;So？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🦀 Rust + 🕸 Wasm = ❤&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是，单纯把教程或者 tutorial 拿出来复述是没意思的。So，搞点事情&lt;/p&gt;
&lt;p&gt;那么前提是，你已经弄清楚了 &lt;code&gt;wasm-pack&lt;/code&gt; 是怎么回事了&lt;br&gt;
    
    </summary>
    
      <category term="实践尝试" scheme="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="TypeScript" scheme="https://colmugx.github.io/blog/tags/TypeScript/"/>
    
      <category term="rust" scheme="https://colmugx.github.io/blog/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>来自 swift 的跨界执法（一） —— Vapor</title>
    <link href="https://colmugx.github.io/blog/2019/06/23/try-vapor-0/"/>
    <id>https://colmugx.github.io/blog/2019/06/23/try-vapor-0/</id>
    <published>2019-06-23T08:17:53.000Z</published>
    <updated>2019-12-18T15:04:17.237Z</updated>
    
    <content type="html"><![CDATA[<p>Vapor 应该是目前比较成熟的服务器应用框架了，更新快，社区“繁荣”</p><p>所以，直接干吧<br><a id="more"></a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>直接装个工具集吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap vapor/tap</span><br><span class="line">brew install vapor/tap/vapor</span><br></pre></td></tr></table></figure></p><h3 id="生成应用"><a href="#生成应用" class="headerlink" title="生成应用"></a>生成应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vapor new Hello</span><br></pre></td></tr></table></figure><p>等待一会，出现水滴图案时就初始化完成了</p><p>接着进目录，生成<code>xcode</code>可以使用的工程文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./Hello</span><br><span class="line">vapor xcode</span><br></pre></td></tr></table></figure><p>依然是等待一会之后，<code>cmd</code>会询问你是否打开<code>XCode</code>，打开便是</p><h3 id="编写体验"><a href="#编写体验" class="headerlink" title="编写体验"></a>编写体验</h3><p>vapor 默认会给几种方案，如果直接 new 的话默认是<code>api</code>方案，也就是“接口服务器”。</p><p>所以一打开，就能看到工程已经被“安排好了”：一般所需要的目录结构，以及默认使用<code>SQLite3</code>数据库（运行在内存）</p><p>本来我打算通过<code>Todos</code>练练手，现在看起来好像参考答案已经给出来了…默认情况下也不需要怎么去补充，按照自己的编程习惯直接用就行了。</p><p>但这里用内存数据库属实8合适，所以改一下数据库存储方式<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DirectoryConfig.detect().workDir 项目绝对路径</span></span><br><span class="line"><span class="keyword">let</span> storePath = <span class="type">DirectoryConfig</span>.detect().workDir + <span class="string">"Db/store.db"</span></span><br><span class="line"><span class="keyword">let</span> sqlite = <span class="keyword">try</span> <span class="type">SQLiteDatabase</span>(storage: .file(path: storePath))</span><br></pre></td></tr></table></figure></p><p>这样一来就把数据库位置移动到工程中<code>Db</code>目录下了，第一次运行就会直接创建数据库</p><p>对了，Vapor 自己带一个 ORM <code>Fluent</code>，所以关系型数据库操作不会太操蛋</p><p>所以下一篇应该是讨论一个更合适的<code>restful</code>写法？或者是用上<code>gRPC</code>？</p><h3 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a>相关信息</h3><p>Vapor 自己提供一个<a href="http://vapor.university/" target="_blank" rel="noopener">「大学」</a>，这里都是组织自己录的教学视频，基本点都涵盖到了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vapor 应该是目前比较成熟的服务器应用框架了，更新快，社区“繁荣”&lt;/p&gt;
&lt;p&gt;所以，直接干吧&lt;br&gt;
    
    </summary>
    
      <category term="实践尝试" scheme="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="swift" scheme="https://colmugx.github.io/blog/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>来自 swift 的跨界执法（零） —— Perfect</title>
    <link href="https://colmugx.github.io/blog/2019/06/07/try-swift-perfect/"/>
    <id>https://colmugx.github.io/blog/2019/06/07/try-swift-perfect/</id>
    <published>2019-06-07T08:39:39.000Z</published>
    <updated>2019-07-27T10:45:38.963Z</updated>
    
    <content type="html"><![CDATA[<p>因为不可抗力没上班，看着新<code>swift</code>和<code>swiftUI</code>发布，决定搞<code>Perfect</code>。</p><p>这个框架可是听说很久了，匆忙看了两眼就没有下文。当时来说是最强 Server-site 框架（为什么要说当时？）</p><p>篇幅不长，仅做一个尝试和介绍，原因在最后。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装还是相当容易，官方编译器起一个可执行类型项目<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift package <span class="keyword">init</span> --type=executable</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>其次，在<code>Package.swift</code>中添加依赖<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies: [</span><br><span class="line">    .package(url: <span class="string">"https://github.com/PerfectlySoft/Perfect-HTTPServer.git"</span>, from: <span class="string">"3.0.0"</span>)</span><br><span class="line">],</span><br></pre></td></tr></table></figure></p><p>接着，编译即安装依赖（熟悉啊！）<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift build</span><br></pre></td></tr></table></figure></p><p>最后，生成<code>xcodeproj</code>文件以<code>xcode</code>打开，接下来工作交还给<code>xcode</code><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift package generate-xcodeproj</span><br></pre></td></tr></table></figure></p><p>不得不说，你果<code>XCode</code>到从系统<code>10.10</code>开始那会到如今 9102 年了，体验还是这么糟糕。然而苹果家的两个语言，不用<code>XCode</code>体验更糟…</p><h3 id="编写体验"><a href="#编写体验" class="headerlink" title="编写体验"></a>编写体验</h3><p>初始化项目什么目录都没有，作为一个毫无后端经验的 API 拼装师，只能假把式创建<code>controllers</code>与<code>models</code>目录，加上习惯加一个<code>constant</code>目录。</p><p><del>后来发现，我好像用不上</del></p><p>按照习惯创建了一个结构体用来存放配置内容<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GlobalConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> baseRoute = <span class="string">"/api/v1"</span></span><br><span class="line">    <span class="keyword">let</span> httpPort = <span class="number">8081</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着，清空<code>main.swift</code>，根据<code>swift</code>的逻辑：只有库需要引用，业务文件同一项目下不需要<code>import</code>。所以引入<code>perfect</code>，并初始化<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PerfectHTTP</span><br><span class="line"><span class="keyword">import</span> PerfectHTTPServer</span><br><span class="line"><span class="comment">// 字典不是JSON，使用库中方法得以把字典转为JSON</span></span><br><span class="line"><span class="keyword">import</span> PerfectLib</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> config = <span class="type">GlobalConfig</span>()</span><br><span class="line"><span class="keyword">let</span> server = <span class="type">HTTPServer</span>()</span><br><span class="line"><span class="keyword">var</span> routes = <span class="type">Routes</span>(baseUri: config.baseRoute)</span><br></pre></td></tr></table></figure></p><p>然后制定一个<code>restful</code>类型路由（原本写在<code>Router.swift</code>）<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: [[<span class="type">String</span>: <span class="type">Any</span>]] = [</span><br><span class="line">    [<span class="string">"name"</span>: <span class="string">"index"</span>, <span class="string">"url"</span>: <span class="string">"/home"</span>, <span class="string">"method"</span>: <span class="type">HTTPMethod</span>.<span class="keyword">get</span>],</span><br><span class="line">    [<span class="string">"name"</span>: <span class="string">"show"</span>, <span class="string">"url"</span>: <span class="string">"/home/&#123;id&#125;"</span>, <span class="string">"method"</span>: <span class="type">HTTPMethod</span>.<span class="keyword">get</span>],</span><br><span class="line">    [<span class="string">"name"</span>: <span class="string">"create"</span>, <span class="string">"url"</span>: <span class="string">"/home"</span>, <span class="string">"method"</span>: <span class="type">HTTPMethod</span>.post],</span><br><span class="line">    [<span class="string">"name"</span>: <span class="string">"update"</span>, <span class="string">"url"</span>: <span class="string">"/home/&#123;id&#125;"</span>, <span class="string">"method"</span>: <span class="type">HTTPMethod</span>.put],</span><br><span class="line">    [<span class="string">"name"</span>: <span class="string">"delete"</span>, <span class="string">"url"</span>: <span class="string">"/home/&#123;id&#125;"</span>, <span class="string">"method"</span>: <span class="type">HTTPMethod</span>.delete]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>接着，通过<code>swift</code>的<code>map</code>（不是很合适）随便载入一套路由（有时候真的恨<code>swift</code>的类型安全）<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RoutesConfig</span>().list.<span class="built_in">map</span> &#123;</span><br><span class="line">    routes.add(method: $<span class="number">0</span>[<span class="string">"method"</span>] <span class="keyword">as</span>! <span class="type">HTTPMethod</span>, uri: $<span class="number">0</span>[<span class="string">"url"</span>] <span class="keyword">as</span>! <span class="type">String</span>, handler: &#123; (request, response) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> json: [<span class="type">String</span>: <span class="type">Any</span>] = [<span class="string">"code"</span>: <span class="number">0</span>, <span class="string">"message"</span>: <span class="string">"success"</span>]</span><br><span class="line">        <span class="keyword">let</span> variables = request.urlVariables</span><br><span class="line">        <span class="keyword">var</span> newJson = json</span><br><span class="line">        <span class="keyword">if</span> (!variables.isEmpty) &#123;</span><br><span class="line">            <span class="keyword">for</span> e <span class="keyword">in</span> variables &#123;</span><br><span class="line">                newJson[e.key] = variables[e.key]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> output = <span class="keyword">try</span>! newJson   <span class="comment">// 因都是字面量，所以必有值（真nm安全，业务尽量不要这么搞）</span></span><br><span class="line">            .jsonEncodedString()</span><br><span class="line">        response</span><br><span class="line">            .setHeader(.contentType, value: <span class="string">"application/json"</span>)</span><br><span class="line">            .appendBody(string: output)</span><br><span class="line">            .completed()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>路由载入服务并指定端口（直接执行会默认<code>0.0.0.0:8081</code>）<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.addRoutes(routes)</span><br><span class="line">server.serverPort = <span class="type">UInt16</span>(config.httpPort)</span><br></pre></td></tr></table></figure></p><p>最后（简单）执行<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> server.start()</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"\(error)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul><li>文档虽是详细，但是周边很少，社区冷淡（都不知道有没有）。而且资料很少，很难查到关于这个框架的讨论或者内容。</li><li>Star 虽然证明不了什么，但是从昔日第一，到现在第二，距离第一也有很大差距。又语言关系，并不会有像某些库那样的宗教化。故必有某些原因。</li></ul><p>所以，你好<code>Vapor</code>！这可能是目前<code>swift server side</code>最优解决方案。并且这也是标题从“零”开始的原因。</p><p>并且在文章提交之前，发现<code>Vapor</code>已经支持<code>Swift 5.1</code>，本体也更新频繁，大概知道为什么<code>Perfect</code>为什么会没落了。</p><p>不过，我觉得可以先尝试<code>Vapor</code>，再看看哪个使用手感更适合我。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为不可抗力没上班，看着新&lt;code&gt;swift&lt;/code&gt;和&lt;code&gt;swiftUI&lt;/code&gt;发布，决定搞&lt;code&gt;Perfect&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个框架可是听说很久了，匆忙看了两眼就没有下文。当时来说是最强 Server-site 框架（为什么要说当时？）&lt;/p&gt;
&lt;p&gt;篇幅不长，仅做一个尝试和介绍，原因在最后。&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;安装还是相当容易，官方编译器起一个可执行类型项目&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;swift package &lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt; --type=executable&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="实践尝试" scheme="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="swift" scheme="https://colmugx.github.io/blog/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>react函数级写法和继承写法有什么区别？</title>
    <link href="https://colmugx.github.io/blog/2019/05/28/react-component-method/"/>
    <id>https://colmugx.github.io/blog/2019/05/28/react-component-method/</id>
    <published>2019-05-28T15:48:21.000Z</published>
    <updated>2019-05-29T16:16:15.036Z</updated>
    
    <content type="html"><![CDATA[<p>这问题真的是土到我了，立刻就发了一个知乎想法。但后来我发现，他会不会想问的是几百年前，在盘古开天辟地之后的<code>react 0.x</code>时代，于是我默默把想法干掉了。</p><p>如果是<code>createClass</code>和<code>extends React.Component</code>，还有点意思。如果是<code>functional component</code>，那您怎么不用同样很「渐进式」同时又更牛逼的<code>vue</code>呢？</p><p>简单对比：</p><table><thead><tr><th style="text-align:center">createClass</th><th style="text-align:center">Component/PureComponent</th></tr></thead><tbody><tr><td style="text-align:center">ES5</td><td style="text-align:center">ES6</td></tr><tr><td style="text-align:center">propTypes/getDefaultProp</td><td style="text-align:center">Component.defaultProps/Component.propType</td></tr><tr><td style="text-align:center">this 已被指定</td><td style="text-align:center">属性 this 不默认指向组件（实例）</td></tr><tr><td style="text-align:center">mixin</td><td style="text-align:center">mixin（被取消，不建议，做不到，HOC）</td></tr></tbody></table><p>其中对我来说，这两个的区别可能<code>mixin</code>最有意思<br><a id="more"></a></p><h3 id="编写风格"><a href="#编写风格" class="headerlink" title="编写风格"></a>编写风格</h3><p><code>createClass</code> 用的是给函数传递一个对象的方式创建组件，风格很像<code>vue</code>，<code>Component</code>用的是对象继承的方式创建组件。好像没什么好说的。</p><h3 id="default-props"><a href="#default-props" class="headerlink" title="default props"></a>default props</h3><p><code>createClass</code>依然跟现在的<code>vue</code>写法很像，不过从<code>vue</code>中<code>props[xxx].default</code>变成<code>getDefaultProp</code>方法，同时对象内通过<code>propTypes</code>做接口类型检查。</p><p><code>classes</code>型的默认接口和接口检查都是来源于对象两个静态对象。</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p><code>createClass</code>同样与<code>vue</code>差不多，<code>this</code>会指向到组件上，应该还是处于同一对象中的原因。<code>classes</code>类型的可没那么顺利，<code>this</code>会指向到类上，所以写<code>react</code>的时候，方法难免还要在构造函数中<code>bind</code>一次，当然如果方法是箭头函数的话麻烦少很多。</p><h3 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h3><p><code>createClass</code>依然与<code>vue</code>的差不多（<code>vue</code>抄得妙啊），遗憾<code>classes</code>不支持<code>mixin</code>了。</p><p>我也不喜欢<code>mixin</code>，也觉得这东西不适合<code>react</code>的理念。<code>mixin</code>是把一个对象的内容与另一个对象的内容合并，看起来复用性利用率很高（别bb抽就完事儿了嗷），但，同名函数怎么办？改动怎么办？东西一多就沉浸在不断重写<del>与复读</del>，造成副作用，牵一发而动全身的情况。</p><p>高阶函数多好，编写一个可复用函数，把计划使用复用内容的函数或对象以参数形式传入，在使用组件或者函数的同时又把复用内容执行完。首先<code>HOC</code>可以想象成是「悠米」——它挂在你身上，加盾，加速，加血，加自适应。它挂在谁身上都一样，不受干扰。</p><blockquote><p>只要我的队友还活着，我就不会遭受苦难 —— 悠米</p></blockquote><p>而每次经过高阶函数之后又是一个新的函数，每个新函数相对独立，不存在副作用。</p><p>但<code>HOC</code>写起来还是有两种，以<code>react</code>返回<code>Component</code>来说，返回的对象又会有两种。</p><ul><li>返回的<code>Component</code>继承于全新的<code>React.Component</code>(react-redux:connect)</li><li>返回的<code>Component</code>继承于参数的<code>Component</code>(反向继承)(reabit:inject)</li></ul><p>第一种最后的结果是<code>render</code>时以组件的形式调用参数，第二种则是通过<code>super</code>在各种地方执行（整个方法执行直接在构造函数执行<code>super([传入适用原组件props])</code>），各有利弊。</p><p>而因为反向继承的关系，我可以获得组件很多内容，所以某种意义上可以当做<code>mixin</code>使用。</p><p>不过毕竟<code>HOC</code>，有一个问题：原组件如果存在<code>static</code>方法将不能被使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这问题真的是土到我了，立刻就发了一个知乎想法。但后来我发现，他会不会想问的是几百年前，在盘古开天辟地之后的&lt;code&gt;react 0.x&lt;/code&gt;时代，于是我默默把想法干掉了。&lt;/p&gt;
&lt;p&gt;如果是&lt;code&gt;createClass&lt;/code&gt;和&lt;code&gt;extends React.Component&lt;/code&gt;，还有点意思。如果是&lt;code&gt;functional component&lt;/code&gt;，那您怎么不用同样很「渐进式」同时又更牛逼的&lt;code&gt;vue&lt;/code&gt;呢？&lt;/p&gt;
&lt;p&gt;简单对比：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;createClass&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Component/PureComponent&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;ES5&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;ES6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;propTypes/getDefaultProp&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Component.defaultProps/Component.propType&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;this 已被指定&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;属性 this 不默认指向组件（实例）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;mixin&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;mixin（被取消，不建议，做不到，HOC）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中对我来说，这两个的区别可能&lt;code&gt;mixin&lt;/code&gt;最有意思&lt;br&gt;
    
    </summary>
    
      <category term="编程议论" scheme="https://colmugx.github.io/blog/categories/%E7%BC%96%E7%A8%8B%E8%AE%AE%E8%AE%BA/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
      <category term="react" scheme="https://colmugx.github.io/blog/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>defineProperty? Proxy?</title>
    <link href="https://colmugx.github.io/blog/2019/04/20/why-vue-proxy/"/>
    <id>https://colmugx.github.io/blog/2019/04/20/why-vue-proxy/</id>
    <published>2019-04-20T04:47:12.000Z</published>
    <updated>2019-04-26T05:28:08.142Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>听说 Vue3 数据绑定要切换到 Proxy，为什么？</p></blockquote><p>这就是这篇文章的原因，来源于某个牛逼公司的面试。<del>我真的应该学会怎么清楚表达观点…</del></p><p><code>defineProperty</code> 和 <code>Proxy</code> 使用方式和效果看起来是差不多的，但如果翻译成中文的话，一个是定义属性，一个是代理，并且 MDN 上描述有所不同。</p><blockquote><p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 —— MDN</p></blockquote><blockquote><p>Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。  —— MDN</p></blockquote><h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h3><p>这是一个 <code>ES5</code> 的方法。一个 <code>defineProperty</code> 需要三个参数，都是 <code>require</code><br><a id="more"></a></p><blockquote><p>Object.defineProperty(obj, prop, descriptor)<br>obj: object, 定义的对象（我理解为附着于哪个对象）<br>prop: 定义的对象名称(key)<br>descriptor: 将被定义或修改的属性描述符。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'colmugx'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>descriptor</code> 存在可选项：</p><table><thead><tr><th style="text-align:left">key</th><th style="text-align:left">value</th></tr></thead><tbody><tr><td style="text-align:left">configurable</td><td style="text-align:left">该属性为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</td></tr><tr><td style="text-align:left">enumerable</td><td style="text-align:left">该属性为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。</td></tr><tr><td style="text-align:left">value</td><td style="text-align:left">该属性对应的值。</td></tr><tr><td style="text-align:left">writable</td><td style="text-align:left">该属性为 true 时，value才能被赋值运算符改变。默认为 false。</td></tr><tr><td style="text-align:left">get</td><td style="text-align:left">getter 方法</td></tr><tr><td style="text-align:left">set</td><td style="text-align:left">setter 方法</td></tr></tbody></table><p>除了 <code>boolean</code> 类型，值都默认为 <code>undefined</code></p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>这是一个 <code>ES6</code> 的方法，<code>Proxy</code> 参数比较简单</p><blockquote><p>new Proxy(target, handler)<br>target: 目标对象<br>handler: 属性/操作对象，当执行一个操作时定义代理的行为的函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, name) &#123;</span><br><span class="line">    <span class="keyword">return</span> name <span class="keyword">in</span> target ? target[name] : target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="？"><a href="#？" class="headerlink" title="？"></a>？</h3><h4 id="数据拦截"><a href="#数据拦截" class="headerlink" title="数据拦截"></a>数据拦截</h4><p>先看看 <code>Vue</code> 那种数据拦截是怎样的，做一个简单实现。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> value = <span class="literal">undefined</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'key'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span>(val) &#123;</span><br><span class="line">    value = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>很明显，我可以劫持一个对象的 <code>getter</code> 和 <code>setter</code>，同时也很明显，貌似需要一个缓存量。</p><p>如果说和 <code>Proxy</code> 比较呢？因为 <code>Proxy</code> 实现的是代理下整个对象，那么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;<span class="attr">key</span>: <span class="literal">undefined</span>&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">    <span class="comment">// 由于代理了所有操作，那么返回 404 纯属意愿</span></span><br><span class="line">    <span class="keyword">return</span> prop <span class="keyword">in</span> target ? target[prop] : <span class="string">'404 Not Found'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span>(val) &#123;</span><br><span class="line">    target[prop] = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>写法有点像<code>computed</code></p><p>那么，为什么<code>defineProperty</code>不直接<code>target[prop] = val</code>？因为劫持关系，你会看到狗咬尾巴的奇观。也就是说，<code>defineProperty</code> 对原对象操作就会触发劫持，而<code>Proxy</code>操作的是实例对象，每个实例对象相对独立。</p><p>所以通过两次面试，闭环了这个知识。另外一篇：<a href="/blog/2018/03/16/vue-watcher">vue watch存在永动吗？</a></p><p>然而<code>Vue</code>换方式，显然不止因为这个，或许连这个都谈不上。</p><h4 id="只需要-defineProperty？怎么可能？"><a href="#只需要-defineProperty？怎么可能？" class="headerlink" title="只需要 defineProperty？怎么可能？"></a>只需要 defineProperty？怎么可能？</h4><p>首先，上面例子这种方式可以看出，我每次操作都只能监听一个值，但一个应用不可能只有一个属性，而且没办法及时知道哪一个属性获得了更新。在深入了解之后，<code>Vue</code>好像用了订阅的方式在做这些事情。</p><p><a href="https://github.com/vuejs/vue/blob/52719ccab8/src/core/observer/index.js#L109" target="_blank" rel="noopener">vue/src/core/observer/index.js#L109</a></p><p>除了简单（没有深度）数据，其他一概遍历进观察者。</p><h4 id="为什么-Proxy？"><a href="#为什么-Proxy？" class="headerlink" title="为什么 Proxy？"></a>为什么 Proxy？</h4><ol><li><code>defineProperty</code> 对数组有硬伤</li></ol><p>因为设定关系，<code>defineProperty</code>不能观察到数组内部，如果直接修改数组而不是返回新数组的话，无法触发劫持。<code>Vue</code>文档以一个简单的方式解释了<a href="https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B" target="_blank" rel="noopener">这个问题</a>，解决这个问题的方法有点骚，<a href="https://github.com/vuejs/vue/blob/52719ccab8fccffbdf497b96d3731dc86f04c1ce/src/core/observer/array.js#L11" target="_blank" rel="noopener">相关源码位置</a>。但这只是让数组方法可以“正常使用”，万一有人<code>arr[0] = 0</code>呢？</p><ol start="2"><li>一个方法只能监听一个属性</li></ol><p>如果我需要监听这个对象里所有键，我需要把所有键都<code>defineProperty</code>一次。需要创建一个缓存变量倒不是什么“难事”，封装成一个方法就成了，但：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">d</span>: &#123; <span class="attr">e</span>: <span class="string">'???'</span> &#125;&#125;&#125;&#125;&#125;  <span class="comment">// ???</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>Proxy</code> 可以做到上面所有事情</li></ol><p>上面提到，<code>Proxy</code>是代理了整个对象，而且是以根据 target 创建实例来进行接下来的工作，每一个都相对独立。</p><p>第一个问题，因为我们有这个“对象”的所有操作权，而且每次<code>set</code>都能返回新的“对象”，并且我们可以自己定义“数据如何改变”</p><p>第二个问题，因为<code>Proxy</code>实现的是观察到整个对象而不是对象属性，那自然不存在这个问题了。</p><ol start="4"><li>除了 <code>getter</code>, <code>setter</code>，<code>Proxy</code>还有其他用法</li></ol><p>比如<code>apply</code>，可以劫持对象的函数（我的理解是把对象可以执行，当然JavaScript中，一切都是对象）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  apply(target, context, args) &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所以你可以执行一些东西，甚至是通过方法创建/改变得到一个对象（对 target 直接修改）</p><p>感觉，如果<code>Vue3</code>用<code>Proxy</code>改写之后，代码会简洁非常多。而且性能可能会比现在提高好几倍（？），毕竟看目前得到的信息，对每一个数据创建<code>Observer</code> + <code>defineProperty</code>，性能挺要命的……</p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><code>Proxy</code>在这里的用法只能说是「能当对象使用的对象」吧，毕竟它还是一个实例(Proxy(…)，而<code>defineProperty</code>操作的是意义上的对象。</p><p>而且我本以为我应该会先读<code>React</code>的源码，没想到…</p><h3 id="为什么-Vue2-不直接用-Proxy"><a href="#为什么-Vue2-不直接用-Proxy" class="headerlink" title="为什么 Vue2 不直接用 Proxy"></a>为什么 Vue2 不直接用 Proxy</h3><p><code>Vue</code> 最早出现于 2013 年，<code>ES2015</code> 规范确定于 2015年，目前找不到 <code>Vue2</code> 第一个 commit 是什么时候（懒），推算了一下，不应该是赶不上，所以有第二种猜想：兼容性问题。</p><p><code>Vue</code>可以支持到 IE9+，目前的兼容性是 IE10+。首先<code>Proxy</code>就已经把 IE 完整的抛弃掉了，一点点都不支持。就算上 <code>polyfill</code>，也仅可以使用<code>get</code>, <code>set</code>, <code>apply</code>, <code>construct</code>，而 <code>Proxy</code> 的钩子(陷阱)达到十几种，显然物尽其能是不可能。</p><p>时代不同了，现在是现代浏览器时代，IE 淡出，连 Edge 都投靠敌台了。话说我最喜欢的就是最后一代斯巴达，渲染很快又开始支持插件。</p><h3 id="Vue-amp-React"><a href="#Vue-amp-React" class="headerlink" title="Vue &amp; React"></a>Vue &amp; React</h3><p>18 年我经常说的就是，如果技术参差不齐的团队，显然<code>Vue</code>更合适。反正你照着说明书一行一行抄肯定不会抄出问题。<strong>所以我不喜欢 Vue 就是因为不够自由，但如果无法驾驭自由，React 性能会更差。</strong></p><p>其中一个原因就是 <code>Vue</code> 跟 <code>React</code> 对数据的操作是不一样的。<code>React</code>单向，通过对比来更新数据，所以今日会有两种组件创建方式：<code>Component</code>, <code>PureComponent</code>。</p><blockquote><p>为什么 React 不学 Vue 搞这手，表单验证之类工作不是很好实现</p></blockquote><p>大家的想法都不一样为什么要强比较？所以我的回答是：</p><blockquote><p>这是 React 的设计原因，React 的做法是数据流单向，利用函数式的思想，像管道一样的操作使得副作用更加可控。</p></blockquote><p>只是回答得不完美，我有面试就紧张的坏心态。我的本意是我可以清楚数据的流向，同时采用数据不可变，这样根本不用担心数据在中途突然被什么做了修改。因为前面的原因，第二个问题忘记回答了：因为用函数式的思想，那么表单验证我可以用高阶函数呀。</p><p>但并不是说<code>Vue</code>的做法不是高阶函数，其实也是的。只是我们在用<code>React</code>的时候，感觉<code>React</code>只提供了把代码转成视图的功能，就没了，什么都没有什么都是自己实现。而<code>Vue</code>已经实装了非常多的操作使得开发过程不用想多一些问题。举一个小栗子：<code>React</code>渲染一个列表，靠的是自己用<code>JavaScript</code>的方法生成一个装着<code>ReactNode</code>的数组，而<code>Vue</code>只需要在模板中标记列表数据和在哪个节点渲染，把要渲染的内容写在其中即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;听说 Vue3 数据绑定要切换到 Proxy，为什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就是这篇文章的原因，来源于某个牛逼公司的面试。&lt;del&gt;我真的应该学会怎么清楚表达观点…&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;defineProperty&lt;/code&gt; 和 &lt;code&gt;Proxy&lt;/code&gt; 使用方式和效果看起来是差不多的，但如果翻译成中文的话，一个是定义属性，一个是代理，并且 MDN 上描述有所不同。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 —— MDN&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。  —— MDN&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;defineProperty&quot;&gt;&lt;a href=&quot;#defineProperty&quot; class=&quot;headerlink&quot; title=&quot;defineProperty&quot;&gt;&lt;/a&gt;defineProperty&lt;/h3&gt;&lt;p&gt;这是一个 &lt;code&gt;ES5&lt;/code&gt; 的方法。一个 &lt;code&gt;defineProperty&lt;/code&gt; 需要三个参数，都是 &lt;code&gt;require&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="编程议论" scheme="https://colmugx.github.io/blog/categories/%E7%BC%96%E7%A8%8B%E8%AE%AE%E8%AE%BA/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
      <category term="vue" scheme="https://colmugx.github.io/blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>关于 Nlvi 「添加到桌面」</title>
    <link href="https://colmugx.github.io/blog/2019/04/17/about-nlvi-pwa/"/>
    <id>https://colmugx.github.io/blog/2019/04/17/about-nlvi-pwa/</id>
    <published>2019-04-17T09:36:28.000Z</published>
    <updated>2019-04-17T10:17:35.456Z</updated>
    
    <content type="html"><![CDATA[<p>其实这个功能早在 2.x 版本就加入了，那时候对 PWA 并没有什么概念。<del>好想换 iPad Mini (new)</del></p><p><img src="/blog/Image/nlvi-ios-desktop.gif" alt="nlvi-ios-desktop"></p><p>目前 3.x 只改了启动图，适配了 iPad 横屏和 iPhone 全面屏（普通屏和plus后续加）。之前看到苹果对 PWA 持拒绝态度我是震惊的，你 tm 早就给 safari 加入了这个功能，也有相关<code>meta</code>配置（包括”识别为<code>WebApp</code>“），然后你告诉我这东西不是 PWA？</p><p>本来确实想支持 PWA 的，想到除了要 <code>manifest.json</code>，还要搞定对应生成 <code>service worker</code>，使用不是很友好，所以取消计划。这部分添加功能就是一个尝试的甜点，所以也没有拿出来说。目前 3.x 开启 <code>pjax</code> 然后添加到桌面，阅读体验还是挺好的。</p><p>所以这次打算讲讲「苹果式网页应用安装」，其实挺简单的。<br><a id="more"></a></p><h3 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h3><p>这里没有列出所有关于 safari 支持的 meta，只针对这个功能部分。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-touch-fullscreen"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-capable"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-title"</span> <span class="attr">content</span>=<span class="string">"Colmugx's Blog"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-status-bar-style"</span> <span class="attr">content</span>=<span class="string">"default"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon"</span>  <span class="attr">sizes</span>=<span class="string">"72x72"</span>  <span class="attr">href</span>=<span class="string">"icon.ico"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon-precomposed"</span>  <span class="attr">sizes</span>=<span class="string">"72x72"</span>  <span class="attr">href</span>=<span class="string">"icon.ico"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-startup-image"</span> <span class="attr">media</span>=<span class="string">"(device-width: 375px)"</span> <span class="attr">href</span>=<span class="string">"apple-launch-1125x2436.png"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-startup-image"</span> <span class="attr">media</span>=<span class="string">"(orientation: landscape)"</span> <span class="attr">href</span>=<span class="string">"apple-touch-startup-image-2048x1496.png"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>从上到下分别是：</p><ul><li>添加到主屏幕后，是否全屏显示</li><li>是否显示 safari 菜单</li><li>应用默认名称（在添加的时候可以修改）</li><li>打开时，顶上状态栏应该呈现什么颜色（白色，黑色，透明）</li><li>设置 icon (72x72, 114x114)，图标在「书签」也可适用</li><li>设置启动画面（这里只设置了手机与平板横置）</li></ul><h3 id="apple-touch-startup-image"><a href="#apple-touch-startup-image" class="headerlink" title="apple-touch-startup-image"></a>apple-touch-startup-image</h3><p>其他的没什么坑点，只是<code>apple-touch-startup-image</code>会复杂一些。它分成很多分辨率，设置不清楚的话就不会显示。而且它不能像图标一样设置<code>size</code>。只能用<code>media</code>一行一行写。</p><p>比如 iPad，设置倒是不需要跟手机一样那么多图片，只需要准备一张垂直一张水平。垂直 <code>768x1024</code>，水平<code>748x1024</code>，水平图也需要摆成垂直的，也就是<code>1024x748</code>，当然内容也是横直，相当于顺时针 90°。接着就考虑一下屏幕用的是二倍图还是三倍图了。</p><p>参考文章：<a href="https://medium.com/appscope/adding-custom-ios-splash-screens-to-your-progressive-web-app-41a9b18bdca3" target="_blank" rel="noopener">Adding Custom iOS Splash Screens To Your Progressive Web App</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实这个功能早在 2.x 版本就加入了，那时候对 PWA 并没有什么概念。&lt;del&gt;好想换 iPad Mini (new)&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/Image/nlvi-ios-desktop.gif&quot; alt=&quot;nlvi-ios-desktop&quot;&gt;&lt;/p&gt;
&lt;p&gt;目前 3.x 只改了启动图，适配了 iPad 横屏和 iPhone 全面屏（普通屏和plus后续加）。之前看到苹果对 PWA 持拒绝态度我是震惊的，你 tm 早就给 safari 加入了这个功能，也有相关&lt;code&gt;meta&lt;/code&gt;配置（包括”识别为&lt;code&gt;WebApp&lt;/code&gt;“），然后你告诉我这东西不是 PWA？&lt;/p&gt;
&lt;p&gt;本来确实想支持 PWA 的，想到除了要 &lt;code&gt;manifest.json&lt;/code&gt;，还要搞定对应生成 &lt;code&gt;service worker&lt;/code&gt;，使用不是很友好，所以取消计划。这部分添加功能就是一个尝试的甜点，所以也没有拿出来说。目前 3.x 开启 &lt;code&gt;pjax&lt;/code&gt; 然后添加到桌面，阅读体验还是挺好的。&lt;/p&gt;
&lt;p&gt;所以这次打算讲讲「苹果式网页应用安装」，其实挺简单的。&lt;br&gt;
    
    </summary>
    
      <category term="实践尝试" scheme="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="nlvi" scheme="https://colmugx.github.io/blog/tags/nlvi/"/>
    
  </entry>
  
  <entry>
    <title>我今天给 let 安排了</title>
    <link href="https://colmugx.github.io/blog/2019/03/27/you-dont-know-let/"/>
    <id>https://colmugx.github.io/blog/2019/03/27/you-dont-know-let/</id>
    <published>2019-03-27T10:13:29.000Z</published>
    <updated>2019-04-08T09:02:18.111Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Round-1"><a href="#Round-1" class="headerlink" title="Round 1"></a>Round 1</h4><blockquote><p>- 我现在把所有东西都注释掉，改成这样<br>function a() {<br>  return inner;<br>  let inner;<br>}<br>返回什么？</p><p>- 那就应该 undefined 了，反正后面不执行</p></blockquote><p>自信的不行，出了门掏出全世界最牛逼的千元机<strong>坚果 Pro 2S</strong>，验证了一下。</p><blockquote><p>inner is not defined</p></blockquote><p>确实是不执行，但好像不是 <code>undefined</code> 啊╭(*ﾟДﾟ*)╮</p><h4 id="Round-2"><a href="#Round-2" class="headerlink" title="Round 2"></a>Round 2</h4><blockquote><p>- 如果改成这样呢<br>function a() {<br>  function inner() {}<br>  return inner;<br>  let inner;<br>}<br>返回什么？</p><p>- 返回方法</p></blockquote><p>自信的不行，同样用全世界最牛逼的千元机<strong>坚果 Pro 2S</strong>，验证了一下。</p><blockquote><p>Identifier ‘inner’ has already been declared</p></blockquote><p>(ﾟДﾟ≡ﾟдﾟ)!? 你在返回你🐴呢？<br><a id="more"></a></p><h3 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h3><p>原本我以为只有 <code>var</code> 会变量提升，实际上错了，<code>var/let/const</code>都会。</p><p><code>var</code> 和 <code>let</code> 在某种时候是相似的，他们都会提升，但 <code>let</code> 少了初始化的过程。MDN 对 <code>let</code> 死区是这么解释的</p><blockquote><p>在 ECMAScript 2015 中，let 绑定不受变量提升的约束，这意味着 let  声明不会被提升到当前执行上下文的顶部。在块中的变量初始化之前，引用它将会导致 ReferenceError（而使用 var 声明变量则恰恰相反，该变量的值是 undefined ）。这个变量处于从块开始到 let 初始化处理的”暂存死区“之中。 —— MDN</p></blockquote><p>暂存死区又有这么个说法，用一个代码块解释一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  a = <span class="string">'caonima'</span> <span class="comment">// 下面有 let，a 直接被该块锁定，这里报错</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> a <span class="comment">// 到这里才完成初始化，变量开始正常使用，但变量早已提升</span></span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// 这里不是 caonima 而是 undefined</span></span><br><span class="line"></span><br><span class="line">  a = <span class="string">'woshinidie'</span></span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// woshinidie</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/getify/You-Dont-Know-JS/issues/767" target="_blank" rel="noopener">You-Dont-Know-JS#767</a> 讨论了这个问题, creeperyang 总结了四点</p><blockquote><ol><li>Hoisting includes both declare and initialize.</li><li>Only initialized variable can be used in a scope.</li><li>var do both declare and initialize, the two cannot be split for var.</li><li>let do firstly declare in the top of the scope, and do initialize when encounter the let xxx statements.<br>—— @creeperyang</li></ol></blockquote><p>另外，方应杭在知乎专栏的文章<a href="https://zhuanlan.zhihu.com/p/28140450" target="_blank" rel="noopener">《我用了两个月的时间才理解 let》</a>也总结出</p><blockquote><ol><li>let 的「创建」过程被提升了，但是初始化没有提升。</li><li>var 的「创建」和「初始化」都被提升了。</li><li>function 的「创建」「初始化」和「赋值」都被提升了。<br>—— <a href="https://www.zhihu.com/people/zhihusucks" target="_blank" rel="noopener">@方应杭</a></li></ol></blockquote><p>理论上 <code>const</code> 应该是 <code>let</code> 的不可修改版本，所以应该是类似的。但也仅限提升原理相同，因为 <code>const</code> 只能初始化时赋值一次。</p><p>不过，阮一峰的《ECMAScript 6 入门》是什么意思？在 let 有单独一小节讲 <a href="http://es6.ruanyifeng.com/#docs/let#%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87" target="_blank" rel="noopener">不存在变量提升</a>，虽然后面解释了暂时性死区，但……</p><p>总结：被安排明白了。根据 @Ahonn 所说，这个问题在高程有讲过，书读少了读少了</p><p>（最后感谢所有被引用的文章和作者，谢谢。）</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Round-1&quot;&gt;&lt;a href=&quot;#Round-1&quot; class=&quot;headerlink&quot; title=&quot;Round 1&quot;&gt;&lt;/a&gt;Round 1&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;- 我现在把所有东西都注释掉，改成这样&lt;br&gt;function a() {&lt;br&gt;  return inner;&lt;br&gt;  let inner;&lt;br&gt;}&lt;br&gt;返回什么？&lt;/p&gt;
&lt;p&gt;- 那就应该 undefined 了，反正后面不执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自信的不行，出了门掏出全世界最牛逼的千元机&lt;strong&gt;坚果 Pro 2S&lt;/strong&gt;，验证了一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;inner is not defined&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;确实是不执行，但好像不是 &lt;code&gt;undefined&lt;/code&gt; 啊╭(*ﾟДﾟ*)╮&lt;/p&gt;
&lt;h4 id=&quot;Round-2&quot;&gt;&lt;a href=&quot;#Round-2&quot; class=&quot;headerlink&quot; title=&quot;Round 2&quot;&gt;&lt;/a&gt;Round 2&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;- 如果改成这样呢&lt;br&gt;function a() {&lt;br&gt;  function inner() {}&lt;br&gt;  return inner;&lt;br&gt;  let inner;&lt;br&gt;}&lt;br&gt;返回什么？&lt;/p&gt;
&lt;p&gt;- 返回方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自信的不行，同样用全世界最牛逼的千元机&lt;strong&gt;坚果 Pro 2S&lt;/strong&gt;，验证了一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Identifier ‘inner’ has already been declared&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(ﾟДﾟ≡ﾟдﾟ)!? 你在返回你🐴呢？&lt;br&gt;
    
    </summary>
    
      <category term="编程议论" scheme="https://colmugx.github.io/blog/categories/%E7%BC%96%E7%A8%8B%E8%AE%AE%E8%AE%BA/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>最后的 Nlvi</title>
    <link href="https://colmugx.github.io/blog/2019/03/25/bye-nlvi/"/>
    <id>https://colmugx.github.io/blog/2019/03/25/bye-nlvi/</id>
    <published>2019-03-25T06:34:53.000Z</published>
    <updated>2019-07-27T10:50:00.785Z</updated>
    
    <content type="html"><![CDATA[<p><code>Nlvi</code> 可以说起源于正准备上班和刚上班工作不饱和(大雾。为了练习自己对语义化 HTML 理解和 CSS 的渐进式学习而诞生的，到现在已经 2 年了。</p><p>那个时候还用 iPad 画草图然后慢慢写起来，而且当时编程能力确实还挺弱，hexo 很多都弄不清楚。现在对 hexo 就熟悉很多了，设计稿也从随便画画变成了用 sketch，但也是杀鸡用牛刀。</p><p>过程中也是各种骚想法，比如用 Vue/React 改写啊；脱离 jQuery 啊；用 pjax 啊；用更复杂的动画啊……不过我现在想的是：新版本(我博客正在用的半成品)做完之后，就不想迭代了。</p><p>为什么？因为一旦工作太忙没时间，又想到这个东西，好累啊……</p><p>但，我的意思是，<strong>我不想维护 hexo 版本的 Nlvi 了</strong>，我的意思是，诶嘿嘿嘿嘿嘿！<br><a id="more"></a></p><p>所以 2.0 到 3.0 大概的改动会是：</p><ul><li>根据我对统一风格的想法，(又)变动部分设计风格</li><li>根据我对统一风格的想法，调整部分部件展示形式</li><li>根据我对统一风格的想法，对颜色变量重新管理</li><li>去掉以前的标签云，重写一个</li><li>去掉以前的搜索框，重写一个</li><li>变动部分不成熟动画，改动动画曲线</li><li><strong>加入渐变色的设定！(Maybe)</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Nlvi&lt;/code&gt; 可以说起源于正准备上班和刚上班工作不饱和(大雾。为了练习自己对语义化 HTML 理解和 CSS 的渐进式学习而诞生的，到现在已经 2 年了。&lt;/p&gt;
&lt;p&gt;那个时候还用 iPad 画草图然后慢慢写起来，而且当时编程能力确实还挺弱，hexo 很多都弄不清楚。现在对 hexo 就熟悉很多了，设计稿也从随便画画变成了用 sketch，但也是杀鸡用牛刀。&lt;/p&gt;
&lt;p&gt;过程中也是各种骚想法，比如用 Vue/React 改写啊；脱离 jQuery 啊；用 pjax 啊；用更复杂的动画啊……不过我现在想的是：新版本(我博客正在用的半成品)做完之后，就不想迭代了。&lt;/p&gt;
&lt;p&gt;为什么？因为一旦工作太忙没时间，又想到这个东西，好累啊……&lt;/p&gt;
&lt;p&gt;但，我的意思是，&lt;strong&gt;我不想维护 hexo 版本的 Nlvi 了&lt;/strong&gt;，我的意思是，诶嘿嘿嘿嘿嘿！&lt;br&gt;
    
    </summary>
    
      <category term="日常吐槽" scheme="https://colmugx.github.io/blog/categories/%E6%97%A5%E5%B8%B8%E5%90%90%E6%A7%BD/"/>
    
    
      <category term="nlvi" scheme="https://colmugx.github.io/blog/tags/nlvi/"/>
    
      <category term="colmugx" scheme="https://colmugx.github.io/blog/tags/colmugx/"/>
    
  </entry>
  
  <entry>
    <title>做不完的题目</title>
    <link href="https://colmugx.github.io/blog/2019/03/23/last-test-questions/"/>
    <id>https://colmugx.github.io/blog/2019/03/23/last-test-questions/</id>
    <published>2019-03-23T06:00:50.000Z</published>
    <updated>2019-03-26T15:48:18.322Z</updated>
    
    <content type="html"><![CDATA[<p>又在「杂乱的工作台上」完成文章……</p><p>没错又错过一个非常好的机会。与其说是因为时间不够做不完，还不如说是因为陷入斐波那契思考导致做不完。</p><p>不留遗憾，把它搞完。题源就不说了。<br><a id="more"></a></p><h3 id="1-现有-a-b-c-d-四个接口，找出最快的那个。异步用-setTimeout-模拟"><a href="#1-现有-a-b-c-d-四个接口，找出最快的那个。异步用-setTimeout-模拟" class="headerlink" title="1. 现有 /a, /b, /c, /d 四个接口，找出最快的那个。异步用 setTimeout 模拟"></a>1. 现有 /a, /b, /c, /d 四个接口，找出最快的那个。异步用 setTimeout 模拟</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requests: <span class="built_in">Promise</span>&lt;<span class="built_in">string</span>&gt;[]</span><br><span class="line">  = [<span class="string">'/a'</span>, <span class="string">'/b'</span>, <span class="string">'/c'</span>, <span class="string">'/d'</span>]</span><br><span class="line">  .map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">1000</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">`<span class="subst">$&#123;v&#125;</span> spent <span class="subst">$&#123;time&#125;</span>`</span>)</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race(requests).then(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又在「杂乱的工作台上」完成文章……&lt;/p&gt;
&lt;p&gt;没错又错过一个非常好的机会。与其说是因为时间不够做不完，还不如说是因为陷入斐波那契思考导致做不完。&lt;/p&gt;
&lt;p&gt;不留遗憾，把它搞完。题源就不说了。&lt;br&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="TypeScript" scheme="https://colmugx.github.io/blog/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Redux —— combineReducers</title>
    <link href="https://colmugx.github.io/blog/2019/03/08/redux-combinereducers/"/>
    <id>https://colmugx.github.io/blog/2019/03/08/redux-combinereducers/</id>
    <published>2019-03-08T06:49:12.000Z</published>
    <updated>2019-04-28T16:09:00.378Z</updated>
    
    <content type="html"><![CDATA[<p>事出有因，写 <code>rabbit</code> 的时候，一条单测出了问题</p><blockquote><p>Reducer _object returned undefined during initialization.</p></blockquote><p>想来必然是 <code>reducer</code> 缺少默认的 <code>state</code> 所致，<del>但是我的单测是从 <code>dva</code> 直接拿过来改改就用的，应该不会出现问题，所以一定是哪里出了差错。后面发现了，虽然 <code>dva</code> 可以接受 <code>reducers</code> 是空对象，但应用运行起来有一样问题。</del></p><p>主要是这个问题无伤大雅，<code>model</code> 不会出现只有 <code>reducers</code> 这种情况。我也给出了解决：构建 <code>reducer</code> 给一个默认 <code>state</code> 顶着（但我认为一个 <code>model</code> 应该强制存在 <code>state</code>）</p><p>显然这次并不想讲这个，而是想理解 <code>combineReducers</code><br><a id="more"></a><br><code>combineReducers</code> 一共有 4 个方法：</p><ul><li><code>getUndefinedStateErrorMessage</code></li><li><code>getUnexpectedStateShapeWarningMessage</code></li><li><code>assertReducerShape</code></li><li>(主要方法) <code>combineReducers</code></li></ul><h3 id="getUndefinedStateErrorMessage"><a href="#getUndefinedStateErrorMessage" class="headerlink" title="getUndefinedStateErrorMessage"></a>getUndefinedStateErrorMessage</h3><p>很明显，这是一个生成错误信息的方法。主要是限制 <code>reducer</code> 必须返回 <code>state</code></p><h3 id="assertReducerShape"><a href="#assertReducerShape" class="headerlink" title="assertReducerShape"></a>assertReducerShape</h3><p>这是一个检查 <code>reducer</code> 是否合规的方法。</p><p>首先接受一个集合所有 <code>reducer</code> 的对象进行遍历，每一个抽出来检验，做一次运行尝试，看是否能得到 <code>state</code>。如果得到的 <code>state</code> 为  <code>undefined</code> 则该 <code>reducer</code> 是非法的。</p><p>文中开头提到的问题正是由这里报出，因为我们给出的 <code>reducers</code> 为空对象，且 <code>state</code> 为 <code>undefined</code>，所以自然会报错。<code>dva</code> 的单测只检查 <code>model</code> 的合理性，且 <code>state</code> 允许任何内容和 <code>reducers</code> 允许空对象，并没有考虑一个 <code>model</code> 同时不存在这两者的情况，不过显然没意义，所以目前是不清楚 <code>dva</code> 团队是没想到还是也觉得无所谓。</p><h3 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h3><p>这是这组方法中的核心，该方法也作为默认方法导出。这组方法的目的是把一群 <code>reducer</code> 合并为一个方法供 <code>createStore</code> 使用。</p><p>上来是两组变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提取对象中所有字段名，一个 key 对应一个 reducer 方法</span></span><br><span class="line"><span class="keyword">const</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers)</span><br><span class="line"><span class="comment">// 由下面可得，该变量用来暂存基本合理（reducer 是一个方法）的 reducer 方法。</span></span><br><span class="line"><span class="keyword">const</span> finalReducers = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">'function'</span>) &#123;</span><br><span class="line">  finalReducers[key] = reducers[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果在非生产环境中，还会提示仅有 key 没有方法的值以方便我们修改调试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再把初步验证过的 reducer 取出</span></span><br><span class="line"><span class="keyword">const</span> finalReducerKeys = <span class="built_in">Object</span>.keys(finalReducers)</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> shapeAssertionError</span><br><span class="line"><span class="comment">// 放入刚刚用来验证 reducer 合规的方法进行第二次验证，并做错误处理</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  assertReducerShape(finalReducers)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  shapeAssertionError = e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是返回一个新的 <code>reducer</code>，并对所有传入的合规的 <code>reducer</code> 进行 diff。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个对比记录变量以及新 state</span></span><br><span class="line"><span class="keyword">let</span> hasChanged = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> nextState = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历刚刚验证完的 reducer key 数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> key = finalReducerKeys[i]</span><br><span class="line">  <span class="keyword">const</span> reducer = finalReducers[key]</span><br><span class="line">  <span class="comment">// 获取当前 state</span></span><br><span class="line">  <span class="keyword">const</span> previousStateForKey = state[key]</span><br><span class="line">  <span class="comment">// 通过执行 reducer 得到新的 state</span></span><br><span class="line">  <span class="keyword">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> nextStateForKey === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> errorMessage = getUndefinedStateErrorMessage(key, action)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(errorMessage)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 并将新 reducer 产物绑定到 nextState，key 不变。（方便对比）</span></span><br><span class="line">  nextState[key] = nextStateForKey</span><br><span class="line">  <span class="comment">// 右式第一个 hasChanged 表达：如果已经为 true 那么就肯定 true，没必要再去对比验证</span></span><br><span class="line">  hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回：有改变的返回新的，无改变返回原 state。</span></span><br><span class="line"><span class="keyword">return</span> hasChanged ? nextState : state</span><br></pre></td></tr></table></figure><p>所以这组方法目的就是把所有复杂的 <code>reducer</code> 和 <code>state</code> 组成新的状态树，统一管理。业务开发时可以根据需求拆分多个 <code>reducer</code> 和 <code>state</code>，便于开发和组织。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事出有因，写 &lt;code&gt;rabbit&lt;/code&gt; 的时候，一条单测出了问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Reducer _object returned undefined during initialization.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想来必然是 &lt;code&gt;reducer&lt;/code&gt; 缺少默认的 &lt;code&gt;state&lt;/code&gt; 所致，&lt;del&gt;但是我的单测是从 &lt;code&gt;dva&lt;/code&gt; 直接拿过来改改就用的，应该不会出现问题，所以一定是哪里出了差错。后面发现了，虽然 &lt;code&gt;dva&lt;/code&gt; 可以接受 &lt;code&gt;reducers&lt;/code&gt; 是空对象，但应用运行起来有一样问题。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;主要是这个问题无伤大雅，&lt;code&gt;model&lt;/code&gt; 不会出现只有 &lt;code&gt;reducers&lt;/code&gt; 这种情况。我也给出了解决：构建 &lt;code&gt;reducer&lt;/code&gt; 给一个默认 &lt;code&gt;state&lt;/code&gt; 顶着（但我认为一个 &lt;code&gt;model&lt;/code&gt; 应该强制存在 &lt;code&gt;state&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;显然这次并不想讲这个，而是想理解 &lt;code&gt;combineReducers&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="Redux" scheme="https://colmugx.github.io/blog/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>看过 Redux 之后，我写了一个不负责任的状态管理</title>
    <link href="https://colmugx.github.io/blog/2019/03/02/about-redux/"/>
    <id>https://colmugx.github.io/blog/2019/03/02/about-redux/</id>
    <published>2019-03-02T10:00:19.000Z</published>
    <updated>2019-03-25T06:39:45.803Z</updated>
    
    <content type="html"><![CDATA[<p>我们现在小程序需要使用状态管理，但因为项目体量实在很小又没必要使用 redux 或者 mobx。所以我打算不负责任的写一个。</p><h3 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h3><p>Redux 最核心的部分，提供基础的功能。<code>createStore</code>接受三个参数：<code>reducer</code>, <code>initialState</code>, <code>enhancer</code>。前两个比较好理解，<code>enhancer</code>主要用在接受中间件中。返回产物我们主要使用三个方法：<code>getState</code>, <code>dispatch</code>, <code>subscribe</code>。</p><ul><li><code>getState</code>：获取当前 state 值</li><li><code>subscribe</code>：接受监听，存入 <code>listeners</code> 池中</li><li><code>dispatch</code>：处理 <code>reducer</code> 操作，触发 <code>listeners</code> 方法<a id="more"></a>所有我们需要的东西都了解清楚了，其他的功能和边缘保护先不考虑，这也是为什么说是不负责任的状态管理(逃</li></ul><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">store</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currentState = state || &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> listeners = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; getState, dispatch, subscribe &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentState</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line">    listeners.push(listener)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    action.call(<span class="keyword">this</span>, currentState)</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">f</span> =&gt;</span> f.call(<span class="literal">null</span>))</span><br><span class="line">    <span class="keyword">return</span> currentState</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里修改了一些：订阅没有返回取消订阅操作。原因是懒。。<code>dispatch</code> 并不是接受一个纯函数进行数据更新，而是直接由业务修改状态然后通知更新，所以这其实不能算是一个 redux 产物，并且这很不可控。所以这更像是为了利用<code>react-redux</code>或者<code>taro-redux</code>而产生的一种状态保存方式。</p><p>原因还是业务比较简单，就是为了存几个不是很关键的数据但不想使用小程序的 <code>storage</code> 去管理而产生的方法。现在不仅满足业务，压缩后也只有 <code>270b</code> 左右，省点空间给小程序代码，有点赚的实际上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们现在小程序需要使用状态管理，但因为项目体量实在很小又没必要使用 redux 或者 mobx。所以我打算不负责任的写一个。&lt;/p&gt;
&lt;h3 id=&quot;createStore&quot;&gt;&lt;a href=&quot;#createStore&quot; class=&quot;headerlink&quot; title=&quot;createStore&quot;&gt;&lt;/a&gt;createStore&lt;/h3&gt;&lt;p&gt;Redux 最核心的部分，提供基础的功能。&lt;code&gt;createStore&lt;/code&gt;接受三个参数：&lt;code&gt;reducer&lt;/code&gt;, &lt;code&gt;initialState&lt;/code&gt;, &lt;code&gt;enhancer&lt;/code&gt;。前两个比较好理解，&lt;code&gt;enhancer&lt;/code&gt;主要用在接受中间件中。返回产物我们主要使用三个方法：&lt;code&gt;getState&lt;/code&gt;, &lt;code&gt;dispatch&lt;/code&gt;, &lt;code&gt;subscribe&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getState&lt;/code&gt;：获取当前 state 值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;subscribe&lt;/code&gt;：接受监听，存入 &lt;code&gt;listeners&lt;/code&gt; 池中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dispatch&lt;/code&gt;：处理 &lt;code&gt;reducer&lt;/code&gt; 操作，触发 &lt;code&gt;listeners&lt;/code&gt; 方法
    
    </summary>
    
      <category term="实践尝试" scheme="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>一位赌狗前端的自我修养</title>
    <link href="https://colmugx.github.io/blog/2018/11/19/gamble-fn/"/>
    <id>https://colmugx.github.io/blog/2018/11/19/gamble-fn/</id>
    <published>2018-11-19T09:57:59.000Z</published>
    <updated>2018-11-20T07:14:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>这两个月工作巨多，直到今天才有时间写点骚东西。</p><p>可是要写点什么比较好呢？这时候看到了隔壁桌面上放着一张福彩，我脑子里有画面了。（所以这位赌狗不是我，我不买彩票）</p><p>为了方便以后支持更多的彩票，直接搞个类</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Gamble &#123;</span><br><span class="line">    <span class="keyword">static</span> dualColor(red: <span class="built_in">number</span> = <span class="number">6</span>, blue: <span class="built_in">number</span> = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> reds: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">1</span>, <span class="number">33</span>];</span><br><span class="line">        <span class="keyword">const</span> blues: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">1</span>, <span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">this</span>.randomVal(reds, red), <span class="keyword">this</span>.randomVal(blues, blue)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> randomVal(</span><br><span class="line">        fromto: <span class="built_in">number</span>[],</span><br><span class="line">        total: <span class="built_in">number</span>,</span><br><span class="line">        temp: <span class="built_in">number</span>[] = [],</span><br><span class="line">    ): <span class="built_in">number</span>[] &#123;</span><br><span class="line">        <span class="keyword">const</span> [head, ...body] = (!temp.length</span><br><span class="line">            ? [...Array(fromto[<span class="number">1</span>]).keys()]</span><br><span class="line">                  .map(<span class="function"><span class="params">item</span> =&gt;</span> item + <span class="number">1</span>)</span><br><span class="line">                  .splice(fromto[<span class="number">0</span>] - <span class="number">1</span>)</span><br><span class="line">            : fromto</span><br><span class="line">        ).sort(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">return</span> !total</span><br><span class="line">            ? temp</span><br><span class="line">            : <span class="keyword">this</span>.randomVal(body, total - <span class="number">1</span>, temp.concat(head));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两个月工作巨多，直到今天才有时间写点骚东西。&lt;/p&gt;
&lt;p&gt;可是要写点什么比较好呢？这时候看到了隔壁桌面上放着一张福彩，我脑子里有画面了。（所以这位赌狗不是我，我不买彩票）&lt;/p&gt;
&lt;p&gt;为了方便以后支持更多的彩票，直接搞个类&lt;/p&gt;
&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="曲苑杂坛" scheme="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/"/>
    
    
      <category term="TypeScript" scheme="https://colmugx.github.io/blog/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>记在NPM抢空包名的经历</title>
    <link href="https://colmugx.github.io/blog/2018/07/12/kill-parentless-on-npm/"/>
    <id>https://colmugx.github.io/blog/2018/07/12/kill-parentless-on-npm/</id>
    <published>2018-07-12T07:10:23.000Z</published>
    <updated>2019-03-22T16:07:34.681Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>强烈谴责某些大厂，前端或者说 JavaScript 是一个极其依赖社区环境的语言，你们在招人之前能不能先调查一下准新人有没有在社区为非作歹？</p></blockquote><p>年前想搞定<code>React</code>的时候想了个骚操作：尝试用<code>React</code>的思路去做<code>Vue</code>的事情。又诞生了「Vue生态统一可以聚合」的骚想法，开始产生做<code>Ahri</code>的念头。想着那得搞个 npm 包吧，孤儿上线了。</p><p>嘛，在 npm 拿《英雄联盟》英雄名字抢注包名的做法都很弱智了，还“大义凛然”的在描述里写着：<code>League of Legends hero.</code></p><p>关于第一次遇到它的时候，我就想算了，重新找合适的名字吧，但后来因为其他原因就搁置了。现在重新回坑，依然遇到这个问题，这次我不忍了，我打算找 npm 肛他！</p><a id="more"></a><h3 id="寻找入口"><a href="#寻找入口" class="headerlink" title="寻找入口"></a>寻找入口</h3><p>首先看了<code>profile</code>页，发现没有举报入口。（从这里进了Twitter，让人感觉这是一个为了装逼而活着的人。</p><p>看看 npm 本身页面有没有什么入口，比如“联系我们”之类的邮箱总有吧，最后在最下面找到了<code>Reporting Abuse</code>。</p><p>不得不说 npm 连“因为名字打起来”的可能都想到了，那“因为孤儿操作”应该也会列入其中吧，果不其然。在骚扰举报一栏找到了控空包的情况：如果有用户注册无用空包，或者利用包进行乱七八糟的活动，可能有两种措施：ban 了这个用户；清除这些东西。</p><p>我一看到可以 ban 了他我就可兴奋了，于是，发邮件走起。</p><h3 id="采取行动"><a href="#采取行动" class="headerlink" title="采取行动"></a>采取行动</h3><p>操起我400分的4级水平英语，就开始写。</p><blockquote><p>hi,<br>here a profile page: xxxxxx.</p><p>this account keep a lot of empty packages which name as a role name in a game, it cause difficulty for me.</p><p>I NEED HELP! THANK YOU!</p></blockquote><p>过了一会收到回信：</p><blockquote><p>Our support hours are Monday through Friday, 9:00AM - 6:00PM PST, excluding US holidays.</p><p>Your request is being reviewed by our support staff and we’ll be responding soon.</p><p>To add additional comments, reply to this email.</p></blockquote><p>噢，没在工作时间还行。过了几秒又收到一封邮件：</p><blockquote><p>Hey there,</p><p>Thank you for reaching out. We hope you’re having a great week thus far, and are looking forward to responding to your request.</p><p>The npm support staff will be off on Wednesday, July 4th in observance of Independence Day. Due to this, you may experience some delay in expected reply times.</p><p>Thanks for your patience.</p></blockquote><p>狗屎还带放假的？美国员工真的舒服啊，不加班，节假日放满。像我们这种997节假日还放不满的简直受到了6把无尽的暴击。</p><p>等了几天发现不对，没理我，再按照第一封发了一次，这次过了半天多才回。这次差点就怕我气到了，大概的意思就是你上次的 ticket 还没解决，如果你没问题了我们就关了。。。美国人上班都这么摸的？</p><p>又过了半天收到一封邮件，这次是技术客服（邮件是有人名的大佬）发来的：</p><blockquote><p>Thanks for reaching out.</p><p>I was not able to find an account associated with (我发信的邮箱). Was there a specific one of these user’s package names you are interested in for a project?</p><p>If so, we may assist you with a transfer request or granting access to that package, depending on the package and contents.</p></blockquote><p>有点着急，看了第一句之后，下面没仔细看，就有点想搞他，我就回信了。信的内容大概是这样：谢谢你的回复。这是我的项目名字（发了<code>Ahri</code>的GitHub Repo），这是我的 npm 账号（意识到发信的账号不对）。我对<code>Ahri</code>有兴趣，但他是个空的而且被占用了，我没办法使用，对吧？还有这个 B 恶意占用了大量的空包（跟上孤儿账号），他是不是同时违反了规则，是不是应该有所动作？</p><p>第二天（有时差），收到了回信，说包名已经转移到我的账号上：</p><blockquote><p>Thanks for getting back to me with that information.</p><p>It’s all yours now, but you won’t be able to re-use any version numbers used by the previous author. In fact, I’d suggest publishing your first update as a major release, i.e., v1.0.0. Please publish an update to the package as soon as possible with your code.</p></blockquote><p>我上了我的 npm 看了一眼，惊了..这就拿到了..</p><p>但并没有解放其他的空包和 <strong>ban 了他</strong>，这点我有点失望。总之，要到想要的包，这才是想要的结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;强烈谴责某些大厂，前端或者说 JavaScript 是一个极其依赖社区环境的语言，你们在招人之前能不能先调查一下准新人有没有在社区为非作歹？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;年前想搞定&lt;code&gt;React&lt;/code&gt;的时候想了个骚操作：尝试用&lt;code&gt;React&lt;/code&gt;的思路去做&lt;code&gt;Vue&lt;/code&gt;的事情。又诞生了「Vue生态统一可以聚合」的骚想法，开始产生做&lt;code&gt;Ahri&lt;/code&gt;的念头。想着那得搞个 npm 包吧，孤儿上线了。&lt;/p&gt;
&lt;p&gt;嘛，在 npm 拿《英雄联盟》英雄名字抢注包名的做法都很弱智了，还“大义凛然”的在描述里写着：&lt;code&gt;League of Legends hero.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;关于第一次遇到它的时候，我就想算了，重新找合适的名字吧，但后来因为其他原因就搁置了。现在重新回坑，依然遇到这个问题，这次我不忍了，我打算找 npm 肛他！&lt;/p&gt;
    
    </summary>
    
      <category term="曲苑杂坛" scheme="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/"/>
    
    
      <category term="colmugx" scheme="https://colmugx.github.io/blog/tags/colmugx/"/>
    
  </entry>
  
  <entry>
    <title>我就写个方法，这么麻烦？</title>
    <link href="https://colmugx.github.io/blog/2018/07/04/different-function/"/>
    <id>https://colmugx.github.io/blog/2018/07/04/different-function/</id>
    <published>2018-07-04T07:06:43.000Z</published>
    <updated>2019-03-22T16:07:34.681Z</updated>
    
    <content type="html"><![CDATA[<p>最近想到一个问题：为什么JavaScript定义一个函数有那么多种形式，是历史残留还是为了装逼？研究了一下发现还是有区别的。</p><p>JavaScript中定义一个方法主要可以分成两种形式：</p><ul><li>函数声明</li><li>函数表达式</li></ul><a id="more"></a><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>声明体是最普通的，其他语言也相近的一种方式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>不过，毕竟是「函数就是爸爸」的JavaScript！它有一个特性：函数提升。</p><blockquote><p>函数提升：把所有函数提升到当前作用域上，从而做到了可以“未声明先调用”。</p></blockquote><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>这可能是目前用的最多的声明方式，因为可以搭配箭头函数假装自己用的是函数式编程。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数版本</span></span><br><span class="line"><span class="keyword">const</span> funcA = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>但变量受作用域影响，所以<code>const</code>和<code>let</code>并没有变量提升的能力。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">funcA(<span class="number">1</span>) <span class="comment">// ReferenceError: funcA is not defined</span></span><br><span class="line"><span class="keyword">const</span> funcA = <span class="function"><span class="params">a</span> =&gt;</span> a</span><br></pre></td></tr></table></figure></p><p>燃鹅，这才刚刚开始……</p><h3 id="匿名-amp-具名"><a href="#匿名-amp-具名" class="headerlink" title="匿名 &amp; 具名"></a>匿名 &amp; 具名</h3><p>匿名就是上面那种，具名就是给函数本体再起一个名字。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="keyword">function</span> <span class="title">funcName</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>这样有什么区别？后面那个名字又不能用！答案还是有区别的。</p><p>首先有一个函数名推断，比如上面这个函数，那么<code>func.name</code>会返回<code>funcName</code>。如果匿名函数的话<code>[fn].name</code>会返回<code>&#39;&#39;</code>。其次这个名字可以在函数内部使用。当然了指代的就是自己了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="keyword">function</span> <span class="title">funcName</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &lt; <span class="number">0</span> ? b : funcName(a+<span class="number">1</span>-b, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">431</span>, <span class="number">151</span>) <span class="comment">// 281</span></span><br><span class="line">funcName(<span class="number">431</span>, <span class="number">151</span>) <span class="comment">// ReferenceError: funcName is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(func.name) <span class="comment">// funcName</span></span><br><span class="line"><span class="keyword">typeof</span> funcName === <span class="string">'function'</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>所以这种方式最适合递归函数了。</p><h3 id="函数表达式依然是个常-变量"><a href="#函数表达式依然是个常-变量" class="headerlink" title="函数表达式依然是个常/变量"></a>函数表达式依然是个常/变量</h3><p>把它当做一个“方程”来看吧，关键词已经决定了这个“量”会以什么形式存在，比如<code>var</code>和<code>let</code>是变量，<code>const</code>是常量，并且<code>let</code>还有作用域范围。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> funcA = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'A'</span>)</span><br><span class="line">funcA() <span class="comment">// A</span></span><br><span class="line">funcA = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'AA'</span>) <span class="comment">// TypeError: Assignment to constant variable.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funcB = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'B'</span>)</span><br><span class="line">funcB() <span class="comment">// B</span></span><br><span class="line">funcB = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'BB'</span>)</span><br><span class="line">funcB() <span class="comment">// BB</span></span><br></pre></td></tr></table></figure></p><p>题外话：那么就有个老生常谈的问题了，函数表达式按道理来讲是“灵活的”，那么下面这个函数会是什么结果？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'B'</span>)</span><br><span class="line">&#125;</span><br><span class="line">funcB() <span class="comment">// BB</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'BB'</span>)</span><br><span class="line">&#125;</span><br><span class="line">funcB() <span class="comment">// BB</span></span><br></pre></td></tr></table></figure></p><p>为什么？还是那句话：JavaScript世界中，函数是你爹！</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>又到了大家最最喜欢的箭头函数环节，现在还有谁是不愿意写箭头函数的？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="params">a</span> =&gt;</span> <span class="function"><span class="params">b</span> =&gt;</span> a + b</span><br><span class="line">func(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>在这篇文章：<a href="/blog/2017/03/03/js-this/">《关于JavaScript的this》</a>已经被安排的明明白白了。</p><p>实际上现在看这篇文章也有点问题，年轻的时候牛批吹多了。总结箭头函数两个特点就是：</p><ul><li>不会创造上下文（自身无this）</li><li>必然是个匿名函数</li><li>没有 <code>arguments</code></li></ul><p>不是两个吗？怎么变成三个了？此时你可能会回去检查刚刚那句话，然后我现在悄悄告诉你，（第三点是送的）。</p><h3 id="计算属性函数名"><a href="#计算属性函数名" class="headerlink" title="计算属性函数名"></a>计算属性函数名</h3><p>这个应该是在“对象”的环境中存在，毕竟对象可以指代很多种只要是对象的情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;</span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'b'</span>](a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object.ab(<span class="number">1</span>, <span class="number">3</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>这就实现了“函数名可以暂时不知道是什么”的情况，通过计算来得到这个函数。</p><h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><h3 id="new-Function"><a href="#new-Function" class="headerlink" title="new Function"></a>new Function</h3><p>这是一个不知道哪里可以用得上但是就是可以用的方式：通过对象创建<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'return a + b'</span>)</span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><h3 id="函数参数初始值"><a href="#函数参数初始值" class="headerlink" title="函数参数初始值"></a>函数参数初始值</h3><p>可能有一定需求，但可能没有<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a = <span class="number">1</span>, b = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>可能我们更常用的有这些<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> funcA = <span class="function">(<span class="params">obj = &#123;&#125;</span>) =&gt;</span> obj</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> funcB = <span class="function">(<span class="params">arr = []</span>) =&gt;</span> arr</span><br></pre></td></tr></table></figure></p><p>但JavaScript毕竟是「函数是第一公民」的语言，有机会会写到很多高阶函数。所以<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function">(<span class="params">fn = (</span>) =&gt;</span> <span class="string">'💉💧🐮🍺'</span>) =&gt; fn.call(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure></p><p>凭什么函数作为参数就不能有初始值呢？当然是可以的呀！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近想到一个问题：为什么JavaScript定义一个函数有那么多种形式，是历史残留还是为了装逼？研究了一下发现还是有区别的。&lt;/p&gt;
&lt;p&gt;JavaScript中定义一个方法主要可以分成两种形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数声明&lt;/li&gt;
&lt;li&gt;函数表达式&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>关于四轴的踩坑指南</title>
    <link href="https://colmugx.github.io/blog/2018/03/12/dji-interview/"/>
    <id>https://colmugx.github.io/blog/2018/03/12/dji-interview/</id>
    <published>2018-03-12T02:39:13.000Z</published>
    <updated>2019-04-17T09:38:15.730Z</updated>
    
    <content type="html"><![CDATA[<p>怎么可能真的是四轴的踩坑指南，其实是大疆的受苦之旅。恼羞成怒下单了<code>mavic air</code>（所以dji还是赚了？）</p><p>怎么可能会让你回去还能等到通知，人家HR明明都告诉我面试入职一条龙了！算了本来就是自己的问题，能一路到看到四个大佬都是赚的。面试结束还送了架精灵还有一块工牌！（虽然是纸精灵和工牌套子。</p><p>总结一下印象深刻受苦的问题和答案，不过有一点想吐槽的…就<code>vue</code>和<code>react</code>之间的关系和选择，我看到了高一文理科分班的那种影子：人家都是哪科分高选哪科，我是选分低 + 主管臆想……<br><a id="more"></a></p><h3 id="html5-css3"><a href="#html5-css3" class="headerlink" title="html5 css3"></a>html5 css3</h3><p>css3：圆角，变形，线性渐变，阴影。后两个没答，另外阴影我一直以为是<code>css2</code>的。</p><p>html5: 算了挺多的…基本上用过的都说了一遍… 下次记得背一下（真的需要用到那么多？</p><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><h3 id="created-和-mounted-区别，ajax会在哪里操作"><a href="#created-和-mounted-区别，ajax会在哪里操作" class="headerlink" title="created 和 mounted 区别，ajax会在哪里操作"></a>created 和 mounted 区别，ajax会在哪里操作</h3><blockquote><p>放在 created，因为 mounted 的时候还没有渲染节点。</p></blockquote><p>虽然这个问题也有一些讨论，有些会在<code>created</code>就做了，有些是在<code>mounted</code>做。</p><p>有问题吗？还真有。因为我想到的是：在<code>created</code>过程把数据获取之后，从虚拟dom转为真实dom的时候可以顺便把数据带进去。而不需要一整个组件都创建完整之后再去加载数据。毕竟到<code>mounted</code>的时候实例都建立完了，这个时候再刷新数据不是会引起刷新/重绘？不过这个问题不应该是我没看源码的问题，而是有些问题没了解透彻，或者说，文章看太少。</p><p>恰好就坑这了，要的就是在<code>mounted</code>，因为这个时候已经有组件实例了，也就是<code>this.$el</code>已经有树了，如果<code>ajax</code>过来的内容是需要依赖<code>el</code>的话，那在<code>created</code>的时候还没有东西呢。</p><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue生命周期图示"></p><h3 id="深度-watcher"><a href="#深度-watcher" class="headerlink" title="深度 watcher"></a>深度 watcher</h3><p>去翻了一下文档，我发现翻车的是自己吧！<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c: &#123;</span><br><span class="line">  handler: <span class="function"><span class="keyword">function</span> (<span class="params">val, oldVal</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  deep: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>只需要给对象加个<code>deep</code>就行了,而<code>a.b</code>这种情况应不属于深度watch，这只是需要监听的数据在比较深处而已…</p><h3 id="vue-函数式组件"><a href="#vue-函数式组件" class="headerlink" title="vue 函数式组件"></a>vue 函数式组件</h3><p>这是一个补充问题，关于 什么时候可以使用函数式组件，我觉得确实没什么可以说的啊…</p><p>如果只是充当渲染任务，不需要持久化不需要状态，采用函数式组件可以减少开销。</p><p>总的来说，比较严重的问题还是出现在：表达能力有问题 + 理解框架不够深刻（但远不及原理） + 狗娘的英语表达。还有<code>css</code>过于依赖补全导致想口头表述语句的时候，单词中间那段想不起来所以说不出口导致的丢分。所以打算CSS部分关闭补全一段时间。</p><p>这属于机会完全被自己毁了（还不是技术层面问题），所以烦躁和不甘又有什么用呢…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;怎么可能真的是四轴的踩坑指南，其实是大疆的受苦之旅。恼羞成怒下单了&lt;code&gt;mavic air&lt;/code&gt;（所以dji还是赚了？）&lt;/p&gt;
&lt;p&gt;怎么可能会让你回去还能等到通知，人家HR明明都告诉我面试入职一条龙了！算了本来就是自己的问题，能一路到看到四个大佬都是赚的。面试结束还送了架精灵还有一块工牌！（虽然是纸精灵和工牌套子。&lt;/p&gt;
&lt;p&gt;总结一下印象深刻受苦的问题和答案，不过有一点想吐槽的…就&lt;code&gt;vue&lt;/code&gt;和&lt;code&gt;react&lt;/code&gt;之间的关系和选择，我看到了高一文理科分班的那种影子：人家都是哪科分高选哪科，我是选分低 + 主管臆想……&lt;br&gt;
    
    </summary>
    
      <category term="前端思考" scheme="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
      <category term="vue" scheme="https://colmugx.github.io/blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>promise链式调用</title>
    <link href="https://colmugx.github.io/blog/2018/02/28/promise-chaining/"/>
    <id>https://colmugx.github.io/blog/2018/02/28/promise-chaining/</id>
    <published>2018-02-28T02:16:22.000Z</published>
    <updated>2019-03-25T06:37:13.980Z</updated>
    
    <content type="html"><![CDATA[<p>学会了却不会活用是真的菜…</p><p>前几天面试，提到了回调地狱用<code>promise</code>，然后抛出个衍生问题：<code>promise</code>也会嵌套，怎么解决<code>promise</code>的回调地狱。</p><p>我想不到，直接问能不能用<code>ES8</code>，说行，然后我就想到了<code>const p2 = await Promise</code>这种做法。</p><p>可是，我记得我在若干天前才写了一篇关于「JS方法链式调用」。</p><blockquote><p>只要函数返回值是一个函数，就可以连着调用</p></blockquote><p>So,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1.then(<span class="function">(<span class="params">&#123; p2 &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p2</span><br><span class="line">&#125;).then(&#123; p3 &#125; =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学会了却不会活用是真的菜…&lt;/p&gt;
&lt;p&gt;前几天面试，提到了回调地狱用&lt;code&gt;promise&lt;/code&gt;，然后抛出个衍生问题：&lt;code&gt;promise&lt;/code&gt;也会嵌套，怎么解决&lt;code&gt;promise&lt;/code&gt;的回调地狱。&lt;/p&gt;
&lt;p&gt;我想不到，直接问
      
    
    </summary>
    
      <category term="曲苑杂坛" scheme="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/"/>
    
    
      <category term="JavaScript" scheme="https://colmugx.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>抛下不成熟，开始nvim</title>
    <link href="https://colmugx.github.io/blog/2018/02/13/new-life-nvim/"/>
    <id>https://colmugx.github.io/blog/2018/02/13/new-life-nvim/</id>
    <published>2018-02-13T03:02:00.000Z</published>
    <updated>2019-03-25T06:41:48.996Z</updated>
    
    <content type="html"><![CDATA[<p>想活得跟过去有些区别，活得更有效率该有的样子，而且我讨厌上一年的自己，不知道为什么会这么想。反正，放弃spacemacs开始使用vim了。</p><p>很简单，spacemacs有时候会卡一下，就像十年前的电脑，按了一长串需要等一下才会突突突突全显示出来。后来vscode + vim插件又出现了“不自觉按空格”的情况，就是写完按两下空格调插件。那既然这样的话，从零开始一个vim吧，把leader换成空格然后一些改不过来的习惯换过来就行了。</p><p>实际上，如果不是因为懒，早就该定制编辑器了。。不过我不会放弃vscode，因为还是有些残留。为什么不从零开始一个emacs？成本太高啊，又要vim模式又要改成leader键操作，而且逐渐能理解那个蚊香图是什么意思了。</p><h3 id="iterm2"><a href="#iterm2" class="headerlink" title="iterm2"></a>iterm2</h3><p>宿主用这个，原先很排斥在终端写东西（不能用鼠标），不过后来一手菜鸡操作<code>xj</code>, <code>xk</code>还有<code>wwwwwwww...</code>也能达到需求了，应该没问题了。<br><a id="more"></a><br>14px的<code>menlo nerd</code>，204x60 的<code>full-width top</code>，接近<code>40%</code>的透明度纯黑背景解决字体字符完整显示和启动时自动无边框全屏，还能看到窗后的情况。顺便把热键改成<code>cmd + return</code>（这操作懂得都懂…）</p><h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><p>oh-my-zsh一早就装了，用的<code>avit</code>主题，其他没动。对我来说<code>shell</code>就是<code>shell</code>。</p><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>从刚开始尝试MacVim到后面把这东西干掉，终端vim更新到vim8.0之后，vim一直充当着“顺手改改”的任务。这次因为要半主力编辑器，也不能全靠手打了…</p><p>对ycm印象极差，虽然deoplete支持vim8，弄了一阵子能用但是一出问题麻烦极多；找到了vim-lsp但是资源稀缺，还不会自启服务器！一气之下编译一手<code>neovim</code>，完美。毕竟我要有这脾气我就去从零开始space + emacs了（主要还可以直接抄大佬的配置）。</p><p>至于其他插件，因为还没有实战过还不知道缺哪些东西。先配好的是肯定会用上的，看情况再说。</p><p>另外求一个vim插件，vim有没有像<code>mmm-mode</code>的插件，就是同一个文件可以不同设置高亮或者补全的？用<code>mmm-mode</code>可以在同一文件同时采用<code>emmet-mode</code>和<code>js2-mode</code>，也因为这样解决我<code>vue</code>高亮补全问题…</p><p>然后就是看情况把在<code>spacemacs</code>的片段搬到<code>vim</code>了。</p><h3 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h3><p>其实<code>iterm2</code>也可以胡乱分屏，但是考虑到大佬墙裂推荐。用！</p><p>看到了<code>i3</code>的影子，配置窗口前后颜色，调整了状态栏左右宽度和配色。毕竟还不熟，随意的改成了和vim主题相近的低调配色并加上时钟（着手做电量）。不过我的终端毕竟不是全屏的，顶栏和dock还是会常驻屏幕，所以一堆东西也没什么用。对了，这一套有颜色的主题颜色都采用了<code>one</code>，atom家那个。</p><p>然后剩下的就是通过使用寻找问题了，现在第一个问题就是vim的主题怎么把背景也至少<code>30%</code>的透明，改了主题文件发现一点用都没有。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想活得跟过去有些区别，活得更有效率该有的样子，而且我讨厌上一年的自己，不知道为什么会这么想。反正，放弃spacemacs开始使用vim了。&lt;/p&gt;
&lt;p&gt;很简单，spacemacs有时候会卡一下，就像十年前的电脑，按了一长串需要等一下才会突突突突全显示出来。后来vscode + vim插件又出现了“不自觉按空格”的情况，就是写完按两下空格调插件。那既然这样的话，从零开始一个vim吧，把leader换成空格然后一些改不过来的习惯换过来就行了。&lt;/p&gt;
&lt;p&gt;实际上，如果不是因为懒，早就该定制编辑器了。。不过我不会放弃vscode，因为还是有些残留。为什么不从零开始一个emacs？成本太高啊，又要vim模式又要改成leader键操作，而且逐渐能理解那个蚊香图是什么意思了。&lt;/p&gt;
&lt;h3 id=&quot;iterm2&quot;&gt;&lt;a href=&quot;#iterm2&quot; class=&quot;headerlink&quot; title=&quot;iterm2&quot;&gt;&lt;/a&gt;iterm2&lt;/h3&gt;&lt;p&gt;宿主用这个，原先很排斥在终端写东西（不能用鼠标），不过后来一手菜鸡操作&lt;code&gt;xj&lt;/code&gt;, &lt;code&gt;xk&lt;/code&gt;还有&lt;code&gt;wwwwwwww...&lt;/code&gt;也能达到需求了，应该没问题了。&lt;br&gt;
    
    </summary>
    
      <category term="实践尝试" scheme="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="vim" scheme="https://colmugx.github.io/blog/tags/vim/"/>
    
  </entry>
  
</feed>
